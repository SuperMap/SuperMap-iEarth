define(["./createTaskProcessorWorker","./defaultValue-2110bb17","./WebMercatorProjection-c3d13a47","./Ellipsoid-ca2b8eb1","./Cartographic-630e5de6","./Cartesian3-c1138337","./Color-75231487","./FeatureDetection-e7fb956a","./Math-cd1437d9","./Check-92c551fb","./defer-a21481c0"],(function(e,t,n,r,o,s,a,i,u,c,l){"use strict";function f(e){return c.o.defined("value",e),e<=.04045?.07739938080495357*e:Math.pow(.9478672985781991*(e+.055),2.4)}let h;function y(e,t,n,r){return r[e+t*n]}function b(e,t,n){const r=n.nativeExtent;let o=(e-r.west)/(r.east-r.west)*(n.width-1),s=(t-r.south)/(r.north-r.south)*(n.height-1);const a=Math.floor(o);let i=Math.floor(s);o-=a,s-=i;const u=a<n.width?a+1:a;let c=i<n.height?i+1:i;i=n.height-1-i,c=n.height-1-c;let l=function(e,t,n,r,o,s){return(n*(1-e)+r*e)*(1-t)+(o*(1-e)+s*e)*t}(o,s,y(a,i,n.width,n.buffer),y(u,i,n.width,n.buffer),y(a,c,n.width,n.buffer),y(u,c,n.width,n.buffer));return l=l*n.scale+n.offset,l}function g(e,t,a){for(let i=0;i<a.length;i++){const u=a[i].nativeExtent;let c=new s.o;if("WebMercator"===a[i].projectionType){const s=a[i].projection._ellipsoid._radii;c=new n.t(new r.t(s.x,s.y,s.z)).project(new o.a(e,t,0))}else c.x=e,c.y=t;if(c.x>u.west&&c.x<u.east&&c.y>u.south&&c.y<u.north)return b(c.x,c.y,a[i])}return 0}function p(e,n,r){const o=n[r];if(t.e(o))return o;const s=n[r]={positions:{},indices:{},edges:{}},a=t.u(e[r],e.default);return s.hasOutline=t.e(a?.edges),s}function d(e,n,r,o){if(!t.e(e[r])){const s=3*r;let a=n;for(let e=0;e<3;e++){const n=o[s+e];t.e(a[n])||(a[n]={}),a=a[n]}t.e(a.index)||(a.index=r),e[r]=a.index}}function m(e,n,r,o,s,a){let i,u;o<s?(i=o,u=s):(i=s,u=o);let c=e[i];t.e(c)||(c=e[i]={});let l=c[u];t.e(l)||(l=c[u]={normalsIndex:[],outlines:[]}),l.normalsIndex.push(a),0!==l.outlines.length&&n===o&&r===s||l.outlines.push(n,r)}const A=new s.o,w=new s.o,x=new s.o;function I(e,t,n,r){const o=3*n[t],a=3*n[t+1],i=3*n[t+2];s.o.fromArray(r,o,A),s.o.fromArray(r,a,w),s.o.fromArray(r,i,x),s.o.subtract(w,A,w),s.o.subtract(x,A,x),s.o.cross(w,x,A);const u=s.o.magnitude(A);0!==u&&s.o.divideByScalar(A,u,A);const c=3*t,l=3*(t+1),f=3*(t+2);s.o.pack(A,e,c),s.o.pack(A,e,l),s.o.pack(A,e,f)}const v=new s.o,L=new s.o;function C(e,t,n){s.o.fromArray(e,t,v),s.o.fromArray(e,n,L);const r=s.o.dot(v,L),o=s.o.magnitude(s.o.cross(v,L,v));return Math.atan2(o,r)<.25}function O(e,n,r,o,s){if(n.normalsIndex.length>1){const e=o.length===s.length;for(let a=0;a<n.normalsIndex.length;a++){const i=n.normalsIndex[a];if(t.e(s[3*i])||I(s,i,r,o),0!==a)for(let t=0;t<a;t++){const o=n.normalsIndex[t];if(C(s,e?3*r[i]:3*i,e?3*r[o]:3*o))return}}}e.push(...n.outlines)}function _(e,t,n,r,o){const s=Object.keys(t);for(let a=0;a<s.length;a++){const i=t[s[a]],u=Object.keys(i);for(let t=0;t<u.length;t++){O(e,i[u[t]],n,r,o)}}}function R(e,n,r,o,s){if(!t.e(e)||0===Object.keys(e).length)return;const a=function(e,n,r,o){const s=[];for(let a=0;a<r.length;a+=3){const i=p(e,s,t.e(n)?n[r[a]]:"default");if(!i.hasOutline)continue;const u=i.indices,c=i.positions;for(let e=0;e<3;e++)d(u,c,r[a+e],o);const l=i.edges;for(let e=0;e<3;e++){const t=r[a+e],n=r[a+(e+1)%3];m(l,t,n,u[t],u[n],a)}}return s}(e,n,r,o);t.e(s)&&3*r.length===s.length||(s=[]);const i=function(e,t,n,r){const o=[],s=Object.keys(e);for(let a=0;a<s.length;a++)_(o,e[s[a]].edges,t,n,r);return o}(a,r,o,s);return i.length>0?new Uint32Array(i):void 0}function T(e,n,r,o,s,i,u,c){if(0===e||!t.e(r)||0===r.length)return{buffers:[],bufferViews:[],accessors:[],meshes:[],nodes:[],nodesInScene:[]};const l=[],h=[],y=[],b=[],g=[],p=[],d={},m=[];t.e(n)&&(e=n.length);const{indexArray:A,transparentVertexOffset:w}=function(e,n,r,o){const s=new Uint32Array(e),a=t.e(n)?e=>n[e]:e=>e;let i=0;if(o&&t.e(r)){const t=e=>r[4*a(e)+3]<255;for(let n=0;n<e;n+=3)t(n)||t(n+1)||t(n+2)||(s[i++]=a(n),s[i++]=a(n+1),s[i++]=a(n+2));if(i>0){let n=i;for(let r=0;r<e;r+=3)(t(r)||t(r+1)||t(r+2))&&(s[n++]=a(r),s[n++]=a(r+1),s[n++]=a(r+2))}else for(let t=0;t<e;++t)s[t]=a(t)}else{i=e;for(let t=0;t<e;++t)s[t]=a(t)}return{indexArray:s,transparentVertexOffset:i}}(e,n,i,c.splitGeometryByColorTransparency),x=new Blob([A],{type:"application/binary"}),I=URL.createObjectURL(x),v=e,L=c.enableFeatures&&t.e(u)?new Float32Array(u.length):void 0;let C,O=0;if(t.e(L))for(let e=0;e<u.length;++e){L[e]=u[e];const t=u[e]+1;O<t&&(O=t)}const _=R(c.symbologyData,u,A,r,o);if(t.e(_)){const e=new Blob([_],{type:"application/binary"});C=URL.createObjectURL(e)}const T=r.subarray(0,3*v),U=new Blob([T],{type:"application/binary"}),F=URL.createObjectURL(U);let V=Number.POSITIVE_INFINITY,D=Number.NEGATIVE_INFINITY,E=Number.POSITIVE_INFINITY,G=Number.NEGATIVE_INFINITY,N=Number.POSITIVE_INFINITY,M=Number.NEGATIVE_INFINITY;for(let e=0;e<T.length/3;e++)V=Math.min(V,T[3*e+0]),D=Math.max(D,T[3*e+0]),E=Math.min(E,T[3*e+1]),G=Math.max(G,T[3*e+1]),N=Math.min(N,T[3*e+2]),M=Math.max(M,T[3*e+2]);const B=o?o.subarray(0,3*v):void 0;let S;if(t.e(B)){const e=new Blob([B],{type:"application/binary"});S=URL.createObjectURL(e)}const j=s?s.subarray(0,2*v):void 0;let P;if(t.e(j)){const e=new Blob([j],{type:"application/binary"});P=URL.createObjectURL(e)}const k=t.e(i)?function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;n+=4)t[n]=f(a.e.byteToFloat(e[n])),t[n+1]=f(a.e.byteToFloat(e[n+1])),t[n+2]=f(a.e.byteToFloat(e[n+2])),t[n+3]=a.e.byteToFloat(e[n+3]);return t}(i.subarray(0,4*v)):void 0;let q;if(t.e(k)){const e=new Blob([k],{type:"application/binary"});q=URL.createObjectURL(e)}const z=t.e(L)?L.subarray(0,v):void 0;let X;if(t.e(z)){const e=new Blob([z],{type:"application/binary"});X=URL.createObjectURL(e)}const Y=t.e(L)?new Float32Array(O):void 0;let W;if(t.e(Y)){for(let e=0;e<Y.length;++e)Y[e]=e;const e=new Blob([Y],{type:"application/binary"});W=URL.createObjectURL(e)}const H={},Q={};H.POSITION=y.length,l.push({uri:F,byteLength:T.byteLength}),h.push({buffer:l.length-1,byteOffset:0,byteLength:T.byteLength,target:34962}),y.push({bufferView:h.length-1,byteOffset:0,componentType:5126,count:T.length/3,type:"VEC3",max:[V,E,N],min:[D,G,M]}),t.e(S)&&(H.NORMAL=y.length,l.push({uri:S,byteLength:B.byteLength}),h.push({buffer:l.length-1,byteOffset:0,byteLength:B.byteLength,target:34962}),y.push({bufferView:h.length-1,byteOffset:0,componentType:5126,count:B.length/3,type:"VEC3"})),t.e(P)&&(H.TEXCOORD_0=y.length,l.push({uri:P,byteLength:j.byteLength}),h.push({buffer:l.length-1,byteOffset:0,byteLength:j.byteLength,target:34962}),y.push({bufferView:h.length-1,byteOffset:0,componentType:5126,count:j.length/2,type:"VEC2"})),t.e(q)&&(H.COLOR_0=y.length,l.push({uri:q,byteLength:k.byteLength}),h.push({buffer:l.length-1,byteOffset:0,byteLength:k.byteLength,target:34962}),y.push({bufferView:h.length-1,byteOffset:0,componentType:5126,count:k.length/4,type:"VEC4"})),t.e(X)&&(H._FEATURE_ID_0=y.length,l.push({uri:X,byteLength:z.byteLength}),h.push({buffer:l.length-1,byteOffset:0,byteLength:z.byteLength,target:34963}),y.push({bufferView:h.length-1,byteOffset:0,componentType:5126,count:z.length,type:"SCALAR"}),Q.EXT_mesh_features={featureIds:[{attribute:0,propertyTable:0,featureCount:O}]},m.push("EXT_mesh_features")),t.e(W)&&(l.push({uri:W,byteLength:Y.byteLength}),h.push({buffer:l.length-1,byteOffset:0,byteLength:Y.byteLength,target:34963}),d.EXT_structural_metadata={schema:{id:"i3s-metadata-schema-001",name:"I3S metadata schema 001",description:"The schema for I3S metadata",version:"1.0",classes:{feature:{name:"feature",description:"Feature metadata",properties:{index:{description:"The feature index",type:"SCALAR",componentType:"FLOAT32",required:!0}}}}},propertyTables:[{name:"feature-indices-mapping",class:"feature",count:O,properties:{index:{values:h.length-1}}}]},m.push("EXT_structural_metadata")),t.e(C)&&(l.push({uri:C,byteLength:_.byteLength}),h.push({buffer:l.length-1,byteOffset:0,byteLength:_.byteLength,target:34963}),y.push({bufferView:h.length-1,byteOffset:0,componentType:5125,count:_.length,type:"SCALAR"}),Q.CESIUM_primitive_outline={indices:y.length-1},m.push("CESIUM_primitive_outline")),l.push({uri:I,byteLength:A.byteLength}),h.push({buffer:l.length-1,byteOffset:0,byteLength:A.byteLength,target:34963});const J=[];return w>0&&(y.push({bufferView:h.length-1,byteOffset:0,componentType:5125,count:w,type:"SCALAR"}),J.push({attributes:H,indices:y.length-1,material:J.length,extensions:Q})),w<e&&(y.push({bufferView:h.length-1,byteOffset:4*w,componentType:5125,count:e-w,type:"SCALAR"}),J.push({attributes:H,indices:y.length-1,material:J.length,extensions:Q,extra:{isTransparent:!0}})),b.push({primitives:J}),p.push(0),g.push({mesh:0}),{buffers:l,bufferViews:h,accessors:y,meshes:b,nodes:g,nodesInScene:p,rootExtensions:d,extensionsUsed:m}}function U(e,n,r,o){const s=new Uint8Array(e,0,5);return s[0]==="D".charCodeAt()&&s[1]==="R".charCodeAt()&&s[2]==="A".charCodeAt()&&s[3]==="C".charCodeAt()&&s[4]==="O".charCodeAt()?function(e){const n=h,r=new n.DecoderBuffer,o=new Uint8Array(e);r.Init(o,o.length);const s=new n.Decoder,a=s.GetEncodedGeometryType(r),i=new n.MetadataQuerier;let u,c;a===n.TRIANGULAR_MESH&&(u=new n.Mesh,c=s.DecodeBufferToMesh(r,u));const l={vertexCount:[0],featureCount:0};if(t.e(c)&&c.ok()&&0!==u.ptr){const e=u.num_faces(),r=u.num_attributes(),o=u.num_points();l.indices=new Uint32Array(3*e);const a=l.indices;l.vertexCount[0]=o,l.scale_x=1,l.scale_y=1;const c=new n.DracoInt32Array(3);for(let t=0;t<e;++t)s.GetFaceFromMesh(u,t,c),a[3*t]=c.GetValue(0),a[3*t+1]=c.GetValue(1),a[3*t+2]=c.GetValue(2);n.destroy(c);for(let e=0;e<r;++e){const r=s.GetAttribute(u,e),a=F(n,s,u,r,o),c=r.attribute_type();let f="unknown";c===n.POSITION?f="positions":c===n.NORMAL?f="normals":c===n.COLOR?f="colors":c===n.TEX_COORD&&(f="uv0s");const h=s.GetAttributeMetadata(u,e);if(0!==h.ptr){const e=i.NumEntries(h);for(let t=0;t<e;++t){const e=i.GetEntryName(h,t);"i3s-scale_x"===e?l.scale_x=i.GetDoubleEntry(h,"i3s-scale_x"):"i3s-scale_y"===e?l.scale_y=i.GetDoubleEntry(h,"i3s-scale_y"):"i3s-attribute-type"===e&&(f=i.GetStringEntry(h,"i3s-attribute-type"))}}t.e(l[f])&&console.log("Attribute already exists",f),l[f]=a,"feature-index"===f&&l.featureCount++}n.destroy(u)}return n.destroy(i),n.destroy(s),l}(e):function(e,n,r,o){const s={vertexCount:0},a=new DataView(e);try{let i=0;if(s.vertexCount=a.getUint32(i,1),i+=4,s.featureCount=a.getUint32(i,1),i+=4,t.e(r))for(let n=0;n<r.attributes.length;n++)t.e(V[r.attributes[n]])?i=V[r.attributes[n]](s,e,i):console.error("Unknown decoder for",r.attributes[n]);else{let r=n.ordering,a=n.featureAttributeOrder;t.e(o)&&t.e(o.geometryData)&&t.e(o.geometryData[0])&&t.e(o.geometryData[0].params)&&(r=Object.keys(o.geometryData[0].params.vertexAttributes),a=Object.keys(o.geometryData[0].params.featureAttributes));for(let t=0;t<r.length;t++){i=(0,V[r[t]])(s,e,i)}for(let t=0;t<a.length;t++){i=(0,V[a[t]])(s,e,i)}}}catch(e){console.error(e)}return s.scale_x=1,s.scale_y=1,s}(e,n,r,o)}function F(e,n,r,o,s){const a=o.num_components()*s;let i;const u=[function(){},function(){i=new e.DracoInt8Array(a);n.GetAttributeInt8ForAllPoints(r,o,i)||console.error("Bad stream");const t=new Int8Array(a);for(let e=0;e<a;++e)t[e]=i.GetValue(e);return t},function(){i=new e.DracoInt8Array(a);n.GetAttributeUInt8ForAllPoints(r,o,i)||console.error("Bad stream");const t=new Uint8Array(a);for(let e=0;e<a;++e)t[e]=i.GetValue(e);return t},function(){i=new e.DracoInt16Array(a);n.GetAttributeInt16ForAllPoints(r,o,i)||console.error("Bad stream");const t=new Int16Array(a);for(let e=0;e<a;++e)t[e]=i.GetValue(e);return t},function(){i=new e.DracoInt16Array(a);n.GetAttributeUInt16ForAllPoints(r,o,i)||console.error("Bad stream");const t=new Uint16Array(a);for(let e=0;e<a;++e)t[e]=i.GetValue(e);return t},function(){i=new e.DracoInt32Array(a);n.GetAttributeInt32ForAllPoints(r,o,i)||console.error("Bad stream");const t=new Int32Array(a);for(let e=0;e<a;++e)t[e]=i.GetValue(e);return t},function(){i=new e.DracoInt32Array(a);n.GetAttributeUInt32ForAllPoints(r,o,i)||console.error("Bad stream");const t=new Uint32Array(a);for(let e=0;e<a;++e)t[e]=i.GetValue(e);return t},function(){},function(){},function(){i=new e.DracoFloat32Array(a);n.GetAttributeFloatForAllPoints(r,o,i)||console.error("Bad stream");const t=new Float32Array(a);for(let e=0;e<a;++e)t[e]=i.GetValue(e);return t},function(){},function(){i=new e.DracoUInt8Array(a);n.GetAttributeUInt8ForAllPoints(r,o,i)||console.error("Bad stream");const t=new Uint8Array(a);for(let e=0;e<a;++e)t[e]=i.GetValue(e);return t}],c=u[o.data_type()]();return t.e(i)&&e.destroy(i),c}const V={position:function(e,t,n){const r=3*e.vertexCount;return e.positions=new Float32Array(t,n,r),n+=4*r},normal:function(e,t,n){const r=3*e.vertexCount;return e.normals=new Float32Array(t,n,r),n+=4*r},uv0:function(e,t,n){const r=2*e.vertexCount;return e.uv0s=new Float32Array(t,n,r),n+=4*r},color:function(e,t,n){const r=4*e.vertexCount;return e.colors=new Uint8Array(t,n,r),n+=r},featureId:function(e,t,n){return n+=8*e.featureCount},id:function(e,t,n){return n+=8*e.featureCount},faceRange:function(e,t,n){const r=2*e.featureCount;return e.faceRange=new Uint32Array(t,n,r),n+=4*r},uvRegion:function(e,t,n){const r=4*e.vertexCount;return e["uv-region"]=new Uint16Array(t,n,r),n+=2*r},region:function(e,t,n){const r=4*e.vertexCount;return e["uv-region"]=new Uint16Array(t,n,r),n+=2*r}};function D(e){const n=U(e.binaryData,e.schema,e.bufferInfo,e.featureData);let a;if(t.e(e.geoidDataList)&&e.geoidDataList.length>0&&function(e,t,n,r,o,s,a){if(a)return;const i=g(o.longitude,o.latitude,s);for(let a=0;a<e;++a){const e=g(o.longitude+u.e.toRadians(n*t[3*a]),o.latitude+u.e.toRadians(r*t[3*a+1]),s);t[3*a+2]+=e-i}}(n.vertexCount,n.positions,n.scale_x,n.scale_y,e.cartographicCenter,e.geoidDataList,!1),function(e,n,a,c,l,f,h,y,b){if(0===e||!t.e(n)||0===n.length)return;const g=new r.t(Math.sqrt(h.x),Math.sqrt(h.y),Math.sqrt(h.z));for(let r=0;r<e;++r){const e=3*r,h=e+1,p=e+2,d=new o.a;d.longitude=c.longitude+u.e.toRadians(y*n[e]),d.latitude=c.latitude+u.e.toRadians(b*n[h]),d.height=c.height+n[p];const m={};g.cartographicToCartesian(d,m),m.x-=l.x,m.y-=l.y,m.z-=l.z;const A={};if(i.p.multiplyByVector(f,m,A),n[e]=A.x,n[h]=A.y,n[p]=A.z,t.e(a)){const t=new s.o(a[e],a[h],a[p]),n={};i.p.multiplyByVector(f,t,n),a[e]=n.x,a[h]=n.y,a[p]=n.z}}}(n.vertexCount,n.positions,n.normals,e.cartographicCenter,e.cartesianCenter,e.parentRotation,e.ellipsoidRadiiSquare,n.scale_x,n.scale_y),t.e(n.uv0s)&&t.e(n["uv-region"])&&function(e,t,n){for(let r=0;r<e;++r){const e=n[4*r]/65535,o=n[4*r+1]/65535,s=(n[4*r+2]-n[4*r])/65535,a=(n[4*r+3]-n[4*r+1])/65535;t[2*r]*=s,t[2*r]+=e,t[2*r+1]*=a,t[2*r+1]+=o}}(n.vertexCount,n.uv0s,n["uv-region"]),t.e(n["feature-index"]))a=n["feature-index"];else if(t.e(n.faceRange)){a=new Array(n.vertexCount);for(let e=0;e<n.faceRange.length-1;e+=2){const t=e/2,r=n.faceRange[e],o=n.faceRange[e+1];for(let e=r;e<=o;e++)a[3*e]=t,a[3*e+1]=t,a[3*e+2]=t}}if(e.calculateNormals){const e=function(e,n,r,o,s,a,i){const u={normals:void 0,positions:void 0,uv0s:void 0,colors:void 0,featureIndex:void 0,vertexCount:void 0};if(0===e||!t.e(r)||0===r.length||t.e(o))return u;if(t.e(n)){u.vertexCount=n.length,u.positions=new Float32Array(3*n.length),u.uv0s=t.e(s)?new Float32Array(2*n.length):void 0,u.colors=t.e(a)?new Uint8Array(4*n.length):void 0,u.featureIndex=t.e(i)?new Array(n.length):void 0;for(let e=0;e<n.length;e++){const o=n[e];u.positions[3*e]=r[3*o],u.positions[3*e+1]=r[3*o+1],u.positions[3*e+2]=r[3*o+2],t.e(u.uv0s)&&(u.uv0s[2*e]=s[2*o],u.uv0s[2*e+1]=s[2*o+1]),t.e(u.colors)&&(u.colors[4*e]=a[4*o],u.colors[4*e+1]=a[4*o+1],u.colors[4*e+2]=a[4*o+2],u.colors[4*e+3]=a[4*o+3]),t.e(u.featureIndex)&&(u.featureIndex[e]=i[o])}e=n.length,r=u.positions}n=new Array(e);for(let t=0;t<e;t++)n[t]=t;u.normals=new Float32Array(3*n.length);for(let e=0;e<n.length;e+=3)I(u.normals,e,n,r);return u}(n.vertexCount,n.indices,n.positions,n.normals,n.uv0s,n.colors,a);t.e(e.normals)&&(n.normals=e.normals,t.e(e.vertexCount)&&(n.vertexCount=e.vertexCount,n.indices=e.indices,n.positions=e.positions,n.uv0s=e.uv0s,n.colors=e.colors,a=e.featureIndex))}const c=T(n.vertexCount,n.indices,n.positions,n.normals,n.uv0s,n.colors,a,e),l={positions:n.positions,indices:n.indices,featureIndex:a,sourceURL:e.url,cartesianCenter:e.cartesianCenter,parentRotation:e.parentRotation};c._customAttributes=l;return{meshData:c}}function E(t){h=t,self.onmessage=e(D),self.postMessage(!0)}return function(e,n){var r=e.data.webAssemblyConfig;if(t.e(r))return require([r.modulePath],(function(e){t.e(r.wasmBinaryFile)?(t.e(e)||(e=self.DracoDecoderModule),e(r).then((function(e){E(e)}))):E(e())}))}}));
