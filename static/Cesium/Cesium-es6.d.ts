
export namespace Viewer {
  /**
   * Initialization options for the Viewer constructor
   * @property [animation = true] - If set to false, the Animation widget will not be created.
   * @property [baseLayerPicker = true] - If set to false, the BaseLayerPicker widget will not be created.
   * @property [fullscreenButton = true] - If set to false, the FullscreenButton widget will not be created.
   * @property [vrButton = false] - If set to true, the VRButton widget will be created.
   * @property [geocoder = true] - If set to false, the Geocoder widget will not be created.
   * @property [homeButton = true] - If set to false, the HomeButton widget will not be created.
   * @property [infoBox = true] - If set to false, the InfoBox widget will not be created.
   * @property [sceneModePicker = true] - If set to false, the SceneModePicker widget will not be created.
   * @property [selectionIndicator = true] - If set to false, the SelectionIndicator widget will not be created.
   * @property [timeline = true] - If set to false, the Timeline widget will not be created.
   * @property [navigationHelpButton = true] - If set to false, the navigation help button will not be created.
   * @property [navigationInstructionsInitiallyVisible = true] - True if the navigation instructions should initially be visible, or false if the should not be shown until the user explicitly clicks the button.
   * @property [scene3DOnly = false] - When <code>true</code>, each geometry instance will only be rendered in 3D to save GPU memory.
   * @property [shouldAnimate = false] - <code>true</code> if the clock should attempt to advance simulation time by default, <code>false</code> otherwise.  This option takes precedence over setting {@link Viewer#clockViewModel}.
   * @property [clockViewModel = new ClockViewModel(clock)] - The clock view model to use to control current time.
   * @property [selectedImageryProviderViewModel] - The view model for the current base imagery layer, if not supplied the first available base layer is used.  This value is only valid if `baseLayerPicker` is set to true.
   * @property [imageryProviderViewModels = createDefaultImageryProviderViewModels()] - The array of ProviderViewModels to be selectable from the BaseLayerPicker.  This value is only valid if `baseLayerPicker` is set to true.
   * @property [selectedTerrainProviderViewModel] - The view model for the current base terrain layer, if not supplied the first available base layer is used.  This value is only valid if `baseLayerPicker` is set to true.
   * @property [terrainProviderViewModels = createDefaultTerrainProviderViewModels()] - The array of ProviderViewModels to be selectable from the BaseLayerPicker.  This value is only valid if `baseLayerPicker` is set to true.
   * @property [imageryProvider = createWorldImagery()] - The imagery provider to use.  This value is only valid if `baseLayerPicker` is set to false.
   * @property [terrainProvider = new EllipsoidTerrainProvider()] - The terrain provider to use
   * @property [skyBox] - The skybox used to render the stars.  When <code>undefined</code>, the default stars are used. If set to <code>false</code>, no skyBox, Sun, or Moon will be added.
   * @property [skyAtmosphere] - Blue sky, and the glow around the Earth's limb.  Set to <code>false</code> to turn it off.
   * @property [fullscreenElement = document.body] - The element or id to be placed into fullscreen mode when the full screen button is pressed.
   * @property [useDefaultRenderLoop = true] - True if this widget should control the render loop, false otherwise.
   * @property [targetFrameRate] - The target frame rate when using the default render loop.
   * @property [showRenderLoopErrors = true] - If true, this widget will automatically display an HTML panel to the user containing the error, if a render loop error occurs.
   * @property [useBrowserRecommendedResolution = true] - If true, render at the browser's recommended resolution and ignore <code>window.devicePixelRatio</code>.
   * @property [automaticallyTrackDataSourceClocks = true] - If true, this widget will automatically track the clock settings of newly added DataSources, updating if the DataSource's clock changes.  Set this to false if you want to configure the clock independently.
   * @property [contextOptions] - Context and WebGL creation properties corresponding to <code>options</code> passed to {@link Scene}.
   * @property [sceneMode = SceneMode.SCENE3D] - The initial scene mode.
   * @property [mapProjection = new GeographicProjection()] - The map projection to use in 2D and Columbus View modes.
   * @property [globe = new Globe(mapProjection.ellipsoid)] - The globe to use in the scene.  If set to <code>false</code>, no globe will be added.
   * @property [orderIndependentTranslucency = true] - If true and the configuration supports it, use order independent translucency.
   * @property [creditContainer] - The DOM element or ID that will contain the {@link CreditDisplay}.  If not specified, the credits are added to the bottom of the widget itself.
   * @property [creditViewport] - The DOM element or ID that will contain the credit pop up created by the {@link CreditDisplay}.  If not specified, it will appear over the widget itself.
   * @property [dataSources = new DataSourceCollection()] - The collection of data sources visualized by the widget.  If this parameter is provided,
   *                               the instance is assumed to be owned by the caller and will not be destroyed when the viewer is destroyed.
   * @property [shadows = false] - Determines if shadows are cast by light sources.
   * @property [terrainShadows = ShadowMode.RECEIVE_ONLY] - Determines if the terrain casts or receives shadows from light sources.
   * @property [mapMode2D = MapMode2D.INFINITE_SCROLL] - Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
   * @property [projectionPicker = false] - If set to true, the ProjectionPicker widget will be created.
   * @property [requestRenderMode = false] - If true, rendering a frame will only occur when needed as determined by changes within the scene. Enabling reduces the CPU/GPU usage of your application and uses less battery on mobile, but requires using {@link Scene#requestRender} to render a new frame explicitly in this mode. This will be necessary in many cases after making changes to the scene in other parts of the API. 
   * @property [maximumRenderTimeChange = 0.0] - If requestRenderMode is true, this value defines the maximum change in simulation time allowed before a render is requested. 
   * @property [depthPlaneEllipsoidOffset = 0.0] - Adjust the DepthPlane to address rendering artefacts below ellipsoid zero elevation.
   * @property [msaaSamples = 1] - If provided, this value controls the rate of multisample antialiasing. Typical multisampling rates are 2, 4, and sometimes 8 samples per pixel. Higher sampling rates of MSAA may impact performance in exchange for improved visual quality. This value only applies to WebGL2 contexts that support multisample render targets.
   */
  type ConstructorOptions = {
    animation?: boolean;
    baseLayerPicker?: boolean;
    fullscreenButton?: boolean;
    vrButton?: boolean;
    geocoder?: boolean | GeocoderService[];
    homeButton?: boolean;
    infoBox?: boolean;
    sceneModePicker?: boolean;
    selectionIndicator?: boolean;
    timeline?: boolean;
    navigationHelpButton?: boolean;
    navigationInstructionsInitiallyVisible?: boolean;
    scene3DOnly?: boolean;
    shouldAnimate?: boolean;
    clockViewModel?: ClockViewModel;
    selectedImageryProviderViewModel?: ProviderViewModel;
    imageryProviderViewModels?: ProviderViewModel[];
    selectedTerrainProviderViewModel?: ProviderViewModel;
    terrainProviderViewModels?: ProviderViewModel[];
    imageryProvider?: ImageryProvider;
    terrainProvider?: TerrainProvider;
    skyBox?: SkyBox | false;
    skyAtmosphere?: SkyAtmosphere | false;
    fullscreenElement?: Element | string;
    useDefaultRenderLoop?: boolean;
    targetFrameRate?: number;
    showRenderLoopErrors?: boolean;
    useBrowserRecommendedResolution?: boolean;
    automaticallyTrackDataSourceClocks?: boolean;
    contextOptions?: any;
    sceneMode?: SceneMode;
    mapProjection?: MapProjection;
    globe?: Globe | false;
    orderIndependentTranslucency?: boolean;
    creditContainer?: Element | string;
    creditViewport?: Element | string;
    dataSources?: DataSourceCollection;
    shadows?: boolean;
    terrainShadows?: ShadowMode;
    mapMode2D?: MapMode2D;
    projectionPicker?: boolean;
    requestRenderMode?: boolean;
    maximumRenderTimeChange?: number;
    depthPlaneEllipsoidOffset?: number;
    msaaSamples?: number;
  };
  /**
   * A function that augments a Viewer instance with additional functionality.
   * @param viewer - The viewer instance.
   * @param options - Options object to be passed to the mixin function.
   */
  type ViewerMixin = (viewer: Viewer, options: any) => void;
}

/**
* 用于构建应用程序的基本小部件.  它将所有标准的Cesium小部件组合成一个可重用的包.
* 小部件总是可以通过使用mixin进行扩展，mixin为各种应用程序添加了有用的功能.
* @example
* //使用几个自定义选项和mixins初始化查看器小部件.
* const viewer = new Cesium.Viewer('CesiumContainer', {
*     sceneMode : Cesium.SceneMode.COLUMBUS_VIEW,
*     terrainProvider : Cesium.createWorldTerrain(),
*     baseLayerPicker : false,
*     imageryProvider : new Cesium.OpenStreetMapImageryProvider({
*         url : 'https://a.tile.openstreetmap.org/'
*     }),
*     skyBox : new Cesium.SkyBox({
*         sources : {
*           positiveX : 'stars/TychoSkymapII.t3_08192x04096_80_px.jpg',
*           negativeX : 'stars/TychoSkymapII.t3_08192x04096_80_mx.jpg',
*           positiveY : 'stars/TychoSkymapII.t3_08192x04096_80_py.jpg',
*           negativeY : 'stars/TychoSkymapII.t3_08192x04096_80_my.jpg',
*           positiveZ : 'stars/TychoSkymapII.t3_08192x04096_80_pz.jpg',
*           negativeZ : 'stars/TychoSkymapII.t3_08192x04096_80_mz.jpg'
*         }
*     }),
* });
* @param container - 包含Widget的DOM元素或ID
* @param [options] - 对象描述初始化选项
*/
export class Viewer {
  constructor(container: Element | string, options?: Viewer.ConstructorOptions);
  /**
   * Gets the parent container.
   */
  readonly container: Element;
  /**
   * Gets the DOM element for the area at the bottom of the window containing the
   * {@link CreditDisplay} and potentially other things.
   */
  readonly bottomContainer: Element;
  /**
   * Gets the CesiumWidget.
   */
  readonly CesiumWidget: CesiumWidget;
  /**
   * Gets the selection indicator.
   */
  readonly selectionIndicator: SelectionIndicator;
  /**
   * Gets the info box.
   */
  readonly infoBox: InfoBox;
  /**
   * Gets the Geocoder.
   */
  readonly geocoder: Geocoder;
  /**
   * Gets the HomeButton.
   */
  readonly homeButton: HomeButton;
  /**
   * Gets the SceneModePicker.
   */
  readonly sceneModePicker: SceneModePicker;
  /**
   * Gets the ProjectionPicker.
   */
  readonly projectionPicker: ProjectionPicker;
  /**
   * Gets the BaseLayerPicker.
   */
  readonly baseLayerPicker: BaseLayerPicker;
  /**
   * Gets the NavigationHelpButton.
   */
  readonly navigationHelpButton: NavigationHelpButton;
  /**
   * Gets the Animation widget.
   */
  readonly animation: Animation;
  /**
   * Gets the Timeline widget.
   */
  readonly timeline: Timeline;
  /**
   * Gets the FullscreenButton.
   */
  readonly fullscreenButton: FullscreenButton;
  /**
   * Gets the VRButton.
   */
  readonly vrButton: VRButton;
  /**
   * Gets the display used for {@link DataSource} visualization.
   */
  readonly dataSourceDisplay: DataSourceDisplay;
  /**
   * Gets the collection of entities not tied to a particular data source.
   * This is a shortcut to [dataSourceDisplay.defaultDataSource.entities]{@link Viewer#dataSourceDisplay}.
   */
  readonly entities: EntityCollection;
  /**
   * Gets the set of {@link DataSource} instances to be visualized.
   */
  readonly dataSources: DataSourceCollection;
  /**
   * Gets the canvas.
   */
  readonly canvas: HTMLCanvasElement;
  /**
   * Gets the scene.
   */
  readonly scene: Scene;
  /**
   * Determines if shadows are cast by light sources.
   */
  shadows: boolean;
  /**
   * Determines if the terrain casts or shadows from light sources.
   */
  terrainShadows: ShadowMode;
  /**
   * Get the scene's shadow map
   */
  readonly shadowMap: ShadowMap;
  /**
   * Gets the collection of image layers that will be rendered on the globe.
   */
  readonly imageryLayers: ImageryLayerCollection;
  /**
   * The terrain provider providing surface geometry for the globe.
   */
  terrainProvider: TerrainProvider;
  /**
   * Gets the camera.
   */
  readonly camera: Camera;
  /**
   * Gets the post-process stages.
   */
  readonly postProcessStages: PostProcessStageCollection;
  /**
   * Gets the clock.
   */
  readonly clock: Clock;
  /**
   * Gets the clock view model.
   */
  readonly clockViewModel: ClockViewModel;
  /**
   * Gets the screen space event handler.
   */
  readonly screenSpaceEventHandler: ScreenSpaceEventHandler;
  /**
   * Gets or sets the target frame rate of the widget when <code>useDefaultRenderLoop</code>
   * is true. If undefined, the browser's {@link requestAnimationFrame} implementation
   * determines the frame rate.  If defined, this value must be greater than 0.  A value higher
   * than the underlying requestAnimationFrame implementation will have no effect.
   */
  targetFrameRate: number;
  /**
   * Gets or sets whether or not this widget should control the render loop.
   * If set to true the widget will use {@link requestAnimationFrame} to
   * perform rendering and resizing of the widget, as well as drive the
   * simulation clock. If set to false, you must manually call the
   * <code>resize</code>, <code>render</code> methods
   * as part of a custom render loop.  If an error occurs during rendering, {@link Scene}'s
   * <code>renderError</code> event will be raised and this property
   * will be set to false.  It must be set back to true to continue rendering
   * after the error.
   */
  useDefaultRenderLoop: boolean;
  /**
   * Gets or sets a scaling factor for rendering resolution.  Values less than 1.0 can improve
   * performance on less powerful devices while values greater than 1.0 will render at a higher
   * resolution and then scale down, resulting in improved visual fidelity.
   * For example, if the widget is laid out at a size of 640x480, setting this value to 0.5
   * will cause the scene to be rendered at 320x240 and then scaled up while setting
   * it to 2.0 will cause the scene to be rendered at 1280x960 and then scaled down.
   */
  resolutionScale: number;
  /**
   * Boolean flag indicating if the browser's recommended resolution is used.
   * If true, the browser's device pixel ratio is ignored and 1.0 is used instead,
   * effectively rendering based on CSS pixels instead of device pixels. This can improve
   * performance on less powerful devices that have high pixel density. When false, rendering
   * will be in device pixels. {@link Viewer#resolutionScale} will still take effect whether
   * this flag is true or false.
   */
  useBrowserRecommendedResolution: boolean;
  /**
   * Gets or sets whether or not data sources can temporarily pause
   * animation in order to avoid showing an incomplete picture to the user.
   * For example, if asynchronous primitives are being processed in the
   * background, the clock will not advance until the geometry is ready.
   */
  allowDataSourcesToSuspendAnimation: boolean;
  /**
   * Gets or sets the Entity instance currently being tracked by the camera.
   */
  trackedEntity: Entity | undefined;
  /**
   * Gets or sets the object instance for which to display a selection indicator.
   *
   * If a user interactively picks a Cesium3DTilesFeature instance, then this property
   * will contain a transient Entity instance with a property named "feature" that is
   * the instance that was picked.
   */
  selectedEntity: Entity | undefined;
  /**
   * Gets the event that is raised when the selected entity changes.
   */
  readonly selectedEntityChanged: Event;
  /**
   * Gets the event that is raised when the tracked entity changes.
   */
  readonly trackedEntityChanged: Event;
  /**
   * Gets or sets the data source to track with the viewer's clock.
   */
  clockTrackedDataSource: DataSource;
  /**
   * Extends the base viewer functionality with the provided mixin.
   * A mixin may add additional properties, functions, or other behavior
   * to the provided viewer instance.
   * @param mixin - The Viewer mixin to add to this instance.
   * @param [options] - The options object to be passed to the mixin function.
   */
  extend(mixin: Viewer.ViewerMixin, options?: any): void;
  /**
   * Resizes the widget to match the container size.
   * This function is called automatically as needed unless
   * <code>useDefaultRenderLoop</code> is set to false.
   */
  resize(): void;
  /**
   * This forces the widget to re-think its layout, including
   * widget sizes and credit placement.
   */
  forceResize(): void;
  /**
   * Renders the scene.  This function is called automatically
   * unless <code>useDefaultRenderLoop</code> is set to false;
   */
  render(): void;
  /**
   * @returns true if the object has been destroyed, false otherwise.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the widget.  Should be called if permanently
   * removing the widget from layout.
   */
  destroy(): void;
  /**
   * Asynchronously sets the camera to view the provided entity, entities, or data source.
   * If the data source is still in the process of loading or the visualization is otherwise still loading,
   * this method waits for the data to be ready before performing the zoom.
   *
   * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
   * The heading and the pitch angles are defined in the local east-north-up reference frame.
   * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
   * angles are above the plane. Negative pitch angles are below the plane. The range is the distance from the center. If the range is
   * zero, a range will be computed such that the whole bounding sphere is visible.</p>
   *
   * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
   * target will be the range. The heading will be determined from the offset. If the heading cannot be
   * determined from the offset, the heading will be north.</p>
   * @param target - The entity, array of entities, entity collection, data source, Cesium3DTileset, point cloud, or imagery layer to view. You can also pass a promise that resolves to one of the previously mentioned types.
   * @param [offset] - The offset from the center of the entity in the local east-north-up reference frame.
   * @returns A Promise that resolves to true if the zoom was successful or false if the target is not currently visualized in the scene or the zoom was cancelled.
   */
  // zoomTo(target: Entity | Entity[] | EntityCollection | DataSource | ImageryLayer | Cesium3DTileset | TimeDynamicPointCloud | Promise<Entity | Entity[] | EntityCollection | DataSource | ImageryLayer | Cesium3DTileset | TimeDynamicPointCloud>, offset?: HeadingPitchRange): Promise<boolean>;
  /**
   * Flies the camera to the provided entity, entities, or data source.
   * If the data source is still in the process of loading or the visualization is otherwise still loading,
   * this method waits for the data to be ready before performing the flight.
   *
   * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
   * The heading and the pitch angles are defined in the local east-north-up reference frame.
   * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
   * angles are above the plane. Negative pitch angles are below the plane. The range is the distance from the center. If the range is
   * zero, a range will be computed such that the whole bounding sphere is visible.</p>
   *
   * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
   * target will be the range. The heading will be determined from the offset. If the heading cannot be
   * determined from the offset, the heading will be north.</p>
   * @param target - The entity, array of entities, entity collection, data source, Cesium3DTileset, point cloud, or imagery layer to view. You can also pass a promise that resolves to one of the previously mentioned types.
   * @param [options] - Object with the following properties:
   * @param [options.duration = 3.0] - The duration of the flight in seconds.
   * @param [options.maximumHeight] - The maximum height at the peak of the flight.
   * @param [options.offset] - The offset from the target in the local east-north-up reference frame centered at the target.
   * @returns A Promise that resolves to true if the flight was successful or false if the target is not currently visualized in the scene or the flight was cancelled. //TODO: Cleanup entity mentions
   */
  // flyTo(target: Entity | Entity[] | EntityCollection | DataSource | ImageryLayer | Cesium3DTileset | TimeDynamicPointCloud | Promise<Entity | Entity[] | EntityCollection | DataSource | ImageryLayer | Cesium3DTileset | TimeDynamicPointCloud>, options?: {
  //   duration?: number;
  //   maximumHeight?: number;
  //   offset?: HeadingPitchRange;
  // }): Promise<boolean>;
}

type Scene = {
  /**
   * 获取场景的泛光效果，包括泛光强度值，泛光亮度阈值等
   */
  bloomEffect : BloomEffect,

  /**
   * 获取当前场景的相机对象
   */
  camera : Camera

  /**
   * 获取scene绑定的canvas元素
   */
  canvas : Element

  /**
   * 创建颜色校正对象
   */
  colorCorrection: any

  /**
   * 该属性仅用于调试，不用于生产。当为true时，绘制轮廓线展示相机平台的范围
   */
  debugShowFrustums : boolean

  /**
   * 获取场景的景深效果
   */
  depthOfFieldEffect : DepthOfFieldEffect

  /**
   * GL绘制缓冲区高度
   */
  drawingBufferHeight : number

  /**
   * GL绘制缓冲区宽度
   */
  drawingBufferWidth : number

  /**
   * 获取或者设置是否将场景绘制成图片。当关闭时，直接绘制到颜色缓冲区，画面效果更佳，但一些分析功能不可用。默认值为true
   */
  enableCompositor : boolean

  /**
   * 当前场景是否开启遮挡剔除
   */
  enableOcclude: boolean

  /**
   * The eye separation distance in meters for use with cardboard or WebVR
   */
  eyeSeparation : number

  /**
   * The focal length for use when with cardboard or WebVR.
   */
  focalLength : number

  /**
   * 设置视锥体容限值，默认值为0.0，最大值为0.5
   */
  frustumTolerance : Number

  /**
   * 获取地球对象
   */
  globe : Globe

  /**
   * 设置或获取当前场景的卷帘位置，有效值为0.0~1.0 Gets or sets the position of the globe splitter within the viewport. Valid values are between 0.0 and 1.0.
   */
  globeSplitPosition : Cartesian2

  /**
   * 获取所有贴地图元集合
   */
  groundPrimitives : PrimitiveCollection

  /**
   * 当前场景是否开启hdr
   */
  hdrEnabled:boolean

  /**
   * 获取当前场景的id
   */
  id : string 

  /**
   * 获取当前场景影像图层集合
   */
  imageryLayers : ImageryLayerCollection

  /**
   * 设置或获取当前场景的影像分隔条位置
   */
  imagerySplitPosition : number

  /**
   * When false, 3D Tiles will render normally. When true, classified 3D Tile geometry will render normally and unclassified 3D Tile geometry will render with the color multiplied by Scene#invertClassificationColor.
   */
  invertClassification : boolean

  /**
   * The highlight color of unclassified 3D Tile geometry when Scene#invertClassification is true.
   * When the color's alpha is less than 1.0, the unclassified portions of the 3D Tiles will not blend correctly with the classified positions of the 3D Tiles.
   * Also, when the color's alpha is less than 1.0, the WEBGL_depth_texture and EXT_frag_depth WebGL extensions must be supported.
   */
  invertClassificationColor : Color

  /**
   * 获取当前场景的三维切片缓存图层集合
   */
  layers : Layers

  /**
   * 获取当前场景中的光源
   */
  lightSource : LightSource

  /**
   * 获取或者设置是否使用对数深度缓冲区。当设置为true时，将会在混合多截锥中使用较少的截锥，详情可参见Cesium官网的说明
   */
  logarithmicDepthBuffer : boolean

  /**
   * 获取地图投影对象，用于2D或者Columbus View模式,默认为经纬度投影
   */
  mapProjection : MapProjection

  /**
   * 通过设置相机视角距离禁止布告板、标签和点对象的深度测试。例如，为了防止剪切地形数据，将距离设置为0则深度测试一直有效，将距离设置为小于0则深度测试失效。通过设置布告板、标签和点对象的disableDepthTestDistance属性修改距离值
   */
  minimumDisableDepthTestDistance : Number

  /**
   * 获取当前场景的模式
   */
  mode : SceneMode
  
  /**
   * 获取或者设置当前场景的多视口模式,默认单视口
   */
  MultiViewportMode : number

  /**
   * 设置度带偏移，加载有度带偏移的地图
   */
  originOffset : Cartesian2

  /**
   * 设置图层的避让参数。 可设置的参数为：allowIconWithTextDisplay,设置是否开启图标图层跟随文字图层避让。默认为true.
   */
  overlapDisplayOptions : object

  /**
   * 开启顶点捕捉功能，默认false，设置为true，则开启捕捉
   */
  pickPointEnabled : boolean

  /**
   * 设置点云捕捉的时间间隔
   */
  pickPointInterval : number

  /**
   * 当为true时，支持使用深度缓冲区拾取半透明的几何图形。Scene#useDepthPicking也必须为true，支持拾取深度缓冲区。使用时性能有所下降，对于半透明的几何图形，将调用额外的绘图命令写入深度
   */
  pickTranslucentDepth : boolean

  /**
   * 获取当前场景每帧渲染结束时的事件，监听该事件在每帧渲染结束时触发
   */
  postRender : Event

  /**
   * 获取当前场景每帧渲染前的事件，监听该事件在每帧渲染之前触发
   */
  preRender : Event

  /**
   * 获取所有图元集合
   */
  primitives : PrimitiveCollection

  /**
   * 获取实时栅格化对象
   */
  rasterVectorCollection : object

  /**
   * 获取场景的扫描线效果
   */
  scanEffect : ScanEffect

  /**
   * 获取当前场景的相机操作对象
   */
  screenSpaceCameraController : ScreenSpaceCameraController

  /**
   * 场景中的阴影贴图。启用时，模型、图元和地球可以投射和接收阴影。默认情况下，阴影贴图的光源是太阳
   */
  shadowMap : ShadowMap

  /**
   * The SkyBox used to draw the stars
   */
  skyBox : SkyBox

  /**
   * The url to the KTX file containing the specular environment map and convoluted mipmaps for image-based lighting of PBR models
   */
  specularEnvironmentMaps : string

  /**
   * The spherical harmonic coefficients for image-based lighting of PBR models.
   */
  sphericalHarmonicCoefficients : array

  sun : Sun

  /**
   * 获取或者设置当前场景的地形服务provider对象
   */
  terrainProvider : TerrainProvider

  /**
   * 获取当前场景地形服务provider改变事件
   */
  terrainProviderChanged : Event

  /**
   * 当前场景是否开启toneMapping
   */
  toneMappingEnabled: boolean

  /**
   * 获取地下球
   */
  underGlobe : UnderGlobe

  /**
   * 获取或者设置地下场景深度，默认1000米（单位：米）
   */
  undergroundDepth : number

  /**
   * 获取或者设置是否开启地下场景
   */
  undergroundMode : Boolean

  /**
   * 获取或者设置相机模式
   */
  walkingMode : number

  /**
   * 根据url路径添加场数据图层
   * @param url 场数据的url路径
   * @example 
   * var promise =  viewer.scene.addFieldLayer("../data.nc");
       Cesium.when(promise,function(fieldLayer){
       fieldLayer.particleVelocityFieldEffect.velocityScale = 100.0;
       fieldLayer.particleVelocityFieldEffect.particleSize = 2;
       fieldLayer.particleVelocityFieldEffect.paricleCountPerDegree = 1.5;
       scene.primitives.add(fieldLayer);
       fieldLayer.particleVelocityFieldEffect.colorTable = colorTable;
       var options = {
        longitude:'lon',
        latitude:'lat',
        uwnd:'uwnd',
        vwnd:'uwnd'
     }
      fieldLayer.NetCDFData = options;
	})
   * @returns 返回场数据图层FieldLayer3D，异步创建场图层对象
   */
  addFieldLayer(url: string) : Promise

  /**
   * 添加场景图层服务
   * @param url  	图层服务的url路径
   * @param sceneName  场景名称
   * @param layerName 图层名称
   */
  addLayerService(url: string, sceneName: string, layerName: string): void

  /**
   * 添加光源
   * @param lightSource 
   * @returns 添加点光源后后的场景
   */
  addLightSource(lightSource: LightSource	) : Scene

  /**
   * 添加S3M分组图层
   * @param url iserver中发布的配置文件地址
   * @param options 图层所需属性对象
   * @param index 索引
   */
  addS3MGroupLayer(url: string, options: object, index: number) : Promise

  /**
   * 添加三维切片缓存图层（S3M、S3MB）
   * @param url iserver中发布的配置文件地址
   * @param options 
   * @param index 索引
   * @example 
   * var promise = scene.addS3MTilesLayerByScp('http://localhost:8090/iserver/services/3D-zj/rest/realspace/datas/zj/config', {name : 'base'});
   *   promise.then(function(layer){
   *  layer.visible = false;
   * });
   * //子域用法
   * var config = {
   *      subdomainConfig: {
   *         urlScheme: "http://{s}.supermap.com:8090/iserver/services/3D-BIM/rest/realspace",
   *         subdomains: ['t1', 't2']
   *     },
   *     name: "BIM"
   * };
   * var promise = scene.addS3MTilesLayerByScp('http://localhost:8090/iserver/services/3D-BIM/rest/realspace/datas/BIM/config', config);
   */
  addS3MTilesLayerByScp(url: string, options: {
    subdomains: Array,
    autoSetView: boolean,
    name: string,
    cullEnabled: boolean
  }, index: number) : Promise

  /**
   * 添加矢量瓦片图层服务。为了保证版本的稳定性，采用该接口创建的MVT图层依然保持原来的使用和实现方式，但不支持VectorTileMap中新增的接口,推荐使用新的实现方式addVectorTilesMap
   * @param options.url 适用于通过SuperMap桌面软件生成mvt数据,经iServer发布为rest风格的地图服务，只需提供服务地址
   * @param options.url 服务地址,适用于第三方发布的WMTS服务
   * @param options.layer 图层名称,适用于第三方发布的WMTS服务
   * @param options.canvasWidth 用来绘制矢量的纹理边长。默认是512，越大越精细，越小性能越高
   * @param options.tileWidth 瓦片宽度,适用于第三方发布的WMTS服务
   * @param options.tileHeight 	瓦片高度,适用于第三方发布的WMTS服务
   * @param options.format 适用于第三方发布的WMTS服务
   * @param options.tilematrxset 切片矩阵集名称,适用于第三方发布的WMTS服务
   * @param options.maximumLevel 数据的最大层级。适用于第三方发布的WMTS服务，默认根据服务参数计算
   * @param options.minimumLevel 数据的最小层级。适用于第三方发布的WMTS服务，默认根据服务参数计算
   * @param options.mapboxStyle  使用的mapBox风格
   * @param options.maximumTerrainLevel  允许加载MVT图层的最大地形层号（如果未定义则所有层都加载）
   * @param options.minimumTerrainLevel 允许加载MVT图层的最小地形层号（如果未定义则所有层都加载）
   * @param options.simplifyTolerance 进行几何简化的坐标容限，单位为切片坐标系，值域为0-4096。值越大简化得越厉害，默认是0，不简化
   * @param options.viewer 设置将要添加到的地球
   * @example 
   * var layer = scene.addVectorTilesLayer({
   * url:"http://localhost:8090/iserver/services/map-mvt-test/....../maps/test"//地图服务
   * });
   */
  addVectorTilesLayer(options: {
    url: string,
    url: string,
    layer:string ,
    canvasWidth: number,
    tileWidth: string,
    tileHeight: string,
    format: string,
    tilematrxset: string,
    maximumLevel: number,
    minimumLevel: number,
    mapboxStyle: Object,
    maximumTerrainLevel: number,
    minimumTerrainLevel: number,
    simplifyTolerance: number,
    viewer: Object
  }): void

  /**
   * 新建一个矢量瓦片地图
   * @param options.url 	适用于通过SuperMap桌面软件生成mvt数据,经iServer发布为rest风格的地图服务，只需提供服务地址
   * @param options.layer 图层名称,适用于第三方发布的WMTS服务
   * @param options.canvasWidth 用来绘制矢量的纹理边长。默认是512，越大越精细，越小性能越高
   * @param options.tileWidth 瓦片宽度,适用于第三方发布的WMTS服务
   * @param options.tileHeight 瓦片高度,适用于第三方发布的WMTS服务
   * @param options.tilematrxset 适用于第三方发布的WMTS服务
   * @param options.maximumLevel 切片矩阵集名称,适用于第三方发布的WMTS服务
   * @param options.minimumLevel 数据的最大层级。适用于第三方发布的WMTS服务，默认根据服务参数计算
   * @param options.mapboxStyle 数据的最小层级。适用于第三方发布的WMTS服务，默认根据服务参数计算
   * @param options.maximumTerrainLevel 允许加载MVT图层的最大地形层号（如果未定义则所有层都加载）
   * @param options.labelScaleByDistance 设置文字随距离缩放
   * @param options.customRequestHeaders 设置自定义请求头
   * @param options.realtime 设置是否实时栅格化
   * @param options.swipeEnabled 设置是否卷帘
   * @param options.swipeRegion 设置卷帘区域
   * @param options.billboardMode 设置文字标签样式
   * @param options.labelDepthTestEnabled 用于控制MVT文字/图标是否做深度检测。默认为true,开启深度检测，反之则关闭深度检测
   * @param options.viewer 设置将要添加到的地球
   */
  addVectorTilesMap(options: {
    url: string,
    layer: string,
    canvasWidth: number,
    tileWidth: string,
    tileHeight: string,
    format: string,
    tilematrxset: string,
    maximumLevel: number,
    minimumLevel: number,
    mapboxStyle: object,
    maximumTerrainLevel: number,
    minimumTerrainLevel: number,
    labelScaleByDistance: number,
    customRequestHeaders: object,
    realtime: boolean,
    swipeEnabled: boolean,
    swipeRegion: object,
    billboardMode: 	BillboardMode,
    labelDepthTestEnabled: boolean,
    viewer: object
  }): void

  /**
   * 转换三维空间坐标到canvas坐标（窗口坐标）。
   * @param options 三维空间坐标
   * @param result 窗口坐标，用于保存结果
   * @example 
   * //随着鼠标移动输出经纬度为(0,0)的窗口坐标。
   * var scene = widget.scene;
   * var ellipsoid = scene.globe.ellipsoid;
   * var position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
   * var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
   * handler.setInputAction(function(movement) {
   *     console.log(scene.cartesianToCanvasCoordinates(position));
   * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
   */
   cartesianToCanvasCoordinates(position:Cartesian3	, result: Cartesian2) : Cartesian2

   /**
    * 当前场景是否支持纹理压缩格式
    * @param format 纹理格式。格式名称或WebGL扩展名。例如：s3tc 或 WEBGL_compressed_texture_s3tc
    * @returns 该格式是否被支持
    */
   getCompressedTextureFormatSupported(format) : boolean

   /**
    * 根据经纬度坐标获取对应高度
    */
    getHeight(lon: number, lat: number) : number

    /**
     * 获取选中ID。返回的是对象数组，每个对象包含图层ID(layerID)和选中对象ID(ids)
     */
    getPickRectIDs() : array

    /**
     * 根据指定名称获取矢量瓦片地图
     * @param name 矢量瓦片地图的名称
     */
    getVectorTilesMap(name: string) : Layer

    /**
     * 根据窗口坐标，获取当前场景视口
     * @param windowPosition 
     */
    getViewport(windowPosition: Cartesian2) : BoundingRectangle

    /**
     * 打开iserver场景服务下所有图层
     * @param url 服务url
     * @param sceneName 工作空间中有多个场景，需要指定场景名称；设置为undefined，默认打开第一个
     * @param options.subdomains 	用于子域，例如：['t1','t2']
     * @param options.autoSetView 是否自动定位到场景
     * @example 
     * var promise = scene.open('http://localhost:8090/iserver/services/3D-BIM3/rest/realspace');
     * promise.then(function(layers){});
     *      //子域和不自动定位用法
     *    var promise = scene.open('http://{s}.supermap.com:8090/iserver/services/3D-BIM3/rest/realspace',undefined,{
     *       subdomains: ['t1', 't2']，//子域
     *      autoSetView : false      //不自动定位
     *   });
     *  promise.then(function(layers){});
     */
     open(url: string, sceneName: string, options: {
      subdomains: array,
      autoSetView: boolean
     }) : Promise

     /**
      * 将当前场景输出Base64编码
      * @example 
      * var promise =  scene.outputSceneToFile();
      *  Cesium.when(promise,function(base64data){
      *    $("#ID").css("background","url(" + base64data +")");
      *  })
      */
     outputSceneToFile() :Promise

     /**
      * 解析PBR材质参数
      * @example 
      * scene.parsePBRFromJson(urls);
      *  var conditions=[
      *  ['${id}<=80',0],
      *  ['${id}<=90',1],
      *  ['${id}<=100',2],
      *  ];
      */
     parsePBRFromJson() : void
     
     /**
      * 场景拾取，返回在场景中该窗口位置对应的第一个图元对象，如果该位置没有任何物体则返回undefined
      * @param windowPosition 窗口坐标
      * @param width 拾取矩形宽度
      * @param height 拾取矩形高度
      */
     pick(windowPosition: Cartesian2, width: number, height: number) : object

     /**
      * 用于拾取法线，传入屏幕坐标，返回法线。结合选中偏移可以实现沿法线方向偏移的效果
      */
      pickNormal(windowPosition: Cartesian2) : Cartesian3

      /**
       * 位置拾取，根据窗口坐标，从场景的深度缓冲区中拾取相应的位置，返回笛卡尔坐标,需要支持深度纹理
       * @param windowPosition 窗口坐标
       * @param result 笛卡尔坐标,保存返回结果
       */
      pickPosition(windowPosition: Cartesian2, result: Cartesian3) : Cartesian3
      
      /**
       * 框选
       * @param startPoint 框选起始点
       * @param endPoint 框选终止点
       */
      pickRect(startPoint: object, endPoint: object) : number

      /**
       * 删除光源
       * @param lightSource 光源
       */
      removeLightSource(lightSource: LightSource) : Scene

      /**
       * 按指定名称移除矢量瓦片地图
       * @param name 指定拟移除的矢量瓦片地图的名称
       */
      removeVectorTilesMap(name) : boolean

      /**
       * 设置MVT的显示层级控制
       * @param control 是否对MVT的显示层级进行控制 
       * @param level 从当前视角由近及远，总共显示的层级数。例如设置为3，则只显示距离相机最近的前三层，第4层及以后的不会显示 
       */
       setVectorTilesLayersControl(control, level): void

      /**
      * @param name 
      */
      find(name: string) : Layer
}

/**
     * A 2D Cartesian point.
     * @param [x = 0.0] - The X component.
     * @param [y = 0.0] - The Y component.
     */
export class Cartesian2 {
  constructor(x?: number, y?: number);
  /**
   * The X component.
   */
  x: number;
  /**
   * The Y component.
   */
  y: number;
  /**
   * Creates a Cartesian2 instance from x and y coordinates.
   * @param x - The x coordinate.
   * @param y - The y coordinate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.
   */
  fromElements(x: number, y: number, result?: Cartesian2): Cartesian2;
  /**
   * Duplicates a Cartesian2 instance.
   * @param cartesian - The Cartesian to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)
   */
  clone(cartesian: Cartesian2, result?: Cartesian2): Cartesian2;
  /**
   * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the
   * x and y properties of the Cartesian3 and drops z.
   * @param cartesian - The Cartesian3 instance to create a Cartesian2 instance from.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.
   */
  fromCartesian3(cartesian: Cartesian3, result?: Cartesian2): Cartesian2;
  /**
   * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the
   * x and y properties of the Cartesian4 and drops z and w.
   * @param cartesian - The Cartesian4 instance to create a Cartesian2 instance from.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.
   */
  fromCartesian4(cartesian: Cartesian4, result?: Cartesian2): Cartesian2;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: Cartesian2, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: Cartesian2): Cartesian2;
  /**
   * Flattens an array of Cartesian2s into an array of components.
   * @param array - The array of cartesians to pack.
   * @param [result] - The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.
   * @returns The packed array.
   */
  packArray(array: Cartesian2[], result?: number[]): number[];
  /**
   * Unpacks an array of cartesian components into an array of Cartesian2s.
   * @param array - The array of components to unpack.
   * @param [result] - The array onto which to store the result.
   * @returns The unpacked array.
   */
  unpackArray(array: number[], result?: Cartesian2[]): Cartesian2[];
  /**
   * Creates a Cartesian2 from two consecutive elements in an array.
   * @example
   * // Create a Cartesian2 with (1.0, 2.0)
   * const v = [1.0, 2.0];
   * const p = Cesium.Cartesian2.fromArray(v);
   *
   * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array
   * const v2 = [0.0, 0.0, 1.0, 2.0];
   * const p2 = Cesium.Cartesian2.fromArray(v2, 2);
   * @param array - The array whose two consecutive elements correspond to the x and y components, respectively.
   * @param [startingIndex = 0] - The offset into the array of the first element, which corresponds to the x component.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.
   */
  fromArray(array: number[], startingIndex?: number, result?: Cartesian2): Cartesian2;
  /**
   * Computes the value of the maximum component for the supplied Cartesian.
   * @param cartesian - The cartesian to use.
   * @returns The value of the maximum component.
   */
  maximumComponent(cartesian: Cartesian2): number;
  /**
   * Computes the value of the minimum component for the supplied Cartesian.
   * @param cartesian - The cartesian to use.
   * @returns The value of the minimum component.
   */
  minimumComponent(cartesian: Cartesian2): number;
  /**
   * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
   * @param first - A cartesian to compare.
   * @param second - A cartesian to compare.
   * @param result - The object into which to store the result.
   * @returns A cartesian with the minimum components.
   */
  minimumByComponent(first: Cartesian2, second: Cartesian2, result: Cartesian2): Cartesian2;
  /**
   * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
   * @param first - A cartesian to compare.
   * @param second - A cartesian to compare.
   * @param result - The object into which to store the result.
   * @returns A cartesian with the maximum components.
   */
  maximumByComponent(first: Cartesian2, second: Cartesian2, result: Cartesian2): Cartesian2;
  /**
   * Constrain a value to lie between two values.
   * @param value - The value to clamp.
   * @param min - The minimum bound.
   * @param max - The maximum bound.
   * @param result - The object into which to store the result.
   * @returns The clamped value such that min <= result <= max.
   */
  clamp(value: Cartesian2, min: Cartesian2, max: Cartesian2, result: Cartesian2): Cartesian2;
  /**
   * Computes the provided Cartesian's squared magnitude.
   * @param cartesian - The Cartesian instance whose squared magnitude is to be computed.
   * @returns The squared magnitude.
   */
  magnitudeSquared(cartesian: Cartesian2): number;
  /**
   * Computes the Cartesian's magnitude (length).
   * @param cartesian - The Cartesian instance whose magnitude is to be computed.
   * @returns The magnitude.
   */
  magnitude(cartesian: Cartesian2): number;
  /**
   * Computes the distance between two points.
   * @example
   * // Returns 1.0
   * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));
   * @param left - The first point to compute the distance from.
   * @param right - The second point to compute the distance to.
   * @returns The distance between two points.
   */
  distance(left: Cartesian2, right: Cartesian2): number;
  /**
   * Computes the squared distance between two points.  Comparing squared distances
   * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.
   * @example
   * // Returns 4.0, not 2.0
   * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));
   * @param left - The first point to compute the distance from.
   * @param right - The second point to compute the distance to.
   * @returns The distance between two points.
   */
  distanceSquared(left: Cartesian2, right: Cartesian2): number;
  /**
   * Computes the normalized form of the supplied Cartesian.
   * @param cartesian - The Cartesian to be normalized.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  normalize(cartesian: Cartesian2, result: Cartesian2): Cartesian2;
  /**
   * Computes the dot (scalar) product of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @returns The dot product.
   */
  dot(left: Cartesian2, right: Cartesian2): number;
  /**
   * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @returns The cross product.
   */
  cross(left: Cartesian2, right: Cartesian2): number;
  /**
   * Computes the componentwise product of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyComponents(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;
  /**
   * Computes the componentwise quotient of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  divideComponents(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;
  /**
   * Computes the componentwise sum of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  add(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;
  /**
   * Computes the componentwise difference of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  subtract(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;
  /**
   * Multiplies the provided Cartesian componentwise by the provided scalar.
   * @param cartesian - The Cartesian to be scaled.
   * @param scalar - The scalar to multiply with.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByScalar(cartesian: Cartesian2, scalar: number, result: Cartesian2): Cartesian2;
  /**
   * Divides the provided Cartesian componentwise by the provided scalar.
   * @param cartesian - The Cartesian to be divided.
   * @param scalar - The scalar to divide by.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  divideByScalar(cartesian: Cartesian2, scalar: number, result: Cartesian2): Cartesian2;
  /**
   * Negates the provided Cartesian.
   * @param cartesian - The Cartesian to be negated.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  negate(cartesian: Cartesian2, result: Cartesian2): Cartesian2;
  /**
   * Computes the absolute value of the provided Cartesian.
   * @param cartesian - The Cartesian whose absolute value is to be computed.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  abs(cartesian: Cartesian2, result: Cartesian2): Cartesian2;
  /**
   * Computes the linear interpolation or extrapolation at t using the provided cartesians.
   * @param start - The value corresponding to t at 0.0.
   * @param end - The value corresponding to t at 1.0.
   * @param t - The point along t at which to interpolate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  lerp(start: Cartesian2, end: Cartesian2, t: number, result: Cartesian2): Cartesian2;
  /**
   * Returns the angle, in radians, between the provided Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @returns The angle between the Cartesians.
   */
  angleBetween(left: Cartesian2, right: Cartesian2): number;
  /**
   * Returns the axis that is most orthogonal to the provided Cartesian.
   * @param cartesian - The Cartesian on which to find the most orthogonal axis.
   * @param result - The object onto which to store the result.
   * @returns The most orthogonal axis.
   */
  mostOrthogonalAxis(cartesian: Cartesian2, result: Cartesian2): Cartesian2;
  /**
   * Compares the provided Cartesians componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [left] - The first Cartesian.
   * @param [right] - The second Cartesian.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left?: Cartesian2, right?: Cartesian2): boolean;
  /**
   * Compares the provided Cartesians componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param [left] - The first Cartesian.
   * @param [right] - The second Cartesian.
   * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
   * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(left?: Cartesian2, right?: Cartesian2, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
  /**
   * An immutable Cartesian2 instance initialized to (0.0, 0.0).
   */
  readonly ZERO: Cartesian2;
  /**
   * An immutable Cartesian2 instance initialized to (1.0, 1.0).
   */
  readonly ONE: Cartesian2;
  /**
   * An immutable Cartesian2 instance initialized to (1.0, 0.0).
   */
  readonly UNIT_X: Cartesian2;
  /**
   * An immutable Cartesian2 instance initialized to (0.0, 1.0).
   */
  readonly UNIT_Y: Cartesian2;
  /**
   * Duplicates this Cartesian2 instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.
   */
  clone(result?: Cartesian2): Cartesian2;
  /**
   * Compares this Cartesian against the provided Cartesian componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The right hand side Cartesian.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(right?: Cartesian2): boolean;
  /**
   * Compares this Cartesian against the provided Cartesian componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param [right] - The right hand side Cartesian.
   * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
   * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(right?: Cartesian2, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
  /**
   * Creates a string representing this Cartesian in the format '(x, y)'.
   * @returns A string representing the provided Cartesian in the format '(x, y)'.
   */
  toString(): string;
}

/**
* A 3D Cartesian point.
* @param [x = 0.0] - The X component.
* @param [y = 0.0] - The Y component.
* @param [z = 0.0] - The Z component.
*/
export class Cartesian3 {
  constructor(x?: number, y?: number, z?: number);
  /**
   * The X component.
   */
  x: number;
  /**
   * The Y component.
   */
  y: number;
  /**
   * The Z component.
   */
  z: number;
  /**
   * Converts the provided Spherical into Cartesian3 coordinates.
   * @param spherical - The Spherical to be converted to Cartesian3.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
   */
  fromSpherical(spherical: Spherical, result?: Cartesian3): Cartesian3;
  /**
   * Creates a Cartesian3 instance from x, y and z coordinates.
   * @param x - The x coordinate.
   * @param y - The y coordinate.
   * @param z - The z coordinate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
   */
  fromElements(x: number, y: number, z: number, result?: Cartesian3): Cartesian3;
  /**
   * Duplicates a Cartesian3 instance.
   * @param cartesian - The Cartesian to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)
   */
  clone(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
  /**
   * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the
   * x, y, and z properties of the Cartesian4 and drops w.
   * @param cartesian - The Cartesian4 instance to create a Cartesian3 instance from.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
   */
  fromCartesian4(cartesian: Cartesian4, result?: Cartesian3): Cartesian3;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: Cartesian3, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: Cartesian3): Cartesian3;
  /**
   * Flattens an array of Cartesian3s into an array of components.
   * @param array - The array of cartesians to pack.
   * @param [result] - The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.
   * @returns The packed array.
   */
  packArray(array: Cartesian3[], result?: number[]): number[];
  /**
   * Unpacks an array of cartesian components into an array of Cartesian3s.
   * @param array - The array of components to unpack.
   * @param [result] - The array onto which to store the result.
   * @returns The unpacked array.
   */
  unpackArray(array: number[], result?: Cartesian3[]): Cartesian3[];
  /**
   * Creates a Cartesian3 from three consecutive elements in an array.
   * @example
   * // Create a Cartesian3 with (1.0, 2.0, 3.0)
   * const v = [1.0, 2.0, 3.0];
   * const p = Cesium.Cartesian3.fromArray(v);
   *
   * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array
   * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];
   * const p2 = Cesium.Cartesian3.fromArray(v2, 2);
   * @param array - The array whose three consecutive elements correspond to the x, y, and z components, respectively.
   * @param [startingIndex = 0] - The offset into the array of the first element, which corresponds to the x component.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
   */
  fromArray(array: number[], startingIndex?: number, result?: Cartesian3): Cartesian3;
  /**
   * Computes the value of the maximum component for the supplied Cartesian.
   * @param cartesian - The cartesian to use.
   * @returns The value of the maximum component.
   */
  maximumComponent(cartesian: Cartesian3): number;
  /**
   * Computes the value of the minimum component for the supplied Cartesian.
   * @param cartesian - The cartesian to use.
   * @returns The value of the minimum component.
   */
  minimumComponent(cartesian: Cartesian3): number;
  /**
   * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
   * @param first - A cartesian to compare.
   * @param second - A cartesian to compare.
   * @param result - The object into which to store the result.
   * @returns A cartesian with the minimum components.
   */
  minimumByComponent(first: Cartesian3, second: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
   * @param first - A cartesian to compare.
   * @param second - A cartesian to compare.
   * @param result - The object into which to store the result.
   * @returns A cartesian with the maximum components.
   */
  maximumByComponent(first: Cartesian3, second: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Constrain a value to lie between two values.
   * @param cartesian - The value to clamp.
   * @param min - The minimum bound.
   * @param max - The maximum bound.
   * @param result - The object into which to store the result.
   * @returns The clamped value such that min <= value <= max.
   */
  clamp(cartesian: Cartesian3, min: Cartesian3, max: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Computes the provided Cartesian's squared magnitude.
   * @param cartesian - The Cartesian instance whose squared magnitude is to be computed.
   * @returns The squared magnitude.
   */
  magnitudeSquared(cartesian: Cartesian3): number;
  /**
   * Computes the Cartesian's magnitude (length).
   * @param cartesian - The Cartesian instance whose magnitude is to be computed.
   * @returns The magnitude.
   */
  magnitude(cartesian: Cartesian3): number;
  /**
   * Computes the distance between two points.
   * @example
   * // Returns 1.0
   * const d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));
   * @param left - The first point to compute the distance from.
   * @param right - The second point to compute the distance to.
   * @returns The distance between two points.
   */
  distance(left: Cartesian3, right: Cartesian3): number;
  /**
   * Computes the squared distance between two points.  Comparing squared distances
   * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.
   * @example
   * // Returns 4.0, not 2.0
   * const d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));
   * @param left - The first point to compute the distance from.
   * @param right - The second point to compute the distance to.
   * @returns The distance between two points.
   */
  distanceSquared(left: Cartesian3, right: Cartesian3): number;
  /**
   * Computes the normalized form of the supplied Cartesian.
   * @param cartesian - The Cartesian to be normalized.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  normalize(cartesian: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Computes the dot (scalar) product of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @returns The dot product.
   */
  dot(left: Cartesian3, right: Cartesian3): number;
  /**
   * Computes the componentwise product of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyComponents(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Computes the componentwise quotient of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  divideComponents(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Computes the componentwise sum of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  add(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Computes the componentwise difference of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  subtract(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Multiplies the provided Cartesian componentwise by the provided scalar.
   * @param cartesian - The Cartesian to be scaled.
   * @param scalar - The scalar to multiply with.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByScalar(cartesian: Cartesian3, scalar: number, result: Cartesian3): Cartesian3;
  /**
   * Divides the provided Cartesian componentwise by the provided scalar.
   * @param cartesian - The Cartesian to be divided.
   * @param scalar - The scalar to divide by.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  divideByScalar(cartesian: Cartesian3, scalar: number, result: Cartesian3): Cartesian3;
  /**
   * Negates the provided Cartesian.
   * @param cartesian - The Cartesian to be negated.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  negate(cartesian: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Computes the absolute value of the provided Cartesian.
   * @param cartesian - The Cartesian whose absolute value is to be computed.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  abs(cartesian: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Computes the linear interpolation or extrapolation at t using the provided cartesians.
   * @param start - The value corresponding to t at 0.0.
   * @param end - The value corresponding to t at 1.0.
   * @param t - The point along t at which to interpolate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  lerp(start: Cartesian3, end: Cartesian3, t: number, result: Cartesian3): Cartesian3;
  /**
   * Returns the angle, in radians, between the provided Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @returns The angle between the Cartesians.
   */
  angleBetween(left: Cartesian3, right: Cartesian3): number;
  /**
   * Returns the axis that is most orthogonal to the provided Cartesian.
   * @param cartesian - The Cartesian on which to find the most orthogonal axis.
   * @param result - The object onto which to store the result.
   * @returns The most orthogonal axis.
   */
  mostOrthogonalAxis(cartesian: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Projects vector a onto vector b
   * @param a - The vector that needs projecting
   * @param b - The vector to project onto
   * @param result - The result cartesian
   * @returns The modified result parameter
   */
  projectVector(a: Cartesian3, b: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Compares the provided Cartesians componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [left] - The first Cartesian.
   * @param [right] - The second Cartesian.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left?: Cartesian3, right?: Cartesian3): boolean;
  /**
   * Compares the provided Cartesians componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param [left] - The first Cartesian.
   * @param [right] - The second Cartesian.
   * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
   * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(left?: Cartesian3, right?: Cartesian3, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
  /**
   * Computes the cross (outer) product of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The cross product.
   */
  cross(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Computes the midpoint between the right and left Cartesian.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The midpoint.
   */
  midpoint(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Returns a Cartesian3 position from longitude and latitude values given in degrees.
   * @example
   * const position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);
   * @param longitude - The longitude, in degrees
   * @param latitude - The latitude, in degrees
   * @param [height = 0.0] - The height, in meters, above the ellipsoid.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the position lies.
   * @param [result] - The object onto which to store the result.
   * @returns The position
   */
  fromDegrees(longitude: number, latitude: number, height?: number, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;
  /**
   * Returns a Cartesian3 position from longitude and latitude values given in radians.
   * @example
   * const position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);
   * @param longitude - The longitude, in radians
   * @param latitude - The latitude, in radians
   * @param [height = 0.0] - The height, in meters, above the ellipsoid.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the position lies.
   * @param [result] - The object onto which to store the result.
   * @returns The position
   */
  fromRadians(longitude: number, latitude: number, height?: number, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;
  /**
   * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.
   * @example
   * const positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);
   * @param coordinates - A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the coordinates lie.
   * @param [result] - An array of Cartesian3 objects to store the result.
   * @returns The array of positions.
   */
  fromDegreesArray(coordinates: number[], ellipsoid?: Ellipsoid, result?: Cartesian3[]): Cartesian3[];
  /**
   * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.
   * @example
   * const positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);
   * @param coordinates - A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the coordinates lie.
   * @param [result] - An array of Cartesian3 objects to store the result.
   * @returns The array of positions.
   */
  fromRadiansArray(coordinates: number[], ellipsoid?: Ellipsoid, result?: Cartesian3[]): Cartesian3[];
  /**
   * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.
   * @example
   * const positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);
   * @param coordinates - A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the position lies.
   * @param [result] - An array of Cartesian3 objects to store the result.
   * @returns The array of positions.
   */
  fromDegreesArrayHeights(coordinates: number[], ellipsoid?: Ellipsoid, result?: Cartesian3[]): Cartesian3[];
  /**
   * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.
   * @example
   * const positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);
   * @param coordinates - A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the position lies.
   * @param [result] - An array of Cartesian3 objects to store the result.
   * @returns The array of positions.
   */
  fromRadiansArrayHeights(coordinates: number[], ellipsoid?: Ellipsoid, result?: Cartesian3[]): Cartesian3[];
  /**
   * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).
   */
  readonly ZERO: Cartesian3;
  /**
   * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).
   */
  readonly ONE: Cartesian3;
  /**
   * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).
   */
  readonly UNIT_X: Cartesian3;
  /**
   * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).
   */
  readonly UNIT_Y: Cartesian3;
  /**
   * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).
   */
  readonly UNIT_Z: Cartesian3;
  /**
   * Duplicates this Cartesian3 instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
   */
  clone(result?: Cartesian3): Cartesian3;
  /**
   * Compares this Cartesian against the provided Cartesian componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The right hand side Cartesian.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(right?: Cartesian3): boolean;
  /**
   * Compares this Cartesian against the provided Cartesian componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param [right] - The right hand side Cartesian.
   * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
   * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(right?: Cartesian3, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
  /**
   * Creates a string representing this Cartesian in the format '(x, y, z)'.
   * @returns A string representing this Cartesian in the format '(x, y, z)'.
   */
  toString(): string;
}

/**
* A 4D Cartesian point.
* @param [x = 0.0] - The X component.
* @param [y = 0.0] - The Y component.
* @param [z = 0.0] - The Z component.
* @param [w = 0.0] - The W component.
*/
export class Cartesian4 {
  constructor(x?: number, y?: number, z?: number, w?: number);
  /**
   * The X component.
   */
  x: number;
  /**
   * The Y component.
   */
  y: number;
  /**
   * The Z component.
   */
  z: number;
  /**
   * The W component.
   */
  w: number;
  /**
   * Creates a Cartesian4 instance from x, y, z and w coordinates.
   * @param x - The x coordinate.
   * @param y - The y coordinate.
   * @param z - The z coordinate.
   * @param w - The w coordinate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian4 instance if one was not provided.
   */
  fromElements(x: number, y: number, z: number, w: number, result?: Cartesian4): Cartesian4;
  /**
   * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,
   * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.
   * @param color - The source color.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian4 instance if one was not provided.
   */
  fromColor(color: Color, result?: Cartesian4): Cartesian4;
  /**
   * Duplicates a Cartesian4 instance.
   * @param cartesian - The Cartesian to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)
   */
  clone(cartesian: Cartesian4, result?: Cartesian4): Cartesian4;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: Cartesian4, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Cartesian4 instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: Cartesian4): Cartesian4;
  /**
   * Flattens an array of Cartesian4s into an array of components.
   * @param array - The array of cartesians to pack.
   * @param [result] - The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.
   * @returns The packed array.
   */
  packArray(array: Cartesian4[], result?: number[]): number[];
  /**
   * Unpacks an array of cartesian components into an array of Cartesian4s.
   * @param array - The array of components to unpack.
   * @param [result] - The array onto which to store the result.
   * @returns The unpacked array.
   */
  unpackArray(array: number[], result?: Cartesian4[]): Cartesian4[];
  /**
   * Creates a Cartesian4 from four consecutive elements in an array.
   * @example
   * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)
   * const v = [1.0, 2.0, 3.0, 4.0];
   * const p = Cesium.Cartesian4.fromArray(v);
   *
   * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array
   * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];
   * const p2 = Cesium.Cartesian4.fromArray(v2, 2);
   * @param array - The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.
   * @param [startingIndex = 0] - The offset into the array of the first element, which corresponds to the x component.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian4 instance if one was not provided.
   */
  fromArray(array: number[], startingIndex?: number, result?: Cartesian4): Cartesian4;
  /**
   * Computes the value of the maximum component for the supplied Cartesian.
   * @param cartesian - The cartesian to use.
   * @returns The value of the maximum component.
   */
  maximumComponent(cartesian: Cartesian4): number;
  /**
   * Computes the value of the minimum component for the supplied Cartesian.
   * @param cartesian - The cartesian to use.
   * @returns The value of the minimum component.
   */
  minimumComponent(cartesian: Cartesian4): number;
  /**
   * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
   * @param first - A cartesian to compare.
   * @param second - A cartesian to compare.
   * @param result - The object into which to store the result.
   * @returns A cartesian with the minimum components.
   */
  minimumByComponent(first: Cartesian4, second: Cartesian4, result: Cartesian4): Cartesian4;
  /**
   * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
   * @param first - A cartesian to compare.
   * @param second - A cartesian to compare.
   * @param result - The object into which to store the result.
   * @returns A cartesian with the maximum components.
   */
  maximumByComponent(first: Cartesian4, second: Cartesian4, result: Cartesian4): Cartesian4;
  /**
   * Constrain a value to lie between two values.
   * @param value - The value to clamp.
   * @param min - The minimum bound.
   * @param max - The maximum bound.
   * @param result - The object into which to store the result.
   * @returns The clamped value such that min <= result <= max.
   */
  clamp(value: Cartesian4, min: Cartesian4, max: Cartesian4, result: Cartesian4): Cartesian4;
  /**
   * Computes the provided Cartesian's squared magnitude.
   * @param cartesian - The Cartesian instance whose squared magnitude is to be computed.
   * @returns The squared magnitude.
   */
  magnitudeSquared(cartesian: Cartesian4): number;
  /**
   * Computes the Cartesian's magnitude (length).
   * @param cartesian - The Cartesian instance whose magnitude is to be computed.
   * @returns The magnitude.
   */
  magnitude(cartesian: Cartesian4): number;
  /**
   * Computes the 4-space distance between two points.
   * @example
   * // Returns 1.0
   * const d = Cesium.Cartesian4.distance(
   *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
   *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));
   * @param left - The first point to compute the distance from.
   * @param right - The second point to compute the distance to.
   * @returns The distance between two points.
   */
  distance(left: Cartesian4, right: Cartesian4): number;
  /**
   * Computes the squared distance between two points.  Comparing squared distances
   * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.
   * @example
   * // Returns 4.0, not 2.0
   * const d = Cesium.Cartesian4.distance(
   *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
   *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));
   * @param left - The first point to compute the distance from.
   * @param right - The second point to compute the distance to.
   * @returns The distance between two points.
   */
  distanceSquared(left: Cartesian4, right: Cartesian4): number;
  /**
   * Computes the normalized form of the supplied Cartesian.
   * @param cartesian - The Cartesian to be normalized.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  normalize(cartesian: Cartesian4, result: Cartesian4): Cartesian4;
  /**
   * Computes the dot (scalar) product of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @returns The dot product.
   */
  dot(left: Cartesian4, right: Cartesian4): number;
  /**
   * Computes the componentwise product of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyComponents(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;
  /**
   * Computes the componentwise quotient of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  divideComponents(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;
  /**
   * Computes the componentwise sum of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  add(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;
  /**
   * Computes the componentwise difference of two Cartesians.
   * @param left - The first Cartesian.
   * @param right - The second Cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  subtract(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;
  /**
   * Multiplies the provided Cartesian componentwise by the provided scalar.
   * @param cartesian - The Cartesian to be scaled.
   * @param scalar - The scalar to multiply with.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByScalar(cartesian: Cartesian4, scalar: number, result: Cartesian4): Cartesian4;
  /**
   * Divides the provided Cartesian componentwise by the provided scalar.
   * @param cartesian - The Cartesian to be divided.
   * @param scalar - The scalar to divide by.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  divideByScalar(cartesian: Cartesian4, scalar: number, result: Cartesian4): Cartesian4;
  /**
   * Negates the provided Cartesian.
   * @param cartesian - The Cartesian to be negated.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  negate(cartesian: Cartesian4, result: Cartesian4): Cartesian4;
  /**
   * Computes the absolute value of the provided Cartesian.
   * @param cartesian - The Cartesian whose absolute value is to be computed.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  abs(cartesian: Cartesian4, result: Cartesian4): Cartesian4;
  /**
   * Computes the linear interpolation or extrapolation at t using the provided cartesians.
   * @param start - The value corresponding to t at 0.0.
   * @param end - The value corresponding to t at 1.0.
   * @param t - The point along t at which to interpolate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  lerp(start: Cartesian4, end: Cartesian4, t: number, result: Cartesian4): Cartesian4;
  /**
   * Returns the axis that is most orthogonal to the provided Cartesian.
   * @param cartesian - The Cartesian on which to find the most orthogonal axis.
   * @param result - The object onto which to store the result.
   * @returns The most orthogonal axis.
   */
  mostOrthogonalAxis(cartesian: Cartesian4, result: Cartesian4): Cartesian4;
  /**
   * Compares the provided Cartesians componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [left] - The first Cartesian.
   * @param [right] - The second Cartesian.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left?: Cartesian4, right?: Cartesian4): boolean;
  /**
   * Compares the provided Cartesians componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param [left] - The first Cartesian.
   * @param [right] - The second Cartesian.
   * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
   * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(left?: Cartesian4, right?: Cartesian4, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
  /**
   * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).
   */
  readonly ZERO: Cartesian4;
  /**
   * An immutable Cartesian4 instance initialized to (1.0, 1.0, 1.0, 1.0).
   */
  readonly ONE: Cartesian4;
  /**
   * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).
   */
  readonly UNIT_X: Cartesian4;
  /**
   * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).
   */
  readonly UNIT_Y: Cartesian4;
  /**
   * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).
   */
  readonly UNIT_Z: Cartesian4;
  /**
   * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).
   */
  readonly UNIT_W: Cartesian4;
  /**
   * Duplicates this Cartesian4 instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian4 instance if one was not provided.
   */
  clone(result?: Cartesian4): Cartesian4;
  /**
   * Compares this Cartesian against the provided Cartesian componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The right hand side Cartesian.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(right?: Cartesian4): boolean;
  /**
   * Compares this Cartesian against the provided Cartesian componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param [right] - The right hand side Cartesian.
   * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
   * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(right?: Cartesian4, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
  /**
   * Creates a string representing this Cartesian in the format '(x, y, z, w)'.
   * @returns A string representing the provided Cartesian in the format '(x, y, z, w)'.
   */
  toString(): string;
  /**
   * Packs an arbitrary floating point value to 4 values representable using uint8.
   * @param value - A floating point number.
   * @param [result] - The Cartesian4 that will contain the packed float.
   * @returns A Cartesian4 representing the float packed to values in x, y, z, and w.
   */
  packFloat(value: number, result?: Cartesian4): Cartesian4;
}

/**
     * A position defined by longitude, latitude, and height.
     * @param [longitude = 0.0] - The longitude, in radians.
     * @param [latitude = 0.0] - The latitude, in radians.
     * @param [height = 0.0] - The height, in meters, above the ellipsoid.
     */
export class Cartographic {
  constructor(longitude?: number, latitude?: number, height?: number);
  /**
   * The longitude, in radians.
   */
  longitude: number;
  /**
   * The latitude, in radians.
   */
  latitude: number;
  /**
   * The height, in meters, above the ellipsoid.
   */
  height: number;
  /**
   * Creates a new Cartographic instance from longitude and latitude
   * specified in radians.
   * @param longitude - The longitude, in radians.
   * @param latitude - The latitude, in radians.
   * @param [height = 0.0] - The height, in meters, above the ellipsoid.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartographic instance if one was not provided.
   */
  fromRadians(longitude: number, latitude: number, height?: number, result?: Cartographic): Cartographic;
  /**
   * Creates a new Cartographic instance from Flongitude and latitude
   * specified in degrees.  The values in the resulting object will
   * be in radians.
   * @param longitude - The longitude, in degrees.
   * @param latitude - The latitude, in degrees.
   * @param [height = 0.0] - The height, in meters, above the ellipsoid.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartographic instance if one was not provided.
   */
  fromDegrees(longitude: number, latitude: number, height?: number, result?: Cartographic): Cartographic;
  /**
   * Creates a new Cartographic instance from a Cartesian position. The values in the
   * resulting object will be in radians.
   * @param cartesian - The Cartesian position to convert to cartographic representation.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the position lies.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.
   */
  fromCartesian(cartesian: Cartesian3, ellipsoid?: Ellipsoid, result?: Cartographic): Cartographic;
  /**
   * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted
   * object should be in radians.
   * @param cartographic - Input to be converted into a Cartesian3 output.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the position lies.
   * @param [result] - The object onto which to store the result.
   * @returns The position
   */
  toCartesian(cartographic: Cartographic, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;
  /**
   * Duplicates a Cartographic instance.
   * @param cartographic - The cartographic to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)
   */
  clone(cartographic: Cartographic, result?: Cartographic): Cartographic;
  /**
   * Compares the provided cartographics componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [left] - The first cartographic.
   * @param [right] - The second cartographic.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left?: Cartographic, right?: Cartographic): boolean;
  /**
   * Compares the provided cartographics componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   * @param [left] - The first cartographic.
   * @param [right] - The second cartographic.
   * @param [epsilon = 0] - The epsilon to use for equality testing.
   * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(left?: Cartographic, right?: Cartographic, epsilon?: number): boolean;
  /**
   * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).
   */
  readonly ZERO: Cartographic;
  /**
   * Duplicates this instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartographic instance if one was not provided.
   */
  clone(result?: Cartographic): Cartographic;
  /**
   * Compares the provided against this cartographic componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The second cartographic.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(right?: Cartographic): boolean;
  /**
   * Compares the provided against this cartographic componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   * @param [right] - The second cartographic.
   * @param [epsilon = 0] - The epsilon to use for equality testing.
   * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(right?: Cartographic, epsilon?: number): boolean;
  /**
   * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.
   * @returns A string representing the provided cartographic in the format '(longitude, latitude, height)'.
   */
  toString(): string;
}

/**
 * Geocodes queries containing longitude and latitude coordinates and an optional height.
 * Query format: `longitude latitude (height)` with longitude/latitude in degrees and height in meters.
 */
export class CartographicGeocoderService {
  constructor();
  /**
   * @param query - The query to be sent to the geocoder service
   */
  geocode(query: string): Promise<GeocoderService.Result[]>;
}

/**
 * A Catmull-Rom spline is a cubic spline where the tangent at control points,
 * except the first and last, are computed using the previous and next control points.
 * Catmull-Rom splines are in the class C<sup>1</sup>.
 * @example
 * // spline above the earth from Philadelphia to Los Angeles
 * const spline = new SuperMap.CatmullRomSpline({
 *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],
 *     points : [
 *         new SuperMap.Cartesian3(1235398.0, -4810983.0, 4146266.0),
 *         new SuperMap.Cartesian3(1372574.0, -5345182.0, 4606657.0),
 *         new SuperMap.Cartesian3(-757983.0, -5542796.0, 4514323.0),
 *         new SuperMap.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
 *         new SuperMap.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
 *     ]
 * });
 *
 * const p0 = spline.evaluate(times[i]);         // equal to positions[i]
 * const p1 = spline.evaluate(times[i] + delta); // interpolated value when delta < times[i + 1] - times[i]
 * @param options - Object with the following properties:
 * @param options.times - An array of strictly increasing, unit-less, floating-point times at each point.
 *                The values are in no way connected to the clock time. They are the parameterization for the curve.
 * @param options.points - The array of {@link Cartesian3} control points.
 * @param [options.firstTangent] - The tangent of the curve at the first control point.
 *                     If the tangent is not given, it will be estimated.
 * @param [options.lastTangent] - The tangent of the curve at the last control point.
 *                     If the tangent is not given, it will be estimated.
 */
export class CatmullRomSpline {
  constructor(options: {
    times: number[];
    points: Cartesian3[];
    firstTangent?: Cartesian3;
    lastTangent?: Cartesian3;
  });
  /**
   * An array of times for the control points.
   */
  readonly times: number[];
  /**
   * An array of {@link Cartesian3} control points.
   */
  readonly points: Cartesian3[];
  /**
   * The tangent at the first control point.
   */
  readonly firstTangent: Cartesian3;
  /**
   * The tangent at the last control point.
   */
  readonly lastTangent: Cartesian3;
  /**
   * Finds an index <code>i</code> in <code>times</code> such that the parameter
   * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
   * @param time - The time.
   * @returns The index for the element at the start of the interval.
   */
  findTimeInterval(time: number): number;
  /**
   * Wraps the given time to the period covered by the spline.
   * @param time - The time.
   * @returns The time, wrapped around to the updated animation.
   */
  wrapTime(time: number): number;
  /**
   * Clamps the given time to the period covered by the spline.
   * @param time - The time.
   * @returns The time, clamped to the animation period.
   */
  clampTime(time: number): number;
  /**
   * Evaluates the curve at a given time.
   * @param time - The time at which to evaluate the curve.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new instance of the point on the curve at the given time.
   */
  evaluate(time: number, result?: Cartesian3): Cartesian3;
}

/**
 * A {@link TerrainProvider} 以supermap地形格式访问地形数据.
 * @example
 * // 创建带有法线的 Arctic DEM terrain.
 * const viewer = new SuperMap.Viewer('CesiumContainer', {
 *     terrainProvider : new SuperMap.SuperMapTerrainProvider({
 *         url : SuperMap.IonResource.fromAssetId(3956),
 *         requestVertexNormals : true
 *     })
 * });
 * @param options - 具有以下属性的对象:
 * @param options.url - SuperMap terrain server的url.
 * @param [options.requestVertexNormals = false] - 指示客户端是否应该从服务器请求额外的照明信息，如果可用，以每个顶点法线的形式.
 * @param [options.requestWaterMask = false] - 指示客户端是否应该向服务器请求每个瓦片水掩码(如果可用的话).
 * @param [options.requestMetadata = true] - 指示客户端是否应该向服务器请求每个tile元数据(如果可用的话).
 * @param [options.ellipsoid] - 椭球。如果未指定，则使用WGS84椭球.
 * @param [options.credit] - 数据源的信用，它显示在画布上.
 */
export class SuperMapTerrainProvider {
  constructor(options: {
    url: Resource | string | Promise<Resource> | Promise<string>;
    requestVertexNormals?: boolean;
    requestWaterMask?: boolean;
    requestMetadata?: boolean;
    ellipsoid?: Ellipsoid;
    credit?: Credit | string;
  });
  /**
   * Requests the geometry for a given tile.  This function should not be called before
   * {@link SuperMapTerrainProvider#ready} returns true.  The result must include terrain data and
   * may optionally include a water mask and an indication of which child tiles are available.
   * @param x - The X coordinate of the tile for which to request geometry.
   * @param y - The Y coordinate of the tile for which to request geometry.
   * @param level - The level of the tile for which to request geometry.
   * @param [request] - The request object. Intended for internal use only.
   * @returns A promise for the requested geometry.  If this method
   *          returns undefined instead of a promise, it is an indication that too many requests are already
   *          pending and the request will be retried later.
   */
  requestTileGeometry(x: number, y: number, level: number, request?: Request): Promise<TerrainData> | undefined;
  /**
   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
   * are passed an instance of {@link TileProviderError}.
   */
  readonly errorEvent: Event;
  /**
   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
   * the source of the terrain.  This function should not be called before {@link SuperMapTerrainProvider#ready} returns true.
   */
  readonly credit: Credit;
  /**
   * Gets the tiling scheme used by this provider.  This function should
   * not be called before {@link SuperMapTerrainProvider#ready} returns true.
   */
  readonly tilingScheme: GeographicTilingScheme;
  /**
   * Gets a value indicating whether or not the provider is ready for use.
   */
  readonly ready: boolean;
  /**
   * Gets a promise that resolves to true when the provider is ready for use.
   */
  readonly readyPromise: Promise<boolean>;
  /**
   * Gets a value indicating whether or not the provider includes a water mask.  The water mask
   * indicates which areas of the globe are water rather than land, so they can be rendered
   * as a reflective surface with animated waves.  This function should not be
   * called before {@link SuperMapTerrainProvider#ready} returns true.
   */
  readonly hasWaterMask: boolean;
  /**
   * Gets a value indicating whether or not the requested tiles include vertex normals.
   * This function should not be called before {@link SuperMapTerrainProvider#ready} returns true.
   */
  readonly hasVertexNormals: boolean;
  /**
   * Gets a value indicating whether or not the requested tiles include metadata.
   * This function should not be called before {@link SuperMapTerrainProvider#ready} returns true.
   */
  readonly hasMetadata: boolean;
  /**
   * Boolean flag that indicates if the client should request vertex normals from the server.
   * Vertex normals data is appended to the standard tile mesh data only if the client requests the vertex normals and
   * if the server provides vertex normals.
   */
  readonly requestVertexNormals: boolean;
  /**
   * Boolean flag that indicates if the client should request a watermask from the server.
   * Watermask data is appended to the standard tile mesh data only if the client requests the watermask and
   * if the server provides a watermask.
   */
  readonly requestWaterMask: boolean;
  /**
   * Boolean flag that indicates if the client should request metadata from the server.
   * Metadata is appended to the standard tile mesh data only if the client requests the metadata and
   * if the server provides a metadata.
   */
  readonly requestMetadata: boolean;
  /**
   * Gets an object that can be used to determine availability of terrain from this provider, such as
   * at points and in rectangles.  This function should not be called before
   * {@link SuperMapTerrainProvider#ready} returns true.  This property may be undefined if availability
   * information is not available. Note that this reflects tiles that are known to be available currently.
   * Additional tiles may be discovered to be available in the future, e.g. if availability information
   * exists deeper in the tree rather than it all being discoverable at the root. However, a tile that
   * is available now will not become unavailable in the future.
   */
  readonly availability: TileAvailability;
  /**
   * Gets the maximum geometric error allowed in a tile at a given level.
   * @param level - The tile level for which to get the maximum geometric error.
   * @returns The maximum geometric error.
   */
  getLevelMaximumGeometricError(level: number): number;
  /**
   * Determines whether data for a tile is available to be loaded.
   * @param x - The X coordinate of the tile for which to request geometry.
   * @param y - The Y coordinate of the tile for which to request geometry.
   * @param level - The level of the tile for which to request geometry.
   * @returns Undefined if not supported or availability is unknown, otherwise true or false.
   */
  getTileDataAvailable(x: number, y: number, level: number): boolean | undefined;
  /**
   * Makes sure we load availability data for a tile
   * @param x - The X coordinate of the tile for which to request geometry.
   * @param y - The Y coordinate of the tile for which to request geometry.
   * @param level - The level of the tile for which to request geometry.
   * @returns Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded
   */
  loadTileDataAvailability(x: number, y: number, level: number): undefined | Promise<void>;
}

/**
 * A description of a circle on the ellipsoid. Circle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
 * @example
 * // Create a circle.
 * const circle = new SuperMap.CircleGeometry({
 *   center : SuperMap.Cartesian3.fromDegrees(-75.59777, 40.03883),
 *   radius : 100000.0
 * });
 * const geometry = SuperMap.CircleGeometry.createGeometry(circle);
 * @param options - Object with the following properties:
 * @param options.center - The circle's center point in the fixed frame.
 * @param options.radius - The radius in meters.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid the circle will be on.
 * @param [options.height = 0.0] - The distance in meters between the circle and the ellipsoid surface.
 * @param [options.granularity = 0.02] - The angular distance between points on the circle in radians.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 * @param [options.extrudedHeight = 0.0] - The distance in meters between the circle's extruded face and the ellipsoid surface.
 * @param [options.stRotation = 0.0] - The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
 */
export class CircleGeometry {
  constructor(options: {
    center: Cartesian3;
    radius: number;
    ellipsoid?: Ellipsoid;
    height?: number;
    granularity?: number;
    vertexFormat?: VertexFormat;
    extrudedHeight?: number;
    stRotation?: number;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: CircleGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new CircleGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: CircleGeometry): CircleGeometry;
  /**
   * Computes the geometric representation of a circle on an ellipsoid, including its vertices, indices, and a bounding sphere.
   * @param circleGeometry - A description of the circle.
   * @returns The computed vertices and indices.
   */
  createGeometry(circleGeometry: CircleGeometry): Geometry | undefined;
}

/**
 * A description of the outline of a circle on the ellipsoid.
 * @example
 * // Create a circle.
 * const circle = new SuperMap.CircleOutlineGeometry({
 *   center : SuperMap.Cartesian3.fromDegrees(-75.59777, 40.03883),
 *   radius : 100000.0
 * });
 * const geometry = SuperMap.CircleOutlineGeometry.createGeometry(circle);
 * @param options - Object with the following properties:
 * @param options.center - The circle's center point in the fixed frame.
 * @param options.radius - The radius in meters.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid the circle will be on.
 * @param [options.height = 0.0] - The distance in meters between the circle and the ellipsoid surface.
 * @param [options.granularity = 0.02] - The angular distance between points on the circle in radians.
 * @param [options.extrudedHeight = 0.0] - The distance in meters between the circle's extruded face and the ellipsoid surface.
 * @param [options.numberOfVerticalLines = 16] - Number of lines to draw between the top and bottom of an extruded circle.
 */
export class CircleOutlineGeometry {
  constructor(options: {
    center: Cartesian3;
    radius: number;
    ellipsoid?: Ellipsoid;
    height?: number;
    granularity?: number;
    extrudedHeight?: number;
    numberOfVerticalLines?: number;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: CircleOutlineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new CircleOutlineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: CircleOutlineGeometry): CircleOutlineGeometry;
  /**
   * Computes the geometric representation of an outline of a circle on an ellipsoid, including its vertices, indices, and a bounding sphere.
   * @param circleGeometry - A description of the circle.
   * @returns The computed vertices and indices.
   */
  createGeometry(circleGeometry: CircleOutlineGeometry): Geometry | undefined;
}

/**
 * A simple clock for keeping track of simulated time.
 * @example
 * // Create a clock that loops on Christmas day 2013 and runs in real-time.
 * const clock = new SuperMap.Clock({
 *    startTime : SuperMap.JulianDate.fromIso8601("2013-12-25"),
 *    currentTime : SuperMap.JulianDate.fromIso8601("2013-12-25"),
 *    stopTime : SuperMap.JulianDate.fromIso8601("2013-12-26"),
 *    clockRange : SuperMap.ClockRange.LOOP_STOP,
 *    clockStep : SuperMap.ClockStep.SYSTEM_CLOCK_MULTIPLIER
 * });
 * @param [options] - Object with the following properties:
 * @param [options.startTime] - The start time of the clock.
 * @param [options.stopTime] - The stop time of the clock.
 * @param [options.currentTime] - The current time.
 * @param [options.multiplier = 1.0] - Determines how much time advances when {@link Clock#tick} is called, negative values allow for advancing backwards.
 * @param [options.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER] - Determines if calls to {@link Clock#tick} are frame dependent or system clock dependent.
 * @param [options.clockRange = ClockRange.UNBOUNDED] - Determines how the clock should behave when {@link Clock#startTime} or {@link Clock#stopTime} is reached.
 * @param [options.canAnimate = true] - Indicates whether {@link Clock#tick} can advance time.  This could be false if data is being buffered, for example.  The clock will only tick when both {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
 * @param [options.shouldAnimate = false] - Indicates whether {@link Clock#tick} should attempt to advance time.  The clock will only tick when both {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
 */
export class Clock {
  constructor(options?: {
    startTime?: JulianDate;
    stopTime?: JulianDate;
    currentTime?: JulianDate;
    multiplier?: number;
    clockStep?: ClockStep;
    clockRange?: ClockRange;
    canAnimate?: boolean;
    shouldAnimate?: boolean;
  });
  /**
   * The start time of the clock.
   */
  startTime: JulianDate;
  /**
   * The stop time of the clock.
   */
  stopTime: JulianDate;
  /**
   * Determines how the clock should behave when
   * {@link Clock#startTime} or {@link Clock#stopTime}
   * is reached.
   */
  clockRange: ClockRange;
  /**
   * Indicates whether {@link Clock#tick} can advance time.  This could be false if data is being buffered,
   * for example.  The clock will only advance time when both
   * {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
   */
  canAnimate: boolean;
  /**
   * An {@link Event} that is fired whenever {@link Clock#tick} is called.
   */
  onTick: Event;
  /**
   * An {@link Event} that is fired whenever {@link Clock#stopTime} is reached.
   */
  onStop: Event;
  /**
   * The current time.
   * Changing this property will change
   * {@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to
   * {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.
   */
  currentTime: JulianDate;
  /**
   * Gets or sets how much time advances when {@link Clock#tick} is called. Negative values allow for advancing backwards.
   * If {@link Clock#clockStep} is set to {@link ClockStep.TICK_DEPENDENT}, this is the number of seconds to advance.
   * If {@link Clock#clockStep} is set to {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}, this value is multiplied by the
   * elapsed system time since the last call to {@link Clock#tick}.
   * Changing this property will change
   * {@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to
   * {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.
   */
  multiplier: number;
  /**
   * Determines if calls to {@link Clock#tick} are frame dependent or system clock dependent.
   * Changing this property to {@link ClockStep.SYSTEM_CLOCK} will set
   * {@link Clock#multiplier} to 1.0, {@link Clock#shouldAnimate} to true, and
   * {@link Clock#currentTime} to the current system clock time.
   */
  clockStep: ClockStep;
  /**
   * Indicates whether {@link Clock#tick} should attempt to advance time.
   * The clock will only advance time when both
   * {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
   * Changing this property will change
   * {@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to
   * {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.
   */
  shouldAnimate: boolean;
  /**
   * Advances the clock from the current time based on the current configuration options.
   * tick should be called every frame, regardless of whether animation is taking place
   * or not.  To control animation, use the {@link Clock#shouldAnimate} property.
   * @returns The new value of the {@link Clock#currentTime} property.
   */
  tick(): JulianDate;
}

/**
* Constants used by {@link Clock#tick} to determine behavior
* when {@link Clock#startTime} or {@link Clock#stopTime} is reached.
*/
export enum ClockRange {
  /**
   * {@link Clock#tick} will always advances the clock in its current direction.
   */
  UNBOUNDED = 0,
  /**
   * When {@link Clock#startTime} or {@link Clock#stopTime} is reached,
   * {@link Clock#tick} will not advance {@link Clock#currentTime} any further.
   */
  CLAMPED = 1,
  /**
   * When {@link Clock#stopTime} is reached, {@link Clock#tick} will advance
   * {@link Clock#currentTime} to the opposite end of the interval.  When
   * time is moving backwards, {@link Clock#tick} will not advance past
   * {@link Clock#startTime}
   */
  LOOP_STOP = 2
}

/**
* Constants to determine how much time advances with each call
* to {@link Clock#tick}.
*/
export enum ClockStep {
  /**
   * {@link Clock#tick} advances the current time by a fixed step,
   * which is the number of seconds specified by {@link Clock#multiplier}.
   */
  TICK_DEPENDENT = 0,
  /**
   * {@link Clock#tick} advances the current time by the amount of system
   * time elapsed since the previous call multiplied by {@link Clock#multiplier}.
   */
  SYSTEM_CLOCK_MULTIPLIER = 1,
  /**
   * {@link Clock#tick} sets the clock to the current system time;
   * ignoring all other settings.
   */
  SYSTEM_CLOCK = 2
}

/**
* A color, specified using red, green, blue, and alpha values,
* which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).
* @param [red = 1.0] - The red component.
* @param [green = 1.0] - The green component.
* @param [blue = 1.0] - The blue component.
* @param [alpha = 1.0] - The alpha component.
*/
export class Color {
  constructor(red?: number, green?: number, blue?: number, alpha?: number);
  /**
   * The red component.
   */
  red: number;
  /**
   * The green component.
   */
  green: number;
  /**
   * The blue component.
   */
  blue: number;
  /**
   * The alpha component.
   */
  alpha: number;
  /**
   * Creates a Color instance from a {@link Cartesian4}. <code>x</code>, <code>y</code>, <code>z</code>,
   * and <code>w</code> map to <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code>, respectively.
   * @param cartesian - The source cartesian.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Color instance if one was not provided.
   */
  fromCartesian4(cartesian: Cartesian4, result?: Color): Color;
  /**
   * Creates a new Color specified using red, green, blue, and alpha values
   * that are in the range of 0 to 255, converting them internally to a range of 0.0 to 1.0.
   * @param [red = 255] - The red component.
   * @param [green = 255] - The green component.
   * @param [blue = 255] - The blue component.
   * @param [alpha = 255] - The alpha component.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Color instance if one was not provided.
   */
  fromBytes(red?: number, green?: number, blue?: number, alpha?: number, result?: Color): Color;
  /**
   * Creates a new Color that has the same red, green, and blue components
   * of the specified color, but with the specified alpha value.
   * @example
   * const translucentRed = SuperMap.Color.fromAlpha(SuperMap.Color.RED, 0.9);
   * @param color - The base color
   * @param alpha - The new alpha component.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Color instance if one was not provided.
   */
  fromAlpha(color: Color, alpha: number, result?: Color): Color;
  /**
   * Creates a new Color from a single numeric unsigned 32-bit RGBA value, using the endianness
   * of the system.
   * @example
   * const color = SuperMap.Color.fromRgba(0x67ADDFFF);
   * @param rgba - A single numeric unsigned 32-bit RGBA value.
   * @param [result] - The object to store the result in, if undefined a new instance will be created.
   * @returns The color object.
   */
  fromRgba(rgba: number, result?: Color): Color;
  /**
   * Creates a Color instance from hue, saturation, and lightness.
   * @param [hue = 0] - The hue angle 0...1
   * @param [saturation = 0] - The saturation value 0...1
   * @param [lightness = 0] - The lightness value 0...1
   * @param [alpha = 1.0] - The alpha component 0...1
   * @param [result] - The object to store the result in, if undefined a new instance will be created.
   * @returns The color object.
   */
  fromHsl(hue?: number, saturation?: number, lightness?: number, alpha?: number, result?: Color): Color;
  /**
   * Creates a random color using the provided options. For reproducible random colors, you should
   * call {@link Math#setRandomNumberSeed} once at the beginning of your application.
   * @example
   * //Create a completely random color
   * const color = SuperMap.Color.fromRandom();
   *
   * //Create a random shade of yellow.
   * const color1 = SuperMap.Color.fromRandom({
   *     red : 1.0,
   *     green : 1.0,
   *     alpha : 1.0
   * });
   *
   * //Create a random bright color.
   * const color2 = SuperMap.Color.fromRandom({
   *     minimumRed : 0.75,
   *     minimumGreen : 0.75,
   *     minimumBlue : 0.75,
   *     alpha : 1.0
   * });
   * @param [options] - Object with the following properties:
   * @param [options.red] - If specified, the red component to use instead of a randomized value.
   * @param [options.minimumRed = 0.0] - The maximum red value to generate if none was specified.
   * @param [options.maximumRed = 1.0] - The minimum red value to generate if none was specified.
   * @param [options.green] - If specified, the green component to use instead of a randomized value.
   * @param [options.minimumGreen = 0.0] - The maximum green value to generate if none was specified.
   * @param [options.maximumGreen = 1.0] - The minimum green value to generate if none was specified.
   * @param [options.blue] - If specified, the blue component to use instead of a randomized value.
   * @param [options.minimumBlue = 0.0] - The maximum blue value to generate if none was specified.
   * @param [options.maximumBlue = 1.0] - The minimum blue value to generate if none was specified.
   * @param [options.alpha] - If specified, the alpha component to use instead of a randomized value.
   * @param [options.minimumAlpha = 0.0] - The maximum alpha value to generate if none was specified.
   * @param [options.maximumAlpha = 1.0] - The minimum alpha value to generate if none was specified.
   * @param [result] - The object to store the result in, if undefined a new instance will be created.
   * @returns The modified result parameter or a new instance if result was undefined.
   */
  fromRandom(options?: {
    red?: number;
    minimumRed?: number;
    maximumRed?: number;
    green?: number;
    minimumGreen?: number;
    maximumGreen?: number;
    blue?: number;
    minimumBlue?: number;
    maximumBlue?: number;
    alpha?: number;
    minimumAlpha?: number;
    maximumAlpha?: number;
  }, result?: Color): Color;
  /**
   * Creates a Color instance from a CSS color value.
   * @example
   * const CesiumBlue = SuperMap.Color.fromCssColorString('#67ADDF');
   * const green = SuperMap.Color.fromCssColorString('green');
   * @param color - The CSS color value in #rgb, #rgba, #rrggbb, #rrggbbaa, rgb(), rgba(), hsl(), or hsla() format.
   * @param [result] - The object to store the result in, if undefined a new instance will be created.
   * @returns The color object, or undefined if the string was not a valid CSS color.
   */
  fromCssColorString(color: string, result?: Color): Color;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: Color, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Color instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: Color): Color;
  /**
   * Converts a 'byte' color component in the range of 0 to 255 into
   * a 'float' color component in the range of 0 to 1.0.
   * @param number - The number to be converted.
   * @returns The converted number.
   */
  byteToFloat(number: number): number;
  /**
   * Converts a 'float' color component in the range of 0 to 1.0 into
   * a 'byte' color component in the range of 0 to 255.
   * @param number - The number to be converted.
   * @returns The converted number.
   */
  floatToByte(number: number): number;
  /**
   * Duplicates a Color.
   * @param color - The Color to duplicate.
   * @param [result] - The object to store the result in, if undefined a new instance will be created.
   * @returns The modified result parameter or a new instance if result was undefined. (Returns undefined if color is undefined)
   */
  clone(color: Color, result?: Color): Color;
  /**
   * Returns true if the first Color equals the second color.
   * @param left - The first Color to compare for equality.
   * @param right - The second Color to compare for equality.
   * @returns <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
   */
  equals(left: Color, right: Color): boolean;
  /**
   * Returns a duplicate of a Color instance.
   * @param [result] - The object to store the result in, if undefined a new instance will be created.
   * @returns The modified result parameter or a new instance if result was undefined.
   */
  clone(result?: Color): Color;
  /**
   * Returns true if this Color equals other.
   * @param other - The Color to compare for equality.
   * @returns <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
   */
  equals(other: Color): boolean;
  /**
   * Returns <code>true</code> if this Color equals other componentwise within the specified epsilon.
   * @param other - The Color to compare for equality.
   * @param [epsilon = 0.0] - The epsilon to use for equality testing.
   * @returns <code>true</code> if the Colors are equal within the specified epsilon; otherwise, <code>false</code>.
   */
  equalsEpsilon(other: Color, epsilon?: number): boolean;
  /**
   * Creates a string representing this Color in the format '(red, green, blue, alpha)'.
   * @returns A string representing this Color in the format '(red, green, blue, alpha)'.
   */
  toString(): string;
  /**
   * Creates a string containing the CSS color value for this color.
   * @returns The CSS equivalent of this color.
   */
  toCssColorString(): string;
  /**
   * Creates a string containing CSS hex string color value for this color.
   * @returns The CSS hex string equivalent of this color.
   */
  toCssHexString(): string;
  /**
   * Converts this color to an array of red, green, blue, and alpha values
   * that are in the range of 0 to 255.
   * @param [result] - The array to store the result in, if undefined a new instance will be created.
   * @returns The modified result parameter or a new instance if result was undefined.
   */
  toBytes(result?: number[]): number[];
  /**
   * Converts this color to a single numeric unsigned 32-bit RGBA value, using the endianness
   * of the system.
   * @example
   * const rgba = SuperMap.Color.BLUE.toRgba();
   * @returns A single numeric unsigned 32-bit RGBA value.
   */
  toRgba(): number;
  /**
   * Brightens this color by the provided magnitude.
   * @example
   * const brightBlue = SuperMap.Color.BLUE.brighten(0.5, new SuperMap.Color());
   * @param magnitude - A positive number indicating the amount to brighten.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  brighten(magnitude: number, result: Color): Color;
  /**
   * Darkens this color by the provided magnitude.
   * @example
   * const darkBlue = SuperMap.Color.BLUE.darken(0.5, new SuperMap.Color());
   * @param magnitude - A positive number indicating the amount to darken.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  darken(magnitude: number, result: Color): Color;
  /**
   * Creates a new Color that has the same red, green, and blue components
   * as this Color, but with the specified alpha value.
   * @example
   * const translucentRed = SuperMap.Color.RED.withAlpha(0.9);
   * @param alpha - The new alpha component.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Color instance if one was not provided.
   */
  withAlpha(alpha: number, result?: Color): Color;
  /**
   * Computes the componentwise sum of two Colors.
   * @param left - The first Color.
   * @param right - The second Color.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  add(left: Color, right: Color, result: Color): Color;
  /**
   * Computes the componentwise difference of two Colors.
   * @param left - The first Color.
   * @param right - The second Color.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  subtract(left: Color, right: Color, result: Color): Color;
  /**
   * Computes the componentwise product of two Colors.
   * @param left - The first Color.
   * @param right - The second Color.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiply(left: Color, right: Color, result: Color): Color;
  /**
   * Computes the componentwise quotient of two Colors.
   * @param left - The first Color.
   * @param right - The second Color.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  divide(left: Color, right: Color, result: Color): Color;
  /**
   * Computes the componentwise modulus of two Colors.
   * @param left - The first Color.
   * @param right - The second Color.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  mod(left: Color, right: Color, result: Color): Color;
  /**
   * Computes the linear interpolation or extrapolation at t between the provided colors.
   * @param start - The color corresponding to t at 0.0.
   * @param end - The color corresponding to t at 1.0.
   * @param t - The point along t at which to interpolate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  lerp(start: Color, end: Color, t: number, result: Color): Color;
  /**
   * Multiplies the provided Color componentwise by the provided scalar.
   * @param color - The Color to be scaled.
   * @param scalar - The scalar to multiply with.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByScalar(color: Color, scalar: number, result: Color): Color;
  /**
   * Divides the provided Color componentwise by the provided scalar.
   * @param color - The Color to be divided.
   * @param scalar - The scalar to divide with.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  divideByScalar(color: Color, scalar: number, result: Color): Color;
  /**
   * An immutable Color instance initialized to CSS color #F0F8FF
   * <span class="colorSwath" style="background: #F0F8FF;"></span>
   */
  readonly ALICEBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #FAEBD7
   * <span class="colorSwath" style="background: #FAEBD7;"></span>
   */
  readonly ANTIQUEWHITE: Color;
  /**
   * An immutable Color instance initialized to CSS color #00FFFF
   * <span class="colorSwath" style="background: #00FFFF;"></span>
   */
  readonly AQUA: Color;
  /**
   * An immutable Color instance initialized to CSS color #7FFFD4
   * <span class="colorSwath" style="background: #7FFFD4;"></span>
   */
  readonly AQUAMARINE: Color;
  /**
   * An immutable Color instance initialized to CSS color #F0FFFF
   * <span class="colorSwath" style="background: #F0FFFF;"></span>
   */
  readonly AZURE: Color;
  /**
   * An immutable Color instance initialized to CSS color #F5F5DC
   * <span class="colorSwath" style="background: #F5F5DC;"></span>
   */
  readonly BEIGE: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFE4C4
   * <span class="colorSwath" style="background: #FFE4C4;"></span>
   */
  readonly BISQUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #000000
   * <span class="colorSwath" style="background: #000000;"></span>
   */
  readonly BLACK: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFEBCD
   * <span class="colorSwath" style="background: #FFEBCD;"></span>
   */
  readonly BLANCHEDALMOND: Color;
  /**
   * An immutable Color instance initialized to CSS color #0000FF
   * <span class="colorSwath" style="background: #0000FF;"></span>
   */
  readonly BLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #8A2BE2
   * <span class="colorSwath" style="background: #8A2BE2;"></span>
   */
  readonly BLUEVIOLET: Color;
  /**
   * An immutable Color instance initialized to CSS color #A52A2A
   * <span class="colorSwath" style="background: #A52A2A;"></span>
   */
  readonly BROWN: Color;
  /**
   * An immutable Color instance initialized to CSS color #DEB887
   * <span class="colorSwath" style="background: #DEB887;"></span>
   */
  readonly BURLYWOOD: Color;
  /**
   * An immutable Color instance initialized to CSS color #5F9EA0
   * <span class="colorSwath" style="background: #5F9EA0;"></span>
   */
  readonly CADETBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #7FFF00
   * <span class="colorSwath" style="background: #7FFF00;"></span>
   */
  readonly CHARTREUSE: Color;
  /**
   * An immutable Color instance initialized to CSS color #D2691E
   * <span class="colorSwath" style="background: #D2691E;"></span>
   */
  readonly CHOCOLATE: Color;
  /**
   * An immutable Color instance initialized to CSS color #FF7F50
   * <span class="colorSwath" style="background: #FF7F50;"></span>
   */
  readonly CORAL: Color;
  /**
   * An immutable Color instance initialized to CSS color #6495ED
   * <span class="colorSwath" style="background: #6495ED;"></span>
   */
  readonly CORNFLOWERBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFF8DC
   * <span class="colorSwath" style="background: #FFF8DC;"></span>
   */
  readonly CORNSILK: Color;
  /**
   * An immutable Color instance initialized to CSS color #DC143C
   * <span class="colorSwath" style="background: #DC143C;"></span>
   */
  readonly CRIMSON: Color;
  /**
   * An immutable Color instance initialized to CSS color #00FFFF
   * <span class="colorSwath" style="background: #00FFFF;"></span>
   */
  readonly CYAN: Color;
  /**
   * An immutable Color instance initialized to CSS color #00008B
   * <span class="colorSwath" style="background: #00008B;"></span>
   */
  readonly DARKBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #008B8B
   * <span class="colorSwath" style="background: #008B8B;"></span>
   */
  readonly DARKCYAN: Color;
  /**
   * An immutable Color instance initialized to CSS color #B8860B
   * <span class="colorSwath" style="background: #B8860B;"></span>
   */
  readonly DARKGOLDENROD: Color;
  /**
   * An immutable Color instance initialized to CSS color #A9A9A9
   * <span class="colorSwath" style="background: #A9A9A9;"></span>
   */
  readonly DARKGRAY: Color;
  /**
   * An immutable Color instance initialized to CSS color #006400
   * <span class="colorSwath" style="background: #006400;"></span>
   */
  readonly DARKGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #A9A9A9
   * <span class="colorSwath" style="background: #A9A9A9;"></span>
   */
  readonly DARKGREY: Color;
  /**
   * An immutable Color instance initialized to CSS color #BDB76B
   * <span class="colorSwath" style="background: #BDB76B;"></span>
   */
  readonly DARKKHAKI: Color;
  /**
   * An immutable Color instance initialized to CSS color #8B008B
   * <span class="colorSwath" style="background: #8B008B;"></span>
   */
  readonly DARKMAGENTA: Color;
  /**
   * An immutable Color instance initialized to CSS color #556B2F
   * <span class="colorSwath" style="background: #556B2F;"></span>
   */
  readonly DARKOLIVEGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #FF8C00
   * <span class="colorSwath" style="background: #FF8C00;"></span>
   */
  readonly DARKORANGE: Color;
  /**
   * An immutable Color instance initialized to CSS color #9932CC
   * <span class="colorSwath" style="background: #9932CC;"></span>
   */
  readonly DARKORCHID: Color;
  /**
   * An immutable Color instance initialized to CSS color #8B0000
   * <span class="colorSwath" style="background: #8B0000;"></span>
   */
  readonly DARKRED: Color;
  /**
   * An immutable Color instance initialized to CSS color #E9967A
   * <span class="colorSwath" style="background: #E9967A;"></span>
   */
  readonly DARKSALMON: Color;
  /**
   * An immutable Color instance initialized to CSS color #8FBC8F
   * <span class="colorSwath" style="background: #8FBC8F;"></span>
   */
  readonly DARKSEAGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #483D8B
   * <span class="colorSwath" style="background: #483D8B;"></span>
   */
  readonly DARKSLATEBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #2F4F4F
   * <span class="colorSwath" style="background: #2F4F4F;"></span>
   */
  readonly DARKSLATEGRAY: Color;
  /**
   * An immutable Color instance initialized to CSS color #2F4F4F
   * <span class="colorSwath" style="background: #2F4F4F;"></span>
   */
  readonly DARKSLATEGREY: Color;
  /**
   * An immutable Color instance initialized to CSS color #00CED1
   * <span class="colorSwath" style="background: #00CED1;"></span>
   */
  readonly DARKTURQUOISE: Color;
  /**
   * An immutable Color instance initialized to CSS color #9400D3
   * <span class="colorSwath" style="background: #9400D3;"></span>
   */
  readonly DARKVIOLET: Color;
  /**
   * An immutable Color instance initialized to CSS color #FF1493
   * <span class="colorSwath" style="background: #FF1493;"></span>
   */
  readonly DEEPPINK: Color;
  /**
   * An immutable Color instance initialized to CSS color #00BFFF
   * <span class="colorSwath" style="background: #00BFFF;"></span>
   */
  readonly DEEPSKYBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #696969
   * <span class="colorSwath" style="background: #696969;"></span>
   */
  readonly DIMGRAY: Color;
  /**
   * An immutable Color instance initialized to CSS color #696969
   * <span class="colorSwath" style="background: #696969;"></span>
   */
  readonly DIMGREY: Color;
  /**
   * An immutable Color instance initialized to CSS color #1E90FF
   * <span class="colorSwath" style="background: #1E90FF;"></span>
   */
  readonly DODGERBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #B22222
   * <span class="colorSwath" style="background: #B22222;"></span>
   */
  readonly FIREBRICK: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFFAF0
   * <span class="colorSwath" style="background: #FFFAF0;"></span>
   */
  readonly FLORALWHITE: Color;
  /**
   * An immutable Color instance initialized to CSS color #228B22
   * <span class="colorSwath" style="background: #228B22;"></span>
   */
  readonly FORESTGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #FF00FF
   * <span class="colorSwath" style="background: #FF00FF;"></span>
   */
  readonly FUCHSIA: Color;
  /**
   * An immutable Color instance initialized to CSS color #DCDCDC
   * <span class="colorSwath" style="background: #DCDCDC;"></span>
   */
  readonly GAINSBORO: Color;
  /**
   * An immutable Color instance initialized to CSS color #F8F8FF
   * <span class="colorSwath" style="background: #F8F8FF;"></span>
   */
  readonly GHOSTWHITE: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFD700
   * <span class="colorSwath" style="background: #FFD700;"></span>
   */
  readonly GOLD: Color;
  /**
   * An immutable Color instance initialized to CSS color #DAA520
   * <span class="colorSwath" style="background: #DAA520;"></span>
   */
  readonly GOLDENROD: Color;
  /**
   * An immutable Color instance initialized to CSS color #808080
   * <span class="colorSwath" style="background: #808080;"></span>
   */
  readonly GRAY: Color;
  /**
   * An immutable Color instance initialized to CSS color #008000
   * <span class="colorSwath" style="background: #008000;"></span>
   */
  readonly GREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #ADFF2F
   * <span class="colorSwath" style="background: #ADFF2F;"></span>
   */
  readonly GREENYELLOW: Color;
  /**
   * An immutable Color instance initialized to CSS color #808080
   * <span class="colorSwath" style="background: #808080;"></span>
   */
  readonly GREY: Color;
  /**
   * An immutable Color instance initialized to CSS color #F0FFF0
   * <span class="colorSwath" style="background: #F0FFF0;"></span>
   */
  readonly HONEYDEW: Color;
  /**
   * An immutable Color instance initialized to CSS color #FF69B4
   * <span class="colorSwath" style="background: #FF69B4;"></span>
   */
  readonly HOTPINK: Color;
  /**
   * An immutable Color instance initialized to CSS color #CD5C5C
   * <span class="colorSwath" style="background: #CD5C5C;"></span>
   */
  readonly INDIANRED: Color;
  /**
   * An immutable Color instance initialized to CSS color #4B0082
   * <span class="colorSwath" style="background: #4B0082;"></span>
   */
  readonly INDIGO: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFFFF0
   * <span class="colorSwath" style="background: #FFFFF0;"></span>
   */
  readonly IVORY: Color;
  /**
   * An immutable Color instance initialized to CSS color #F0E68C
   * <span class="colorSwath" style="background: #F0E68C;"></span>
   */
  readonly KHAKI: Color;
  /**
   * An immutable Color instance initialized to CSS color #E6E6FA
   * <span class="colorSwath" style="background: #E6E6FA;"></span>
   */
  readonly LAVENDER: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFF0F5
   * <span class="colorSwath" style="background: #FFF0F5;"></span>
   */
  readonly LAVENDAR_BLUSH: Color;
  /**
   * An immutable Color instance initialized to CSS color #7CFC00
   * <span class="colorSwath" style="background: #7CFC00;"></span>
   */
  readonly LAWNGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFFACD
   * <span class="colorSwath" style="background: #FFFACD;"></span>
   */
  readonly LEMONCHIFFON: Color;
  /**
   * An immutable Color instance initialized to CSS color #ADD8E6
   * <span class="colorSwath" style="background: #ADD8E6;"></span>
   */
  readonly LIGHTBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #F08080
   * <span class="colorSwath" style="background: #F08080;"></span>
   */
  readonly LIGHTCORAL: Color;
  /**
   * An immutable Color instance initialized to CSS color #E0FFFF
   * <span class="colorSwath" style="background: #E0FFFF;"></span>
   */
  readonly LIGHTCYAN: Color;
  /**
   * An immutable Color instance initialized to CSS color #FAFAD2
   * <span class="colorSwath" style="background: #FAFAD2;"></span>
   */
  readonly LIGHTGOLDENRODYELLOW: Color;
  /**
   * An immutable Color instance initialized to CSS color #D3D3D3
   * <span class="colorSwath" style="background: #D3D3D3;"></span>
   */
  readonly LIGHTGRAY: Color;
  /**
   * An immutable Color instance initialized to CSS color #90EE90
   * <span class="colorSwath" style="background: #90EE90;"></span>
   */
  readonly LIGHTGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #D3D3D3
   * <span class="colorSwath" style="background: #D3D3D3;"></span>
   */
  readonly LIGHTGREY: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFB6C1
   * <span class="colorSwath" style="background: #FFB6C1;"></span>
   */
  readonly LIGHTPINK: Color;
  /**
   * An immutable Color instance initialized to CSS color #20B2AA
   * <span class="colorSwath" style="background: #20B2AA;"></span>
   */
  readonly LIGHTSEAGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #87CEFA
   * <span class="colorSwath" style="background: #87CEFA;"></span>
   */
  readonly LIGHTSKYBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #778899
   * <span class="colorSwath" style="background: #778899;"></span>
   */
  readonly LIGHTSLATEGRAY: Color;
  /**
   * An immutable Color instance initialized to CSS color #778899
   * <span class="colorSwath" style="background: #778899;"></span>
   */
  readonly LIGHTSLATEGREY: Color;
  /**
   * An immutable Color instance initialized to CSS color #B0C4DE
   * <span class="colorSwath" style="background: #B0C4DE;"></span>
   */
  readonly LIGHTSTEELBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFFFE0
   * <span class="colorSwath" style="background: #FFFFE0;"></span>
   */
  readonly LIGHTYELLOW: Color;
  /**
   * An immutable Color instance initialized to CSS color #00FF00
   * <span class="colorSwath" style="background: #00FF00;"></span>
   */
  readonly LIME: Color;
  /**
   * An immutable Color instance initialized to CSS color #32CD32
   * <span class="colorSwath" style="background: #32CD32;"></span>
   */
  readonly LIMEGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #FAF0E6
   * <span class="colorSwath" style="background: #FAF0E6;"></span>
   */
  readonly LINEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #FF00FF
   * <span class="colorSwath" style="background: #FF00FF;"></span>
   */
  readonly MAGENTA: Color;
  /**
   * An immutable Color instance initialized to CSS color #800000
   * <span class="colorSwath" style="background: #800000;"></span>
   */
  readonly MAROON: Color;
  /**
   * An immutable Color instance initialized to CSS color #66CDAA
   * <span class="colorSwath" style="background: #66CDAA;"></span>
   */
  readonly MEDIUMAQUAMARINE: Color;
  /**
   * An immutable Color instance initialized to CSS color #0000CD
   * <span class="colorSwath" style="background: #0000CD;"></span>
   */
  readonly MEDIUMBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #BA55D3
   * <span class="colorSwath" style="background: #BA55D3;"></span>
   */
  readonly MEDIUMORCHID: Color;
  /**
   * An immutable Color instance initialized to CSS color #9370DB
   * <span class="colorSwath" style="background: #9370DB;"></span>
   */
  readonly MEDIUMPURPLE: Color;
  /**
   * An immutable Color instance initialized to CSS color #3CB371
   * <span class="colorSwath" style="background: #3CB371;"></span>
   */
  readonly MEDIUMSEAGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #7B68EE
   * <span class="colorSwath" style="background: #7B68EE;"></span>
   */
  readonly MEDIUMSLATEBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #00FA9A
   * <span class="colorSwath" style="background: #00FA9A;"></span>
   */
  readonly MEDIUMSPRINGGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #48D1CC
   * <span class="colorSwath" style="background: #48D1CC;"></span>
   */
  readonly MEDIUMTURQUOISE: Color;
  /**
   * An immutable Color instance initialized to CSS color #C71585
   * <span class="colorSwath" style="background: #C71585;"></span>
   */
  readonly MEDIUMVIOLETRED: Color;
  /**
   * An immutable Color instance initialized to CSS color #191970
   * <span class="colorSwath" style="background: #191970;"></span>
   */
  readonly MIDNIGHTBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #F5FFFA
   * <span class="colorSwath" style="background: #F5FFFA;"></span>
   */
  readonly MINTCREAM: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFE4E1
   * <span class="colorSwath" style="background: #FFE4E1;"></span>
   */
  readonly MISTYROSE: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFE4B5
   * <span class="colorSwath" style="background: #FFE4B5;"></span>
   */
  readonly MOCCASIN: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFDEAD
   * <span class="colorSwath" style="background: #FFDEAD;"></span>
   */
  readonly NAVAJOWHITE: Color;
  /**
   * An immutable Color instance initialized to CSS color #000080
   * <span class="colorSwath" style="background: #000080;"></span>
   */
  readonly NAVY: Color;
  /**
   * An immutable Color instance initialized to CSS color #FDF5E6
   * <span class="colorSwath" style="background: #FDF5E6;"></span>
   */
  readonly OLDLACE: Color;
  /**
   * An immutable Color instance initialized to CSS color #808000
   * <span class="colorSwath" style="background: #808000;"></span>
   */
  readonly OLIVE: Color;
  /**
   * An immutable Color instance initialized to CSS color #6B8E23
   * <span class="colorSwath" style="background: #6B8E23;"></span>
   */
  readonly OLIVEDRAB: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFA500
   * <span class="colorSwath" style="background: #FFA500;"></span>
   */
  readonly ORANGE: Color;
  /**
   * An immutable Color instance initialized to CSS color #FF4500
   * <span class="colorSwath" style="background: #FF4500;"></span>
   */
  readonly ORANGERED: Color;
  /**
   * An immutable Color instance initialized to CSS color #DA70D6
   * <span class="colorSwath" style="background: #DA70D6;"></span>
   */
  readonly ORCHID: Color;
  /**
   * An immutable Color instance initialized to CSS color #EEE8AA
   * <span class="colorSwath" style="background: #EEE8AA;"></span>
   */
  readonly PALEGOLDENROD: Color;
  /**
   * An immutable Color instance initialized to CSS color #98FB98
   * <span class="colorSwath" style="background: #98FB98;"></span>
   */
  readonly PALEGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #AFEEEE
   * <span class="colorSwath" style="background: #AFEEEE;"></span>
   */
  readonly PALETURQUOISE: Color;
  /**
   * An immutable Color instance initialized to CSS color #DB7093
   * <span class="colorSwath" style="background: #DB7093;"></span>
   */
  readonly PALEVIOLETRED: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFEFD5
   * <span class="colorSwath" style="background: #FFEFD5;"></span>
   */
  readonly PAPAYAWHIP: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFDAB9
   * <span class="colorSwath" style="background: #FFDAB9;"></span>
   */
  readonly PEACHPUFF: Color;
  /**
   * An immutable Color instance initialized to CSS color #CD853F
   * <span class="colorSwath" style="background: #CD853F;"></span>
   */
  readonly PERU: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFC0CB
   * <span class="colorSwath" style="background: #FFC0CB;"></span>
   */
  readonly PINK: Color;
  /**
   * An immutable Color instance initialized to CSS color #DDA0DD
   * <span class="colorSwath" style="background: #DDA0DD;"></span>
   */
  readonly PLUM: Color;
  /**
   * An immutable Color instance initialized to CSS color #B0E0E6
   * <span class="colorSwath" style="background: #B0E0E6;"></span>
   */
  readonly POWDERBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #800080
   * <span class="colorSwath" style="background: #800080;"></span>
   */
  readonly PURPLE: Color;
  /**
   * An immutable Color instance initialized to CSS color #FF0000
   * <span class="colorSwath" style="background: #FF0000;"></span>
   */
  readonly RED: Color;
  /**
   * An immutable Color instance initialized to CSS color #BC8F8F
   * <span class="colorSwath" style="background: #BC8F8F;"></span>
   */
  readonly ROSYBROWN: Color;
  /**
   * An immutable Color instance initialized to CSS color #4169E1
   * <span class="colorSwath" style="background: #4169E1;"></span>
   */
  readonly ROYALBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #8B4513
   * <span class="colorSwath" style="background: #8B4513;"></span>
   */
  readonly SADDLEBROWN: Color;
  /**
   * An immutable Color instance initialized to CSS color #FA8072
   * <span class="colorSwath" style="background: #FA8072;"></span>
   */
  readonly SALMON: Color;
  /**
   * An immutable Color instance initialized to CSS color #F4A460
   * <span class="colorSwath" style="background: #F4A460;"></span>
   */
  readonly SANDYBROWN: Color;
  /**
   * An immutable Color instance initialized to CSS color #2E8B57
   * <span class="colorSwath" style="background: #2E8B57;"></span>
   */
  readonly SEAGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFF5EE
   * <span class="colorSwath" style="background: #FFF5EE;"></span>
   */
  readonly SEASHELL: Color;
  /**
   * An immutable Color instance initialized to CSS color #A0522D
   * <span class="colorSwath" style="background: #A0522D;"></span>
   */
  readonly SIENNA: Color;
  /**
   * An immutable Color instance initialized to CSS color #C0C0C0
   * <span class="colorSwath" style="background: #C0C0C0;"></span>
   */
  readonly SILVER: Color;
  /**
   * An immutable Color instance initialized to CSS color #87CEEB
   * <span class="colorSwath" style="background: #87CEEB;"></span>
   */
  readonly SKYBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #6A5ACD
   * <span class="colorSwath" style="background: #6A5ACD;"></span>
   */
  readonly SLATEBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #708090
   * <span class="colorSwath" style="background: #708090;"></span>
   */
  readonly SLATEGRAY: Color;
  /**
   * An immutable Color instance initialized to CSS color #708090
   * <span class="colorSwath" style="background: #708090;"></span>
   */
  readonly SLATEGREY: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFFAFA
   * <span class="colorSwath" style="background: #FFFAFA;"></span>
   */
  readonly SNOW: Color;
  /**
   * An immutable Color instance initialized to CSS color #00FF7F
   * <span class="colorSwath" style="background: #00FF7F;"></span>
   */
  readonly SPRINGGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS color #4682B4
   * <span class="colorSwath" style="background: #4682B4;"></span>
   */
  readonly STEELBLUE: Color;
  /**
   * An immutable Color instance initialized to CSS color #D2B48C
   * <span class="colorSwath" style="background: #D2B48C;"></span>
   */
  readonly TAN: Color;
  /**
   * An immutable Color instance initialized to CSS color #008080
   * <span class="colorSwath" style="background: #008080;"></span>
   */
  readonly TEAL: Color;
  /**
   * An immutable Color instance initialized to CSS color #D8BFD8
   * <span class="colorSwath" style="background: #D8BFD8;"></span>
   */
  readonly THISTLE: Color;
  /**
   * An immutable Color instance initialized to CSS color #FF6347
   * <span class="colorSwath" style="background: #FF6347;"></span>
   */
  readonly TOMATO: Color;
  /**
   * An immutable Color instance initialized to CSS color #40E0D0
   * <span class="colorSwath" style="background: #40E0D0;"></span>
   */
  readonly TURQUOISE: Color;
  /**
   * An immutable Color instance initialized to CSS color #EE82EE
   * <span class="colorSwath" style="background: #EE82EE;"></span>
   */
  readonly VIOLET: Color;
  /**
   * An immutable Color instance initialized to CSS color #F5DEB3
   * <span class="colorSwath" style="background: #F5DEB3;"></span>
   */
  readonly WHEAT: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFFFFF
   * <span class="colorSwath" style="background: #FFFFFF;"></span>
   */
  readonly WHITE: Color;
  /**
   * An immutable Color instance initialized to CSS color #F5F5F5
   * <span class="colorSwath" style="background: #F5F5F5;"></span>
   */
  readonly WHITESMOKE: Color;
  /**
   * An immutable Color instance initialized to CSS color #FFFF00
   * <span class="colorSwath" style="background: #FFFF00;"></span>
   */
  readonly YELLOW: Color;
  /**
   * An immutable Color instance initialized to CSS color #9ACD32
   * <span class="colorSwath" style="background: #9ACD32;"></span>
   */
  readonly YELLOWGREEN: Color;
  /**
   * An immutable Color instance initialized to CSS transparent.
   * <span class="colorSwath" style="background: transparent;"></span>
   */
  readonly TRANSPARENT: Color;
}

/**
* Value and type information for per-instance geometry color.
* @example
* const instance = new SuperMap.GeometryInstance({
*   geometry : SuperMap.BoxGeometry.fromDimensions({
*     dimensions : new SuperMap.Cartesian3(1000000.0, 1000000.0, 500000.0)
*   }),
*   modelMatrix : SuperMap.Matrix4.multiplyByTranslation(SuperMap.Transforms.eastNorthUpToFixedFrame(
*     SuperMap.Cartesian3.fromDegrees(0.0, 0.0)), new SuperMap.Cartesian3(0.0, 0.0, 1000000.0), new SuperMap.Matrix4()),
*   id : 'box',
*   attributes : {
*     color : new SuperMap.ColorGeometryInstanceAttribute(red, green, blue, alpha)
*   }
* });
* @param [red = 1.0] - The red component.
* @param [green = 1.0] - The green component.
* @param [blue = 1.0] - The blue component.
* @param [alpha = 1.0] - The alpha component.
*/
export class ColorGeometryInstanceAttribute {
  constructor(red?: number, green?: number, blue?: number, alpha?: number);
  /**
   * The values for the attributes stored in a typed array.
   */
  value: Uint8Array;
  /**
   * The datatype of each component in the attribute, e.g., individual elements in
   * {@link ColorGeometryInstanceAttribute#value}.
   */
  readonly componentDatatype: ComponentDatatype;
  /**
   * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.
   */
  readonly componentsPerAttribute: number;
  /**
   * When <code>true</code> and <code>componentDatatype</code> is an integer format,
   * indicate that the components should be mapped to the range [0, 1] (unsigned)
   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
   */
  readonly normalize: boolean;
  /**
   * Creates a new {@link ColorGeometryInstanceAttribute} instance given the provided {@link Color}.
   * @example
   * const instance = new SuperMap.GeometryInstance({
   *   geometry : geometry,
   *   attributes : {
   *     color : SuperMap.ColorGeometryInstanceAttribute.fromColor(SuperMap.Color.CORNFLOWERBLUE),
   *   }
   * });
   * @param color - The color.
   * @returns The new {@link ColorGeometryInstanceAttribute} instance.
   */
  fromColor(color: Color): ColorGeometryInstanceAttribute;
  /**
   * Converts a color to a typed array that can be used to assign a color attribute.
   * @example
   * const attributes = primitive.getGeometryInstanceAttributes('an id');
   * attributes.color = SuperMap.ColorGeometryInstanceAttribute.toValue(SuperMap.Color.AQUA, attributes.color);
   * @param color - The color.
   * @param [result] - The array to store the result in, if undefined a new instance will be created.
   * @returns The modified result parameter or a new instance if result was undefined.
   */
  toValue(color: Color, result?: Uint8Array): Uint8Array;
  /**
   * Compares the provided ColorGeometryInstanceAttributes and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [left] - The first ColorGeometryInstanceAttribute.
   * @param [right] - The second ColorGeometryInstanceAttribute.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left?: ColorGeometryInstanceAttribute, right?: ColorGeometryInstanceAttribute): boolean;
}

/**
* WebGL component datatypes.  Components are intrinsics,
* which form attributes, which form vertices.
*/
export enum ComponentDatatype {
  /**
   * 8-bit signed byte corresponding to <code>gl.BYTE</code> and the type
   * of an element in <code>Int8Array</code>.
   */
  BYTE = WebGLConstants.BYTE,
  /**
   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type
   * of an element in <code>Uint8Array</code>.
   */
  UNSIGNED_BYTE = WebGLConstants.UNSIGNED_BYTE,
  /**
   * 16-bit signed short corresponding to <code>SHORT</code> and the type
   * of an element in <code>Int16Array</code>.
   */
  SHORT = WebGLConstants.SHORT,
  /**
   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type
   * of an element in <code>Uint16Array</code>.
   */
  UNSIGNED_SHORT = WebGLConstants.UNSIGNED_SHORT,
  /**
   * 32-bit signed int corresponding to <code>INT</code> and the type
   * of an element in <code>Int32Array</code>.
   */
  INT = WebGLConstants.INT,
  /**
   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type
   * of an element in <code>Uint32Array</code>.
   */
  UNSIGNED_INT = WebGLConstants.UNSIGNED_INT,
  /**
   * 32-bit floating-point corresponding to <code>FLOAT</code> and the type
   * of an element in <code>Float32Array</code>.
   */
  FLOAT = WebGLConstants.FLOAT,
  /**
   * 64-bit floating-point corresponding to <code>gl.DOUBLE</code> (in Desktop OpenGL;
   * this is not supported in WebGL, and is emulated in SuperMap via {@link GeometryPipeline.encodeAttribute})
   * and the type of an element in <code>Float64Array</code>.
   */
  DOUBLE = WebGLConstants.DOUBLE
}

/**
* Describes a compressed texture and contains a compressed texture buffer.
* @param internalFormat - The pixel format of the compressed texture.
* @param pixelDatatype - The pixel datatype of the compressed texture.
* @param width - The width of the texture.
* @param height - The height of the texture.
* @param buffer - The compressed texture buffer.
*/
export class CompressedTextureBuffer {
  constructor(internalFormat: PixelFormat, pixelDatatype: PixelDatatype, width: number, height: number, buffer: Uint8Array);
  /**
   * The format of the compressed texture.
   */
  readonly internalFormat: PixelFormat;
  /**
   * The datatype of the compressed texture.
   */
  readonly pixelDatatype: PixelDatatype;
  /**
   * The width of the texture.
   */
  readonly width: number;
  /**
   * The height of the texture.
   */
  readonly height: number;
  /**
   * The compressed texture buffer.
   */
  readonly bufferView: Uint8Array;
  /**
   * Creates a shallow clone of a compressed texture buffer.
   * @param object - The compressed texture buffer to be cloned.
   * @returns A shallow clone of the compressed texture buffer.
   */
  clone(object: CompressedTextureBuffer): CompressedTextureBuffer;
  /**
   * Creates a shallow clone of this compressed texture buffer.
   * @returns A shallow clone of the compressed texture buffer.
   */
  clone(): CompressedTextureBuffer;
}

/**
 * A description of a polygon composed of arbitrary coplanar positions.
 * @example
 * const polygonGeometry = new SuperMap.CoplanarPolygonGeometry({
 *  polygonHierarchy: new SuperMap.PolygonHierarchy(
 *     SuperMap.Cartesian3.fromDegreesArrayHeights([
 *      -90.0, 30.0, 0.0,
 *      -90.0, 30.0, 300000.0,
 *      -80.0, 30.0, 300000.0,
 *      -80.0, 30.0, 0.0
 *   ]))
 * });
 * @param options - Object with the following properties:
 * @param options.polygonHierarchy - A polygon hierarchy that can include holes.
 * @param [options.stRotation = 0.0] - The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
 * @param [options.textureCoordinates] - Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points.
 */
export class CoplanarPolygonGeometry {
  constructor(options: {
    polygonHierarchy: PolygonHierarchy;
    stRotation?: number;
    vertexFormat?: VertexFormat;
    ellipsoid?: Ellipsoid;
    textureCoordinates?: PolygonHierarchy;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * A description of a coplanar polygon from an array of positions.
   * @example
   * // create a polygon from points
   * const polygon = SuperMap.CoplanarPolygonGeometry.fromPositions({
   *   positions : SuperMap.Cartesian3.fromDegreesArray([
   *     -72.0, 40.0,
   *     -70.0, 35.0,
   *     -75.0, 30.0,
   *     -70.0, 30.0,
   *     -68.0, 40.0
   *   ])
   * });
   * const geometry = SuperMap.PolygonGeometry.createGeometry(polygon);
   * @param options - Object with the following properties:
   * @param options.positions - An array of positions that defined the corner points of the polygon.
   * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
   * @param [options.stRotation = 0.0] - The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
   * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
   * @param [options.textureCoordinates] - Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points.
   */
  fromPositions(options: {
    positions: Cartesian3[];
    vertexFormat?: VertexFormat;
    stRotation?: number;
    ellipsoid?: Ellipsoid;
    textureCoordinates?: PolygonHierarchy;
  }): CoplanarPolygonGeometry;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: CoplanarPolygonGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new CoplanarPolygonGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: CoplanarPolygonGeometry): CoplanarPolygonGeometry;
  /**
   * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.
   * @param polygonGeometry - A description of the polygon.
   * @returns The computed vertices and indices.
   */
  createGeometry(polygonGeometry: CoplanarPolygonGeometry): Geometry | undefined;
}

/**
* A description of the outline of a polygon composed of arbitrary coplanar positions.
* @example
* const polygonOutline = new SuperMap.CoplanarPolygonOutlineGeometry({
*   positions : SuperMap.Cartesian3.fromDegreesArrayHeights([
*      -90.0, 30.0, 0.0,
*      -90.0, 30.0, 1000.0,
*      -80.0, 30.0, 1000.0,
*      -80.0, 30.0, 0.0
*   ])
* });
* const geometry = SuperMap.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);
* @param options - Object with the following properties:
* @param options.polygonHierarchy - A polygon hierarchy that can include holes.
*/
export class CoplanarPolygonOutlineGeometry {
  constructor(options: {
    polygonHierarchy: PolygonHierarchy;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * A description of a coplanar polygon outline from an array of positions.
   * @param options - Object with the following properties:
   * @param options.positions - An array of positions that defined the corner points of the polygon.
   */
  fromPositions(options: {
    positions: Cartesian3[];
  }): CoplanarPolygonOutlineGeometry;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: CoplanarPolygonOutlineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new CoplanarPolygonOutlineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: CoplanarPolygonOutlineGeometry): CoplanarPolygonOutlineGeometry;
  /**
   * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.
   * @param polygonGeometry - A description of the polygon.
   * @returns The computed vertices and indices.
   */
  createGeometry(polygonGeometry: CoplanarPolygonOutlineGeometry): Geometry | undefined;
}

/**
* Style options for corners.
*/
export enum CornerType {
  /**
   * <img src="Images/CornerTypeRounded.png" style="vertical-align: middle;" width="186" height="189" />
   *
   * Corner has a smooth edge.
   */
  ROUNDED = 0,
  /**
   * <img src="Images/CornerTypeMitered.png" style="vertical-align: middle;" width="186" height="189" />
   *
   * Corner point is the intersection of adjacent edges.
   */
  MITERED = 1,
  /**
   * <img src="Images/CornerTypeBeveled.png" style="vertical-align: middle;" width="186" height="189" />
   *
   * Corner is clipped.
   */
  BEVELED = 2
}

/**
* A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
* @example
* const corridor = new SuperMap.CorridorGeometry({
*   vertexFormat : SuperMap.VertexFormat.POSITION_ONLY,
*   positions : SuperMap.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),
*   width : 100000
* });
* @param options - Object with the following properties:
* @param options.positions - An array of positions that define the center of the corridor.
* @param options.width - The distance between the edges of the corridor in meters.
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
* @param [options.height = 0] - The distance in meters between the ellipsoid surface and the positions.
* @param [options.extrudedHeight] - The distance in meters between the ellipsoid surface and the extruded face.
* @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
* @param [options.cornerType = CornerType.ROUNDED] - Determines the style of the corners.
*/
export class CorridorGeometry {
  constructor(options: {
    positions: Cartesian3[];
    width: number;
    ellipsoid?: Ellipsoid;
    granularity?: number;
    height?: number;
    extrudedHeight?: number;
    vertexFormat?: VertexFormat;
    cornerType?: CornerType;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: CorridorGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new CorridorGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: CorridorGeometry): CorridorGeometry;
  /**
   * Computes the bounding rectangle given the provided options
   * @param options - Object with the following properties:
   * @param options.positions - An array of positions that define the center of the corridor.
   * @param options.width - The distance between the edges of the corridor in meters.
   * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
   * @param [options.cornerType = CornerType.ROUNDED] - Determines the style of the corners.
   * @param [result] - An object in which to store the result.
   * @returns The result rectangle.
   */
  computeRectangle(options: {
    positions: Cartesian3[];
    width: number;
    ellipsoid?: Ellipsoid;
    cornerType?: CornerType;
  }, result?: Rectangle): Rectangle;
  /**
   * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.
   * @param corridorGeometry - A description of the corridor.
   * @returns The computed vertices and indices.
   */
  createGeometry(corridorGeometry: CorridorGeometry): Geometry | undefined;
}

/**
* A description of a corridor outline.
* @example
* const corridor = new SuperMap.CorridorOutlineGeometry({
*   positions : SuperMap.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),
*   width : 100000
* });
* @param options - Object with the following properties:
* @param options.positions - An array of positions that define the center of the corridor outline.
* @param options.width - The distance between the edges of the corridor outline.
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
* @param [options.height = 0] - The distance in meters between the positions and the ellipsoid surface.
* @param [options.extrudedHeight] - The distance in meters between the extruded face and the ellipsoid surface.
* @param [options.cornerType = CornerType.ROUNDED] - Determines the style of the corners.
*/
export class CorridorOutlineGeometry {
  constructor(options: {
    positions: Cartesian3[];
    width: number;
    ellipsoid?: Ellipsoid;
    granularity?: number;
    height?: number;
    extrudedHeight?: number;
    cornerType?: CornerType;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: CorridorOutlineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: CorridorOutlineGeometry): CorridorOutlineGeometry;
  /**
   * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.
   * @param corridorOutlineGeometry - A description of the corridor.
   * @returns The computed vertices and indices.
   */
  createGeometry(corridorOutlineGeometry: CorridorOutlineGeometry): Geometry | undefined;
}

/**
* A credit contains data pertaining to how to display attributions/credits for certain content on the screen.
* @example
* //Create a credit with a tooltip, image and link
* @param html - An string representing an html code snippet
* @param [showOnScreen = false] - If true, the credit will be visible in the main credit container.  Otherwise, it will appear in a popover
*/
export class Credit {
  constructor(html: string, showOnScreen?: boolean);
  /**
   * The credit content
   */
  readonly html: string;
  /**
   * Whether the credit should be displayed on screen or in a lightbox
   */
  showOnScreen: boolean;
  /**
   * Gets the credit element
   */
  readonly element: HTMLElement;
  /**
   * Returns true if the credits are equal
   * @param left - The first credit
   * @param right - The second credit
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left: Credit, right: Credit): boolean;
  /**
   * Returns true if the credits are equal
   * @param credit - The credit to compare to.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(credit: Credit): boolean;
  /**
   * Duplicates a Credit instance.
   * @param [credit] - The Credit to duplicate.
   * @returns A new Credit instance that is a duplicate of the one provided. (Returns undefined if the credit is undefined)
   */
  clone(credit?: Credit): Credit;
}

/**
* Defines functions for 3rd order polynomial functions of one variable with only real coefficients.
*/
export namespace CubicRealPolynomial {
  /**
   * Provides the discriminant of the cubic equation from the supplied coefficients.
   * @param a - The coefficient of the 3rd order monomial.
   * @param b - The coefficient of the 2nd order monomial.
   * @param c - The coefficient of the 1st order monomial.
   * @param d - The coefficient of the 0th order monomial.
   * @returns The value of the discriminant.
   */
  function computeDiscriminant(a: number, b: number, c: number, d: number): number;
  /**
   * Provides the real valued roots of the cubic polynomial with the provided coefficients.
   * @param a - The coefficient of the 3rd order monomial.
   * @param b - The coefficient of the 2nd order monomial.
   * @param c - The coefficient of the 1st order monomial.
   * @param d - The coefficient of the 0th order monomial.
   * @returns The real valued roots.
   */
  function computeRealRoots(a: number, b: number, c: number, d: number): number[];
}

/**
* The culling volume defined by planes.
* @param [planes] - An array of clipping planes.
*/
export class CullingVolume {
  constructor(planes?: Cartesian4[]);
  /**
   * Each plane is represented by a Cartesian4 object, where the x, y, and z components
   * define the unit vector normal to the plane, and the w component is the distance of the
   * plane from the origin.
   */
  planes: Cartesian4[];
  /**
   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
   * The planes are aligned to the x, y, and z axes in world coordinates.
   * @param boundingSphere - The bounding sphere used to create the culling volume.
   * @param [result] - The object onto which to store the result.
   * @returns The culling volume created from the bounding sphere.
   */
  fromBoundingSphere(boundingSphere: BoundingSphere, result?: CullingVolume): CullingVolume;
  /**
   * Determines whether a bounding volume intersects the culling volume.
   * @param boundingVolume - The bounding volume whose intersection with the culling volume is to be tested.
   * @returns Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.
   */
  computeVisibility(boundingVolume: any): Intersect;
}

/**
 * A description of a cylinder.
 * @example
 * // create cylinder geometry
 * const cylinder = new SuperMap.CylinderGeometry({
 *     length: 200000,
 *     topRadius: 80000,
 *     bottomRadius: 200000,
 * });
 * const geometry = SuperMap.CylinderGeometry.createGeometry(cylinder);
 * @param options - Object with the following properties:
 * @param options.length - The length of the cylinder.
 * @param options.topRadius - The radius of the top of the cylinder.
 * @param options.bottomRadius - The radius of the bottom of the cylinder.
 * @param [options.slices = 128] - The number of edges around the perimeter of the cylinder.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 */
export class CylinderGeometry {
  constructor(options: {
    length: number;
    topRadius: number;
    bottomRadius: number;
    slices?: number;
    vertexFormat?: VertexFormat;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: CylinderGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new CylinderGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: CylinderGeometry): CylinderGeometry;
  /**
   * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.
   * @param cylinderGeometry - A description of the cylinder.
   * @returns The computed vertices and indices.
   */
  createGeometry(cylinderGeometry: CylinderGeometry): Geometry | undefined;
}

/**
* A description of the outline of a cylinder.
* @example
* // create cylinder geometry
* const cylinder = new SuperMap.CylinderOutlineGeometry({
*     length: 200000,
*     topRadius: 80000,
*     bottomRadius: 200000,
* });
* const geometry = SuperMap.CylinderOutlineGeometry.createGeometry(cylinder);
* @param options - Object with the following properties:
* @param options.length - The length of the cylinder.
* @param options.topRadius - The radius of the top of the cylinder.
* @param options.bottomRadius - The radius of the bottom of the cylinder.
* @param [options.slices = 128] - The number of edges around the perimeter of the cylinder.
* @param [options.numberOfVerticalLines = 16] - Number of lines to draw between the top and bottom surfaces of the cylinder.
*/
export class CylinderOutlineGeometry {
  constructor(options: {
    length: number;
    topRadius: number;
    bottomRadius: number;
    slices?: number;
    numberOfVerticalLines?: number;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: CylinderOutlineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: CylinderOutlineGeometry): CylinderOutlineGeometry;
  /**
   * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.
   * @param cylinderGeometry - A description of the cylinder outline.
   * @returns The computed vertices and indices.
   */
  createGeometry(cylinderGeometry: CylinderOutlineGeometry): Geometry | undefined;
}

/**
* A simple proxy that appends the desired resource as the sole query parameter
* to the given proxy URL.
* @param proxy - The proxy URL that will be used to requests all resources.
*/
export class DefaultProxy extends Proxy {
  constructor(proxy: string);
  /**
   * Get the final URL to use to request a given resource.
   * @param resource - The resource to request.
   * @returns proxied resource
   */
  getURL(resource: string): string;
}

/**
* Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,
* argument out of range, etc.  This exception should only be thrown during development;
* it usually indicates a bug in the calling code.  This exception should never be
* caught; instead the calling code should strive not to generate it.
* <br /><br />
* On the other hand, a {@link RuntimeError} indicates an exception that may
* be thrown at runtime, e.g., out of memory, that the calling code should be prepared
* to catch.
* @param [message] - The error message for this exception.
*/
export class DeveloperError extends Error {
  constructor(message?: string);
  /**
   * 'DeveloperError' indicating that this exception was thrown due to a developer error.
   */
  readonly name: string;
  /**
   * The explanation for why this exception was thrown.
   */
  readonly message: string;
  /**
   * The stack trace of this exception, if available.
   */
  readonly stack: string;
}

/**
* Determines visibility based on the distance to the camera.
* @example
* // Make a billboard that is only visible when the distance to the camera is between 10 and 20 meters.
* billboard.distanceDisplayCondition = new SuperMap.DistanceDisplayCondition(10.0, 20.0);
* @param [near = 0.0] - The smallest distance in the interval where the object is visible.
* @param [far = Number.MAX_VALUE] - The largest distance in the interval where the object is visible.
*/
export class DistanceDisplayCondition {
  constructor(near?: number, far?: number);
  /**
   * The smallest distance in the interval where the object is visible.
   */
  near: number;
  /**
   * The largest distance in the interval where the object is visible.
   */
  far: number;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: DistanceDisplayCondition, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new DistanceDisplayCondition instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: DistanceDisplayCondition): DistanceDisplayCondition;
  /**
   * Determines if two distance display conditions are equal.
   * @param left - A distance display condition.
   * @param right - Another distance display condition.
   * @returns Whether the two distance display conditions are equal.
   */
  equals(left: DistanceDisplayCondition, right: DistanceDisplayCondition): boolean;
  /**
   * Duplicates a distance display condition instance.
   * @param [value] - The distance display condition to duplicate.
   * @param [result] - The result onto which to store the result.
   * @returns The duplicated instance.
   */
  clone(value?: DistanceDisplayCondition, result?: DistanceDisplayCondition): DistanceDisplayCondition;
  /**
   * Duplicates this instance.
   * @param [result] - The result onto which to store the result.
   * @returns The duplicated instance.
   */
  clone(result?: DistanceDisplayCondition): DistanceDisplayCondition;
  /**
   * Determines if this distance display condition is equal to another.
   * @param other - Another distance display condition.
   * @returns Whether this distance display condition is equal to the other.
   */
  equals(other: DistanceDisplayCondition): boolean;
}

/**
* Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.
* @example
* const instance = new SuperMap.GeometryInstance({
*   geometry : new SuperMap.BoxGeometry({
*     vertexFormat : SuperMap.VertexFormat.POSITION_AND_NORMAL,
*     minimum : new SuperMap.Cartesian3(-250000.0, -250000.0, -250000.0),
*     maximum : new SuperMap.Cartesian3(250000.0, 250000.0, 250000.0)
*   }),
*   modelMatrix : SuperMap.Matrix4.multiplyByTranslation(SuperMap.Transforms.eastNorthUpToFixedFrame(
*     SuperMap.Cartesian3.fromDegrees(-75.59777, 40.03883)), new SuperMap.Cartesian3(0.0, 0.0, 1000000.0), new SuperMap.Matrix4()),
*   id : 'box',
*   attributes : {
*     distanceDisplayCondition : new SuperMap.DistanceDisplayConditionGeometryInstanceAttribute(100.0, 10000.0)
*   }
* });
* @param [near = 0.0] - The near distance.
* @param [far = Number.MAX_VALUE] - The far distance.
*/
export class DistanceDisplayConditionGeometryInstanceAttribute {
  constructor(near?: number, far?: number);
  /**
   * The values for the attributes stored in a typed array.
   */
  value: Float32Array;
  /**
   * The datatype of each component in the attribute, e.g., individual elements in
   * {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.
   */
  readonly componentDatatype: ComponentDatatype;
  /**
   * The number of components in the attributes, i.e., {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.
   */
  readonly componentsPerAttribute: number;
  /**
   * When <code>true</code> and <code>componentDatatype</code> is an integer format,
   * indicate that the components should be mapped to the range [0, 1] (unsigned)
   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
   */
  readonly normalize: boolean;
  /**
   * Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.
   * @example
   * const distanceDisplayCondition = new SuperMap.DistanceDisplayCondition(100.0, 10000.0);
   * const instance = new SuperMap.GeometryInstance({
   *   geometry : geometry,
   *   attributes : {
   *     distanceDisplayCondition : SuperMap.DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)
   *   }
   * });
   * @param distanceDisplayCondition - The distance display condition.
   * @returns The new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance.
   */
  fromDistanceDisplayCondition(distanceDisplayCondition: DistanceDisplayCondition): DistanceDisplayConditionGeometryInstanceAttribute;
  /**
   * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.
   * @example
   * const attributes = primitive.getGeometryInstanceAttributes('an id');
   * attributes.distanceDisplayCondition = SuperMap.DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);
   * @param distanceDisplayCondition - The distance display condition value.
   * @param [result] - The array to store the result in, if undefined a new instance will be created.
   * @returns The modified result parameter or a new instance if result was undefined.
   */
  toValue(distanceDisplayCondition: DistanceDisplayCondition, result?: Float32Array): Float32Array;
}

/**
* Easing functions for use with TweenCollection.  These function are from
*/
export namespace EasingFunction {
  /**
   * Linear easing.
   */
  const LINEAR_NONE: EasingFunction.Callback;
  /**
   * Quadratic in.
   */
  const QUADRATIC_IN: EasingFunction.Callback;
  /**
   * Quadratic out.
   */
  const QUADRATIC_OUT: EasingFunction.Callback;
  /**
   * Quadratic in then out.
   */
  const QUADRATIC_IN_OUT: EasingFunction.Callback;
  /**
   * Cubic in.
   */
  const CUBIC_IN: EasingFunction.Callback;
  /**
   * Cubic out.
   */
  const CUBIC_OUT: EasingFunction.Callback;
  /**
   * Cubic in then out.
   */
  const CUBIC_IN_OUT: EasingFunction.Callback;
  /**
   * Quartic in.
   */
  const QUARTIC_IN: EasingFunction.Callback;
  /**
   * Quartic out.
   */
  const QUARTIC_OUT: EasingFunction.Callback;
  /**
   * Quartic in then out.
   */
  const QUARTIC_IN_OUT: EasingFunction.Callback;
  /**
   * Quintic in.
   */
  const QUINTIC_IN: EasingFunction.Callback;
  /**
   * Quintic out.
   */
  const QUINTIC_OUT: EasingFunction.Callback;
  /**
   * Quintic in then out.
   */
  const QUINTIC_IN_OUT: EasingFunction.Callback;
  /**
   * Sinusoidal in.
   */
  const SINUSOIDAL_IN: EasingFunction.Callback;
  /**
   * Sinusoidal out.
   */
  const SINUSOIDAL_OUT: EasingFunction.Callback;
  /**
   * Sinusoidal in then out.
   */
  const SINUSOIDAL_IN_OUT: EasingFunction.Callback;
  /**
   * Exponential in.
   */
  const EXPONENTIAL_IN: EasingFunction.Callback;
  /**
   * Exponential out.
   */
  const EXPONENTIAL_OUT: EasingFunction.Callback;
  /**
   * Exponential in then out.
   */
  const EXPONENTIAL_IN_OUT: EasingFunction.Callback;
  /**
   * Circular in.
   */
  const CIRCULAR_IN: EasingFunction.Callback;
  /**
   * Circular out.
   */
  const CIRCULAR_OUT: EasingFunction.Callback;
  /**
   * Circular in then out.
   */
  const CIRCULAR_IN_OUT: EasingFunction.Callback;
  /**
   * Elastic in.
   */
  const ELASTIC_IN: EasingFunction.Callback;
  /**
   * Elastic out.
   */
  const ELASTIC_OUT: EasingFunction.Callback;
  /**
   * Elastic in then out.
   */
  const ELASTIC_IN_OUT: EasingFunction.Callback;
  /**
   * Back in.
   */
  const BACK_IN: EasingFunction.Callback;
  /**
   * Back out.
   */
  const BACK_OUT: EasingFunction.Callback;
  /**
   * Back in then out.
   */
  const BACK_IN_OUT: EasingFunction.Callback;
  /**
   * Bounce in.
   */
  const BOUNCE_IN: EasingFunction.Callback;
  /**
   * Bounce out.
   */
  const BOUNCE_OUT: EasingFunction.Callback;
  /**
   * Bounce in then out.
   */
  const BOUNCE_IN_OUT: EasingFunction.Callback;
  /**
   * Function interface for implementing a custom easing function.
   * @example
   * function quadraticIn(time) {
   *     return time * time;
   * }
   * @example
   * function quadraticOut(time) {
   *     return time * (2.0 - time);
   * }
   * @param time - The time in the range <code>[0, 1]</code>.
   */
  type Callback = (time: number) => number;
}

/**
* A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
* @example
* // Create an ellipse.
* const ellipse = new SuperMap.EllipseGeometry({
*   center : SuperMap.Cartesian3.fromDegrees(-75.59777, 40.03883),
*   semiMajorAxis : 500000.0,
*   semiMinorAxis : 300000.0,
*   rotation : SuperMap.Math.toRadians(60.0)
* });
* const geometry = SuperMap.EllipseGeometry.createGeometry(ellipse);
* @param options - Object with the following properties:
* @param options.center - The ellipse's center point in the fixed frame.
* @param options.semiMajorAxis - The length of the ellipse's semi-major axis in meters.
* @param options.semiMinorAxis - The length of the ellipse's semi-minor axis in meters.
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid the ellipse will be on.
* @param [options.height = 0.0] - The distance in meters between the ellipse and the ellipsoid surface.
* @param [options.extrudedHeight] - The distance in meters between the ellipse's extruded face and the ellipsoid surface.
* @param [options.rotation = 0.0] - The angle of rotation counter-clockwise from north.
* @param [options.stRotation = 0.0] - The rotation of the texture coordinates counter-clockwise from north.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The angular distance between points on the ellipse in radians.
* @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
*/
export class EllipseGeometry {
  constructor(options: {
    center: Cartesian3;
    semiMajorAxis: number;
    semiMinorAxis: number;
    ellipsoid?: Ellipsoid;
    height?: number;
    extrudedHeight?: number;
    rotation?: number;
    stRotation?: number;
    granularity?: number;
    vertexFormat?: VertexFormat;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: EllipseGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new EllipseGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: EllipseGeometry): EllipseGeometry;
  /**
   * Computes the bounding rectangle based on the provided options
   * @param options - Object with the following properties:
   * @param options.center - The ellipse's center point in the fixed frame.
   * @param options.semiMajorAxis - The length of the ellipse's semi-major axis in meters.
   * @param options.semiMinorAxis - The length of the ellipse's semi-minor axis in meters.
   * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid the ellipse will be on.
   * @param [options.rotation = 0.0] - The angle of rotation counter-clockwise from north.
   * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The angular distance between points on the ellipse in radians.
   * @param [result] - An object in which to store the result
   * @returns The result rectangle
   */
  computeRectangle(options: {
    center: Cartesian3;
    semiMajorAxis: number;
    semiMinorAxis: number;
    ellipsoid?: Ellipsoid;
    rotation?: number;
    granularity?: number;
  }, result?: Rectangle): Rectangle;
  /**
   * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.
   * @param ellipseGeometry - A description of the ellipse.
   * @returns The computed vertices and indices.
   */
  createGeometry(ellipseGeometry: EllipseGeometry): Geometry | undefined;
}

/**
* A description of the outline of an ellipse on an ellipsoid.
* @example
* const ellipse = new SuperMap.EllipseOutlineGeometry({
*   center : SuperMap.Cartesian3.fromDegrees(-75.59777, 40.03883),
*   semiMajorAxis : 500000.0,
*   semiMinorAxis : 300000.0,
*   rotation : SuperMap.Math.toRadians(60.0)
* });
* const geometry = SuperMap.EllipseOutlineGeometry.createGeometry(ellipse);
* @param options - Object with the following properties:
* @param options.center - The ellipse's center point in the fixed frame.
* @param options.semiMajorAxis - The length of the ellipse's semi-major axis in meters.
* @param options.semiMinorAxis - The length of the ellipse's semi-minor axis in meters.
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid the ellipse will be on.
* @param [options.height = 0.0] - The distance in meters between the ellipse and the ellipsoid surface.
* @param [options.extrudedHeight] - The distance in meters between the ellipse's extruded face and the ellipsoid surface.
* @param [options.rotation = 0.0] - The angle from north (counter-clockwise) in radians.
* @param [options.granularity = 0.02] - The angular distance between points on the ellipse in radians.
* @param [options.numberOfVerticalLines = 16] - Number of lines to draw between the top and bottom surface of an extruded ellipse.
*/
export class EllipseOutlineGeometry {
  constructor(options: {
    center: Cartesian3;
    semiMajorAxis: number;
    semiMinorAxis: number;
    ellipsoid?: Ellipsoid;
    height?: number;
    extrudedHeight?: number;
    rotation?: number;
    granularity?: number;
    numberOfVerticalLines?: number;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: EllipseOutlineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: EllipseOutlineGeometry): EllipseOutlineGeometry;
  /**
   * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.
   * @param ellipseGeometry - A description of the ellipse.
   * @returns The computed vertices and indices.
   */
  createGeometry(ellipseGeometry: EllipseOutlineGeometry): Geometry | undefined;
}

/**
* A quadratic surface defined in Cartesian coordinates by the equation
* <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used
* by SuperMap to represent the shape of planetary bodies.
*
* Rather than constructing this object directly, one of the provided
* constants is normally used.
* @param [x = 0] - The radius in the x direction.
* @param [y = 0] - The radius in the y direction.
* @param [z = 0] - The radius in the z direction.
*/
export class Ellipsoid {
  constructor(x?: number, y?: number, z?: number);
  /**
   * Gets the radii of the ellipsoid.
   */
  readonly radii: Cartesian3;
  /**
   * Gets the squared radii of the ellipsoid.
   */
  readonly radiiSquared: Cartesian3;
  /**
   * Gets the radii of the ellipsoid raise to the fourth power.
   */
  readonly radiiToTheFourth: Cartesian3;
  /**
   * Gets one over the radii of the ellipsoid.
   */
  readonly oneOverRadii: Cartesian3;
  /**
   * Gets one over the squared radii of the ellipsoid.
   */
  readonly oneOverRadiiSquared: Cartesian3;
  /**
   * Gets the minimum radius of the ellipsoid.
   */
  readonly minimumRadius: number;
  /**
   * Gets the maximum radius of the ellipsoid.
   */
  readonly maximumRadius: number;
  /**
   * Duplicates an Ellipsoid instance.
   * @param ellipsoid - The ellipsoid to duplicate.
   * @param [result] - The object onto which to store the result, or undefined if a new
   *                    instance should be created.
   * @returns The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)
   */
  clone(ellipsoid: Ellipsoid, result?: Ellipsoid): Ellipsoid;
  /**
   * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.
   * @param [cartesian = Cartesian3.ZERO] - The ellipsoid's radius in the x, y, and z directions.
   * @param [result] - The object onto which to store the result, or undefined if a new
   *                    instance should be created.
   * @returns A new Ellipsoid instance.
   */
  fromCartesian3(cartesian?: Cartesian3, result?: Ellipsoid): Ellipsoid;
  /**
   * An Ellipsoid instance initialized to the WGS84 standard.
   */
  readonly WGS84: Ellipsoid;
  /**
   * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).
   */
  readonly UNIT_SPHERE: Ellipsoid;
  /**
   * An Ellipsoid instance initialized to a sphere with the lunar radius.
   */
  readonly MOON: Ellipsoid;
  /**
   * Duplicates an Ellipsoid instance.
   * @param [result] - The object onto which to store the result, or undefined if a new
   *                    instance should be created.
   * @returns The cloned Ellipsoid.
   */
  clone(result?: Ellipsoid): Ellipsoid;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: Ellipsoid, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Ellipsoid instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: Ellipsoid): Ellipsoid;
  /**
   * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.
   * @param cartesian - The Cartesian for which to to determine the geocentric normal.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian3 instance if none was provided.
   */
  geocentricSurfaceNormal(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
  /**
   * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
   * @param cartographic - The cartographic position for which to to determine the geodetic normal.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian3 instance if none was provided.
   */
  geodeticSurfaceNormalCartographic(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
  /**
   * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
   * @param cartesian - The Cartesian position for which to to determine the surface normal.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.
   */
  geodeticSurfaceNormal(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
  /**
   * Converts the provided cartographic to Cartesian representation.
   * @example
   * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.
   * const position = new SuperMap.Cartographic(SuperMap.Math.toRadians(21), SuperMap.Math.toRadians(78), 5000);
   * const cartesianPosition = SuperMap.Ellipsoid.WGS84.cartographicToCartesian(position);
   * @param cartographic - The cartographic position.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian3 instance if none was provided.
   */
  cartographicToCartesian(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
  /**
   * Converts the provided array of cartographics to an array of Cartesians.
   * @example
   * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.
   * const positions = [new SuperMap.Cartographic(SuperMap.Math.toRadians(21), SuperMap.Math.toRadians(78), 0),
   *                  new SuperMap.Cartographic(SuperMap.Math.toRadians(21.321), SuperMap.Math.toRadians(78.123), 100),
   *                  new SuperMap.Cartographic(SuperMap.Math.toRadians(21.645), SuperMap.Math.toRadians(78.456), 250)];
   * const cartesianPositions = SuperMap.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);
   * @param cartographics - An array of cartographic positions.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Array instance if none was provided.
   */
  cartographicArrayToCartesianArray(cartographics: Cartographic[], result?: Cartesian3[]): Cartesian3[];
  /**
   * Converts the provided cartesian to cartographic representation.
   * The cartesian is undefined at the center of the ellipsoid.
   * @example
   * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.
   * const position = new SuperMap.Cartesian3(17832.12, 83234.52, 952313.73);
   * const cartographicPosition = SuperMap.Ellipsoid.WGS84.cartesianToCartographic(position);
   * @param cartesian - The Cartesian position to convert to cartographic representation.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.
   */
  cartesianToCartographic(cartesian: Cartesian3, result?: Cartographic): Cartographic;
  /**
   * Converts the provided array of cartesians to an array of cartographics.
   * @example
   * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.
   * const positions = [new SuperMap.Cartesian3(17832.12, 83234.52, 952313.73),
   *                  new SuperMap.Cartesian3(17832.13, 83234.53, 952313.73),
   *                  new SuperMap.Cartesian3(17832.14, 83234.54, 952313.73)]
   * const cartographicPositions = SuperMap.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);
   * @param cartesians - An array of Cartesian positions.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Array instance if none was provided.
   */
  cartesianArrayToCartographicArray(cartesians: Cartesian3[], result?: Cartographic[]): Cartographic[];
  /**
   * Scales the provided Cartesian position along the geodetic surface normal
   * so that it is on the surface of this ellipsoid.  If the position is
   * at the center of the ellipsoid, this function returns undefined.
   * @param cartesian - The Cartesian position to scale.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.
   */
  scaleToGeodeticSurface(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
  /**
   * Scales the provided Cartesian position along the geocentric surface normal
   * so that it is on the surface of this ellipsoid.
   * @param cartesian - The Cartesian position to scale.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian3 instance if none was provided.
   */
  scaleToGeocentricSurface(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
  /**
   * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
   * its components by the result of {@link Ellipsoid#oneOverRadii}.
   * @param position - The position to transform.
   * @param [result] - The position to which to copy the result, or undefined to create and
   *        return a new instance.
   * @returns The position expressed in the scaled space.  The returned instance is the
   *          one passed as the result parameter if it is not undefined, or a new instance of it is.
   */
  transformPositionToScaledSpace(position: Cartesian3, result?: Cartesian3): Cartesian3;
  /**
   * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
   * its components by the result of {@link Ellipsoid#radii}.
   * @param position - The position to transform.
   * @param [result] - The position to which to copy the result, or undefined to create and
   *        return a new instance.
   * @returns The position expressed in the unscaled space.  The returned instance is the
   *          one passed as the result parameter if it is not undefined, or a new instance of it is.
   */
  transformPositionFromScaledSpace(position: Cartesian3, result?: Cartesian3): Cartesian3;
  /**
   * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The other Ellipsoid.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(right?: Ellipsoid): boolean;
  /**
   * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.
   * @returns A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.
   */
  toString(): string;
  /**
   * Computes a point which is the intersection of the surface normal with the z-axis.
   * @param position - the position. must be on the surface of the ellipsoid.
   * @param [buffer = 0.0] - A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.
   *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.
   *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).
   *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2
   * @param [result] - The cartesian to which to copy the result, or undefined to create and
   *        return a new instance.
   * @returns the intersection point if it's inside the ellipsoid, undefined otherwise
   */
  getSurfaceNormalIntersectionWithZAxis(position: Cartesian3, buffer?: number, result?: Cartesian3): Cartesian3 | undefined;
  /**
   * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using
   * Gauss-Legendre 10th order quadrature.
   * @param rectangle - The rectangle used for computing the surface area.
   * @returns The approximate area of the rectangle on the surface of this ellipsoid.
   */
  surfaceArea(rectangle: Rectangle): number;
}

/**
* Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.
* @param [start] - The initial planetodetic point on the path.
* @param [end] - The final planetodetic point on the path.
* @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the geodesic lies.
*/
export class EllipsoidGeodesic {
  constructor(start?: Cartographic, end?: Cartographic, ellipsoid?: Ellipsoid);
  /**
   * Gets the ellipsoid.
   */
  readonly ellipsoid: Ellipsoid;
  /**
   * Gets the surface distance between the start and end point
   */
  readonly surfaceDistance: number;
  /**
   * Gets the initial planetodetic point on the path.
   */
  readonly start: Cartographic;
  /**
   * Gets the final planetodetic point on the path.
   */
  readonly end: Cartographic;
  /**
   * Gets the heading at the initial point.
   */
  readonly startHeading: number;
  /**
   * Gets the heading at the final point.
   */
  readonly endHeading: number;
  /**
   * Sets the start and end points of the geodesic
   * @param start - The initial planetodetic point on the path.
   * @param end - The final planetodetic point on the path.
   */
  setEndPoints(start: Cartographic, end: Cartographic): void;
  /**
   * Provides the location of a point at the indicated portion along the geodesic.
   * @param fraction - The portion of the distance between the initial and final points.
   * @param [result] - The object in which to store the result.
   * @returns The location of the point along the geodesic.
   */
  interpolateUsingFraction(fraction: number, result?: Cartographic): Cartographic;
  /**
   * Provides the location of a point at the indicated distance along the geodesic.
   * @param distance - The distance from the inital point to the point of interest along the geodesic
   * @param [result] - The object in which to store the result.
   * @returns The location of the point along the geodesic.
   */
  interpolateUsingSurfaceDistance(distance: number, result?: Cartographic): Cartographic;
}

/**
* A description of an ellipsoid centered at the origin.
* @example
* const ellipsoid = new SuperMap.EllipsoidGeometry({
*   vertexFormat : SuperMap.VertexFormat.POSITION_ONLY,
*   radii : new SuperMap.Cartesian3(1000000.0, 500000.0, 500000.0)
* });
* const geometry = SuperMap.EllipsoidGeometry.createGeometry(ellipsoid);
* @param [options] - Object with the following properties:
* @param [options.radii = Cartesian3(1.0, 1.0, 1.0)] - The radii of the ellipsoid in the x, y, and z directions.
* @param [options.innerRadii = options.radii] - The inner radii of the ellipsoid in the x, y, and z directions.
* @param [options.minimumClock = 0.0] - The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
* @param [options.maximumClock = 2*PI] - The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
* @param [options.minimumCone = 0.0] - The minimum angle measured from the positive z-axis and toward the negative z-axis.
* @param [options.maximumCone = PI] - The maximum angle measured from the positive z-axis and toward the negative z-axis.
* @param [options.stackPartitions = 64] - The number of times to partition the ellipsoid into stacks.
* @param [options.slicePartitions = 64] - The number of times to partition the ellipsoid into radial slices.
* @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
*/
export class EllipsoidGeometry {
  constructor(options?: {
    radii?: Cartesian3;
    innerRadii?: Cartesian3;
    minimumClock?: number;
    maximumClock?: number;
    minimumCone?: number;
    maximumCone?: number;
    stackPartitions?: number;
    slicePartitions?: number;
    vertexFormat?: VertexFormat;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: EllipsoidGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new EllipsoidGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: EllipsoidGeometry): EllipsoidGeometry;
  /**
   * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.
   * @param ellipsoidGeometry - A description of the ellipsoid.
   * @returns The computed vertices and indices.
   */
  createGeometry(ellipsoidGeometry: EllipsoidGeometry): Geometry | undefined;
}

/**
* A description of the outline of an ellipsoid centered at the origin.
* @example
* const ellipsoid = new SuperMap.EllipsoidOutlineGeometry({
*   radii : new SuperMap.Cartesian3(1000000.0, 500000.0, 500000.0),
*   stackPartitions: 6,
*   slicePartitions: 5
* });
* const geometry = SuperMap.EllipsoidOutlineGeometry.createGeometry(ellipsoid);
* @param [options] - Object with the following properties:
* @param [options.radii = Cartesian3(1.0, 1.0, 1.0)] - The radii of the ellipsoid in the x, y, and z directions.
* @param [options.innerRadii = options.radii] - The inner radii of the ellipsoid in the x, y, and z directions.
* @param [options.minimumClock = 0.0] - The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
* @param [options.maximumClock = 2*PI] - The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
* @param [options.minimumCone = 0.0] - The minimum angle measured from the positive z-axis and toward the negative z-axis.
* @param [options.maximumCone = PI] - The maximum angle measured from the positive z-axis and toward the negative z-axis.
* @param [options.stackPartitions = 10] - The count of stacks for the ellipsoid (1 greater than the number of parallel lines).
* @param [options.slicePartitions = 8] - The count of slices for the ellipsoid (Equal to the number of radial lines).
* @param [options.subdivisions = 128] - The number of points per line, determining the granularity of the curvature.
*/
export class EllipsoidOutlineGeometry {
  constructor(options?: {
    radii?: Cartesian3;
    innerRadii?: Cartesian3;
    minimumClock?: number;
    maximumClock?: number;
    minimumCone?: number;
    maximumCone?: number;
    stackPartitions?: number;
    slicePartitions?: number;
    subdivisions?: number;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: EllipsoidOutlineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new EllipsoidOutlineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: EllipsoidOutlineGeometry): EllipsoidOutlineGeometry;
  /**
   * Computes the geometric representation of an outline of an ellipsoid, including its vertices, indices, and a bounding sphere.
   * @param ellipsoidGeometry - A description of the ellipsoid outline.
   * @returns The computed vertices and indices.
   */
  createGeometry(ellipsoidGeometry: EllipsoidOutlineGeometry): Geometry | undefined;
}

/**
 * Initializes a rhumb line on the ellipsoid connecting the two provided planetodetic points.
 * @param [start] - The initial planetodetic point on the path.
 * @param [end] - The final planetodetic point on the path.
 * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the rhumb line lies.
 */
export class EllipsoidRhumbLine {
  constructor(start?: Cartographic, end?: Cartographic, ellipsoid?: Ellipsoid);
  /**
   * Gets the ellipsoid.
   */
  readonly ellipsoid: Ellipsoid;
  /**
   * Gets the surface distance between the start and end point
   */
  readonly surfaceDistance: number;
  /**
   * Gets the initial planetodetic point on the path.
   */
  readonly start: Cartographic;
  /**
   * Gets the final planetodetic point on the path.
   */
  readonly end: Cartographic;
  /**
   * Gets the heading from the start point to the end point.
   */
  readonly heading: number;
  /**
   * Create a rhumb line using an initial position with a heading and distance.
   * @param start - The initial planetodetic point on the path.
   * @param heading - The heading in radians.
   * @param distance - The rhumb line distance between the start and end point.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the rhumb line lies.
   * @param [result] - The object in which to store the result.
   * @returns The EllipsoidRhumbLine object.
   */
  fromStartHeadingDistance(start: Cartographic, heading: number, distance: number, ellipsoid?: Ellipsoid, result?: EllipsoidRhumbLine): EllipsoidRhumbLine;
  /**
   * Sets the start and end points of the rhumb line.
   * @param start - The initial planetodetic point on the path.
   * @param end - The final planetodetic point on the path.
   */
  setEndPoints(start: Cartographic, end: Cartographic): void;
  /**
   * Provides the location of a point at the indicated portion along the rhumb line.
   * @param fraction - The portion of the distance between the initial and final points.
   * @param [result] - The object in which to store the result.
   * @returns The location of the point along the rhumb line.
   */
  interpolateUsingFraction(fraction: number, result?: Cartographic): Cartographic;
  /**
   * Provides the location of a point at the indicated distance along the rhumb line.
   * @param distance - The distance from the inital point to the point of interest along the rhumbLine.
   * @param [result] - The object in which to store the result.
   * @returns The location of the point along the rhumb line.
   */
  interpolateUsingSurfaceDistance(distance: number, result?: Cartographic): Cartographic;
  /**
   * Provides the location of a point at the indicated longitude along the rhumb line.
   * If the longitude is outside the range of start and end points, the first intersection with the longitude from the start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.
   * @param intersectionLongitude - The longitude, in radians, at which to find the intersection point from the starting point using the heading.
   * @param [result] - The object in which to store the result.
   * @returns The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.
   */
  findIntersectionWithLongitude(intersectionLongitude: number, result?: Cartographic): Cartographic;
  /**
   * Provides the location of a point at the indicated latitude along the rhumb line.
   * If the latitude is outside the range of start and end points, the first intersection with the latitude from that start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.
   * @param intersectionLatitude - The latitude, in radians, at which to find the intersection point from the starting point using the heading.
   * @param [result] - The object in which to store the result.
   * @returns The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.
   */
  findIntersectionWithLatitude(intersectionLatitude: number, result?: Cartographic): Cartographic;
}

/**
* A plane tangent to the provided ellipsoid at the provided origin.
* If origin is not on the surface of the ellipsoid, it's surface projection will be used.
* If origin is at the center of the ellipsoid, an exception will be thrown.
* @param origin - The point on the surface of the ellipsoid where the tangent plane touches.
* @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid to use.
*/
export class EllipsoidTangentPlane {
  constructor(origin: Cartesian3, ellipsoid?: Ellipsoid);
  /**
   * Gets the ellipsoid.
   */
  ellipsoid: Ellipsoid;
  /**
   * Gets the origin.
   */
  origin: Cartesian3;
  /**
   * Gets the plane which is tangent to the ellipsoid.
   */
  readonly plane: Plane;
  /**
   * Gets the local X-axis (east) of the tangent plane.
   */
  readonly xAxis: Cartesian3;
  /**
   * Gets the local Y-axis (north) of the tangent plane.
   */
  readonly yAxis: Cartesian3;
  /**
   * Gets the local Z-axis (up) of the tangent plane.
   */
  readonly zAxis: Cartesian3;
  /**
   * Creates a new instance from the provided ellipsoid and the center
   * point of the provided Cartesians.
   * @param cartesians - The list of positions surrounding the center point.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid to use.
   * @returns The new instance of EllipsoidTangentPlane.
   */
  fromPoints(cartesians: Cartesian3[], ellipsoid?: Ellipsoid): EllipsoidTangentPlane;
  /**
   * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.
   * @param cartesian - The point to project.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point
   */
  projectPointOntoPlane(cartesian: Cartesian3, result?: Cartesian2): Cartesian2;
  /**
   * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.
   * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.
   * @param cartesians - The array of points to project.
   * @param [result] - The array of Cartesian2 instances onto which to store results.
   * @returns The modified result parameter or a new array of Cartesian2 instances if none was provided.
   */
  projectPointsOntoPlane(cartesians: Cartesian3[], result?: Cartesian2[]): Cartesian2[];
  /**
   * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.
   * @param cartesian - The point to project.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian2 instance if none was provided.
   */
  projectPointToNearestOnPlane(cartesian: Cartesian3, result?: Cartesian2): Cartesian2;
  /**
   * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.
   * @param cartesians - The array of points to project.
   * @param [result] - The array of Cartesian2 instances onto which to store results.
   * @returns The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.
   */
  projectPointsToNearestOnPlane(cartesians: Cartesian3[], result?: Cartesian2[]): Cartesian2[];
  /**
   * Computes the projection of the provided 2D position onto the 3D ellipsoid.
   * @param cartesian - The points to project.
   * @param [result] - The Cartesian3 instance to store result.
   * @returns The modified result parameter or a new Cartesian3 instance if none was provided.
   */
  projectPointOntoEllipsoid(cartesian: Cartesian2, result?: Cartesian3): Cartesian3;
  /**
   * Computes the projection of the provided 2D positions onto the 3D ellipsoid.
   * @param cartesians - The array of points to project.
   * @param [result] - The array of Cartesian3 instances onto which to store results.
   * @returns The modified result parameter or a new array of Cartesian3 instances if none was provided.
   */
  projectPointsOntoEllipsoid(cartesians: Cartesian2[], result?: Cartesian3[]): Cartesian3[];
}

/**
* A very simple {@link TerrainProvider} that produces geometry by tessellating an ellipsoidal
* surface.
* @param [options] - Object with the following properties:
* @param [options.tilingScheme] - The tiling scheme specifying how the ellipsoidal
* surface is broken into tiles.  If this parameter is not provided, a {@link GeographicTilingScheme}
* is used.
* @param [options.ellipsoid] - The ellipsoid.  If the tilingScheme is specified,
* this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
* parameter is specified, the WGS84 ellipsoid is used.
*/
export class EllipsoidTerrainProvider {
  constructor(options?: {
    tilingScheme?: TilingScheme;
    ellipsoid?: Ellipsoid;
  });
  /**
   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
   * are passed an instance of {@link TileProviderError}.
   */
  readonly errorEvent: Event;
  /**
   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
   * the source of the terrain.  This function should not be called before {@link EllipsoidTerrainProvider#ready} returns true.
   */
  readonly credit: Credit;
  /**
   * Gets the tiling scheme used by this provider.  This function should
   * not be called before {@link EllipsoidTerrainProvider#ready} returns true.
   */
  readonly tilingScheme: GeographicTilingScheme;
  /**
   * Gets a value indicating whether or not the provider is ready for use.
   */
  readonly ready: boolean;
  /**
   * Gets a promise that resolves to true when the provider is ready for use.
   */
  readonly readyPromise: Promise<boolean>;
  /**
   * Gets a value indicating whether or not the provider includes a water mask.  The water mask
   * indicates which areas of the globe are water rather than land, so they can be rendered
   * as a reflective surface with animated waves.  This function should not be
   * called before {@link EllipsoidTerrainProvider#ready} returns true.
   */
  readonly hasWaterMask: boolean;
  /**
   * Gets a value indicating whether or not the requested tiles include vertex normals.
   * This function should not be called before {@link EllipsoidTerrainProvider#ready} returns true.
   */
  readonly hasVertexNormals: boolean;
  /**
   * Gets an object that can be used to determine availability of terrain from this provider, such as
   * at points and in rectangles.  This function should not be called before
   * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability
   * information is not available.
   */
  readonly availability: TileAvailability;
  /**
   * Requests the geometry for a given tile.  This function should not be called before
   * {@link TerrainProvider#ready} returns true.  The result includes terrain
   * data and indicates that all child tiles are available.
   * @param x - The X coordinate of the tile for which to request geometry.
   * @param y - The Y coordinate of the tile for which to request geometry.
   * @param level - The level of the tile for which to request geometry.
   * @param [request] - The request object. Intended for internal use only.
   * @returns A promise for the requested geometry.  If this method
   *          returns undefined instead of a promise, it is an indication that too many requests are already
   *          pending and the request will be retried later.
   */
  requestTileGeometry(x: number, y: number, level: number, request?: Request): Promise<TerrainData> | undefined;
  /**
   * Gets the maximum geometric error allowed in a tile at a given level.
   * @param level - The tile level for which to get the maximum geometric error.
   * @returns The maximum geometric error.
   */
  getLevelMaximumGeometricError(level: number): number;
  /**
   * Determines whether data for a tile is available to be loaded.
   * @param x - The X coordinate of the tile for which to request geometry.
   * @param y - The Y coordinate of the tile for which to request geometry.
   * @param level - The level of the tile for which to request geometry.
   * @returns Undefined if not supported, otherwise true or false.
   */
  getTileDataAvailable(x: number, y: number, level: number): boolean | undefined;
  /**
   * Makes sure we load availability data for a tile
   * @param x - The X coordinate of the tile for which to request geometry.
   * @param y - The Y coordinate of the tile for which to request geometry.
   * @param level - The level of the tile for which to request geometry.
   * @returns This provider does not support loading availability.
   */
  loadTileDataAvailability(x: number, y: number, level: number): undefined;
}

/**
* A generic utility class for managing subscribers for a particular event.
* This class is usually instantiated inside of a container class and
* exposed as a property for others to subscribe to.
* @example
* MyObject.prototype.myListener = function(arg1, arg2) {
*     this.myArg1Copy = arg1;
*     this.myArg2Copy = arg2;
* }
*
* const myObjectInstance = new MyObject();
* const evt = new SuperMap.Event();
* evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);
* evt.raiseEvent('1', '2');
* evt.removeEventListener(MyObject.prototype.myListener);
*/
export class Event<Listener extends (...args: any[]) => void = (...args: any[]) => void> {
  constructor();
  /**
   * The number of listeners currently subscribed to the event.
   */
  readonly numberOfListeners: number;
  /**
   * Registers a callback function to be executed whenever the event is raised.
   * An optional scope can be provided to serve as the <code>this</code> pointer
   * in which the function will execute.
   * @param listener - The function to be executed when the event is raised.
   * @param [scope] - An optional object scope to serve as the <code>this</code>
   *        pointer in which the listener function will execute.
   * @returns A function that will remove this event listener when invoked.
   */
  addEventListener(listener: Listener, scope?: any): Event.RemoveCallback;
  /**
   * Unregisters a previously registered callback.
   * @param listener - The function to be unregistered.
   * @param [scope] - The scope that was originally passed to addEventListener.
   * @returns <code>true</code> if the listener was removed; <code>false</code> if the listener and scope are not registered with the event.
   */
  removeEventListener(listener: Listener, scope?: any): boolean;
  /**
   * Raises the event by calling each registered listener with all supplied arguments.
   * @param arguments - This method takes any number of parameters and passes them through to the listener functions.
   */
  raiseEvent(...arguments: Parameters<Listener>[]): void;
}

export namespace Event {
  /**
   * A function that removes a listener.
   */
  type RemoveCallback = () => void;
}

/**
* A convenience object that simplifies the common pattern of attaching event listeners
* to several events, then removing all those listeners at once later, for example, in
* a destroy method.
* @example
* const helper = new SuperMap.EventHelper();
*
* helper.add(someObject.event, listener1, this);
* helper.add(otherObject.event, listener2, this);
*
* // later...
* helper.removeAll();
*/
export class EventHelper {
  constructor();
  /**
   * Adds a listener to an event, and records the registration to be cleaned up later.
   * @param event - The event to attach to.
   * @param listener - The function to be executed when the event is raised.
   * @param [scope] - An optional object scope to serve as the <code>this</code>
   *        pointer in which the listener function will execute.
   * @returns A function that will remove this event listener when invoked.
   */
  add(event: Event, listener: (...params: any[]) => any, scope?: any): EventHelper.RemoveCallback;
  /**
   * Unregisters all previously added listeners.
   */
  removeAll(): void;
}

export namespace EventHelper {
  /**
   * A function that removes a listener.
   */
  type RemoveCallback = () => void;
}

/**
 * Constants to determine how an interpolated value is extrapolated
 * when querying outside the bounds of available data.
 */
export enum ExtrapolationType {
  /**
   * No extrapolation occurs.
   */
  NONE = 0,
  /**
   * The first or last value is used when outside the range of sample data.
   */
  HOLD = 1,
  /**
   * The value is extrapolated.
   */
  EXTRAPOLATE = 2
}

/**
* A set of functions to detect whether the current browser supports
* various features.
*/
export namespace FeatureDetection {
  /**
   * Detects whether the current browser supports Basis Universal textures and the web assembly modules needed to transcode them.
   * @returns true if the browser supports web assembly modules and the scene supports Basis Universal textures, false if not.
   */
  function supportsBasis(scene: Scene): boolean;
  /**
   * Detects whether the current browser supports the full screen standard.
   * @returns true if the browser supports the full screen standard, false if not.
   */
  function supportsFullscreen(): boolean;
  /**
   * Detects whether the current browser supports typed arrays.
   * @returns true if the browser supports typed arrays, false if not.
   */
  function supportsTypedArrays(): boolean;
  /**
   * Detects whether the current browser supports BigInt64Array typed arrays.
   * @returns true if the browser supports BigInt64Array typed arrays, false if not.
   */
  function supportsBigInt64Array(): boolean;
  /**
   * Detects whether the current browser supports BigUint64Array typed arrays.
   * @returns true if the browser supports BigUint64Array typed arrays, false if not.
   */
  function supportsBigUint64Array(): boolean;
  /**
   * Detects whether the current browser supports BigInt.
   * @returns true if the browser supports BigInt, false if not.
   */
  function supportsBigInt(): boolean;
  /**
   * Detects whether the current browser supports Web Workers.
   * @returns true if the browsers supports Web Workers, false if not.
   */
  function supportsWebWorkers(): boolean;
  /**
   * Detects whether the current browser supports Web Assembly.
   * @returns true if the browsers supports Web Assembly, false if not.
   */
  function supportsWebAssembly(): boolean;
}

/**
* Describes a frustum at the given the origin and orientation.
* @param options - Object with the following properties:
* @param options.frustum - The frustum.
* @param options.origin - The origin of the frustum.
* @param options.orientation - The orientation of the frustum.
* @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
*/
export class FrustumGeometry {
  constructor(options: {
    frustum: PerspectiveFrustum | OrthographicFrustum;
    origin: Cartesian3;
    orientation: Quaternion;
    vertexFormat?: VertexFormat;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: FrustumGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   */
  unpack(array: number[], startingIndex?: number, result?: FrustumGeometry): void;
  /**
   * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.
   * @param frustumGeometry - A description of the frustum.
   * @returns The computed vertices and indices.
   */
  createGeometry(frustumGeometry: FrustumGeometry): Geometry | undefined;
}

/**
* A description of the outline of a frustum with the given the origin and orientation.
* @param options - Object with the following properties:
* @param options.frustum - The frustum.
* @param options.origin - The origin of the frustum.
* @param options.orientation - The orientation of the frustum.
*/
export class FrustumOutlineGeometry {
  constructor(options: {
    frustum: PerspectiveFrustum | OrthographicFrustum;
    origin: Cartesian3;
    orientation: Quaternion;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: FrustumOutlineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   */
  unpack(array: number[], startingIndex?: number, result?: FrustumOutlineGeometry): void;
  /**
   * Computes the geometric representation of a frustum outline, including its vertices, indices, and a bounding sphere.
   * @param frustumGeometry - A description of the frustum.
   * @returns The computed vertices and indices.
   */
  createGeometry(frustumGeometry: FrustumOutlineGeometry): Geometry | undefined;
}

/**
* Browser-independent functions for working with the standard fullscreen API.
*/
export namespace Fullscreen {
  /**
   * The element that is currently fullscreen, if any.  To simply check if the
   * browser is in fullscreen mode or not, use {@link Fullscreen#fullscreen}.
   */
  const element: any;
  /**
   * The name of the event on the document that is fired when fullscreen is
   * entered or exited.  This event name is intended for use with addEventListener.
   * In your event handler, to determine if the browser is in fullscreen mode or not,
   * use {@link Fullscreen#fullscreen}.
   */
  const changeEventName: string;
  /**
   * The name of the event that is fired when a fullscreen error
   * occurs.  This event name is intended for use with addEventListener.
   */
  const errorEventName: string;
  /**
   * Determine whether the browser will allow an element to be made fullscreen, or not.
   * For example, by default, iframes cannot go fullscreen unless the containing page
   * adds an "allowfullscreen" attribute (or prefixed equivalent).
   */
  const enabled: boolean;
  /**
   * Determines if the browser is currently in fullscreen mode.
   */
  const fullscreen: boolean;
  /**
   * Detects whether the browser supports the standard fullscreen API.
   * @returns <code>true</code> if the browser supports the standard fullscreen API,
   * <code>false</code> otherwise.
   */
  function supportsFullscreen(): boolean;
  /**
   * Asynchronously requests the browser to enter fullscreen mode on the given element.
   * If fullscreen mode is not supported by the browser, does nothing.
   * @example
   * // Put the entire page into fullscreen.
   * SuperMap.Fullscreen.requestFullscreen(document.body)
   *
   * // Place only the SuperMap canvas into fullscreen.
   * SuperMap.Fullscreen.requestFullscreen(scene.canvas)
   * @param element - The HTML element which will be placed into fullscreen mode.
   * @param [vrDevice] - The HMDVRDevice device.
   */
  function requestFullscreen(element: any, vrDevice?: any): void;
  /**
   * Asynchronously exits fullscreen mode.  If the browser is not currently
   * in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.
   */
  function exitFullscreen(): void;
}

/**
* The type of geocoding to be performed by a {@link GeocoderService}.
*/
export enum GeocodeType {
  /**
   * Perform a search where the input is considered complete.
   */
  SEARCH = 0,
  /**
   * Perform an auto-complete using partial input, typically
   * reserved for providing possible results as a user is typing.
   */
  AUTOCOMPLETE = 1
}

export namespace GeocoderService {
  /**
   * @property displayName - The display name for a location
   * @property destination - The bounding box for a location
   */
  type Result = {
    displayName: string;
    destination: Rectangle | Cartesian3;
  };
}

/**
* Provides geocoding through an external service. This type describes an interface and
* is not intended to be used.
*/
export class GeocoderService {
  constructor();
  /**
   * @param query - The query to be sent to the geocoder service
   * @param [type = GeocodeType.SEARCH] - The type of geocode to perform.
   */
  geocode(query: string, type?: GeocodeType): Promise<GeocoderService.Result[]>;
}

/**
* A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying
* them by the {@link Ellipsoid#maximumRadius}.  This projection
* is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrée.  It
* is also known as EPSG:4326.
* @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid.
*/
export class GeographicProjection {
  constructor(ellipsoid?: Ellipsoid);
  /**
   * Gets the {@link Ellipsoid}.
   */
  readonly ellipsoid: Ellipsoid;
  /**
   * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.
   * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the
   * ellipsoid.  Z is the unmodified height.
   * @param cartographic - The coordinates to project.
   * @param [result] - An instance into which to copy the result.  If this parameter is
   *        undefined, a new instance is created and returned.
   * @returns The projected coordinates.  If the result parameter is not undefined, the
   *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
   *          created and returned.
   */
  project(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
  /**
   * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}
   * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,
   * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.
   * @param cartesian - The Cartesian position to unproject with height (z) in meters.
   * @param [result] - An instance into which to copy the result.  If this parameter is
   *        undefined, a new instance is created and returned.
   * @returns The unprojected coordinates.  If the result parameter is not undefined, the
   *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
   *          created and returned.
   */
  unproject(cartesian: Cartesian3, result?: Cartographic): Cartographic;
}

/**
* A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where
* longitude and latitude are directly mapped to X and Y.  This projection is commonly
* known as geographic, equirectangular, equidistant cylindrical, or plate carrée.
* @param [options] - Object with the following properties:
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose surface is being tiled. Defaults to
* the WGS84 ellipsoid.
* @param [options.rectangle = Rectangle.MAX_VALUE] - The rectangle, in radians, covered by the tiling scheme.
* @param [options.numberOfLevelZeroTilesX = 2] - The number of tiles in the X direction at level zero of
* the tile tree.
* @param [options.numberOfLevelZeroTilesY = 1] - The number of tiles in the Y direction at level zero of
* the tile tree.
*/
export class GeographicTilingScheme {
  constructor(options?: {
    ellipsoid?: Ellipsoid;
    rectangle?: Rectangle;
    numberOfLevelZeroTilesX?: number;
    numberOfLevelZeroTilesY?: number;
  });
  /**
   * Gets the ellipsoid that is tiled by this tiling scheme.
   */
  ellipsoid: Ellipsoid;
  /**
   * Gets the rectangle, in radians, covered by this tiling scheme.
   */
  rectangle: Rectangle;
  /**
   * Gets the map projection used by this tiling scheme.
   */
  projection: MapProjection;
  /**
   * Gets the total number of tiles in the X direction at a specified level-of-detail.
   * @param level - The level-of-detail.
   * @returns The number of tiles in the X direction at the given level.
   */
  getNumberOfXTilesAtLevel(level: number): number;
  /**
   * Gets the total number of tiles in the Y direction at a specified level-of-detail.
   * @param level - The level-of-detail.
   * @returns The number of tiles in the Y direction at the given level.
   */
  getNumberOfYTilesAtLevel(level: number): number;
  /**
   * Transforms a rectangle specified in geodetic radians to the native coordinate system
   * of this tiling scheme.
   * @param rectangle - The rectangle to transform.
   * @param [result] - The instance to which to copy the result, or undefined if a new instance
   *        should be created.
   * @returns The specified 'result', or a new object containing the native rectangle if 'result'
   *          is undefined.
   */
  rectangleToNativeRectangle(rectangle: Rectangle, result?: Rectangle): Rectangle;
  /**
   * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates
   * of the tiling scheme.
   * @param x - The integer x coordinate of the tile.
   * @param y - The integer y coordinate of the tile.
   * @param level - The tile level-of-detail.  Zero is the least detailed.
   * @param [result] - The instance to which to copy the result, or undefined if a new instance
   *        should be created.
   * @returns The specified 'result', or a new object containing the rectangle
   *          if 'result' is undefined.
   */
  tileXYToNativeRectangle(x: number, y: number, level: number, result?: any): Rectangle;
  /**
   * Converts tile x, y coordinates and level to a cartographic rectangle in radians.
   * @param x - The integer x coordinate of the tile.
   * @param y - The integer y coordinate of the tile.
   * @param level - The tile level-of-detail.  Zero is the least detailed.
   * @param [result] - The instance to which to copy the result, or undefined if a new instance
   *        should be created.
   * @returns The specified 'result', or a new object containing the rectangle
   *          if 'result' is undefined.
   */
  tileXYToRectangle(x: number, y: number, level: number, result?: any): Rectangle;
  /**
   * Calculates the tile x, y coordinates of the tile containing
   * a given cartographic position.
   * @param position - The position.
   * @param level - The tile level-of-detail.  Zero is the least detailed.
   * @param [result] - The instance to which to copy the result, or undefined if a new instance
   *        should be created.
   * @returns The specified 'result', or a new object containing the tile x, y coordinates
   *          if 'result' is undefined.
   */
  positionToTileXY(position: Cartographic, level: number, result?: Cartesian2): Cartesian2;
}

/**
* A geometry representation with attributes forming vertices and optional index data
* defining primitives.  Geometries and an {@link Appearance}, which describes the shading,
* can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can
* be created from many heterogeneous - in many cases - geometries for performance.
* <p>
* Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.
* </p>
* @example
* // Create geometry with a position attribute and indexed lines.
* const positions = new Float64Array([
*   0.0, 0.0, 0.0,
*   7500000.0, 0.0, 0.0,
*   0.0, 7500000.0, 0.0
* ]);
*
* const geometry = new SuperMap.Geometry({
*   attributes : {
*     position : new SuperMap.GeometryAttribute({
*       componentDatatype : SuperMap.ComponentDatatype.DOUBLE,
*       componentsPerAttribute : 3,
*       values : positions
*     })
*   },
*   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),
*   primitiveType : SuperMap.PrimitiveType.LINES,
*   boundingSphere : SuperMap.BoundingSphere.fromVertices(positions)
* });
* @param options - Object with the following properties:
* @param options.attributes - Attributes, which make up the geometry's vertices.
* @param [options.primitiveType = PrimitiveType.TRIANGLES] - The type of primitives in the geometry.
* @param [options.indices] - Optional index data that determines the primitives in the geometry.
* @param [options.boundingSphere] - An optional bounding sphere that fully enclosed the geometry.
*/
export class Geometry {
  constructor(options: {
    attributes: GeometryAttributes;
    primitiveType?: PrimitiveType;
    indices?: Uint16Array | Uint32Array;
    boundingSphere?: BoundingSphere;
  });
  /**
   * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a
   * {@link GeometryAttribute} containing the attribute's data.
   * <p>
   * Attributes are always stored non-interleaved in a Geometry.
   * </p>
   * <p>
   * There are reserved attribute names with well-known semantics.  The following attributes
   * are created by a Geometry (depending on the provided {@link VertexFormat}.
   * <ul>
   *    <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>
   *    <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>
   *    <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>
   *    <li><code>bitangent</code> - Bitangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#bitangent}.</li>
   *    <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>
   * </ul>
   * </p>
   * <p>
   * The following attribute names are generally not created by a Geometry, but are added
   * to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare
   * the geometry for rendering.
   * <ul>
   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
   *    <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
   *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
   *    <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
   *    <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>
   *    <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>
   * </ul>
   * </p>
   * @example
   * geometry.attributes.position = new SuperMap.GeometryAttribute({
   *   componentDatatype : SuperMap.ComponentDatatype.FLOAT,
   *   componentsPerAttribute : 3,
   *   values : new Float32Array(0)
   * });
   */
  attributes: GeometryAttributes;
  /**
   * Optional index data that - along with {@link Geometry#primitiveType} -
   * determines the primitives in the geometry.
   */
  indices: any[];
  /**
   * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},
   * but can varying based on the specific geometry.
   */
  primitiveType: PrimitiveType;
  /**
   * An optional bounding sphere that fully encloses the geometry.  This is
   * commonly used for culling.
   */
  boundingSphere: BoundingSphere;
  /**
   * Computes the number of vertices in a geometry.  The runtime is linear with
   * respect to the number of attributes in a vertex, not the number of vertices.
   * @example
   * const numVertices = SuperMap.Geometry.computeNumberOfVertices(geometry);
   * @param geometry - The geometry.
   * @returns The number of vertices in the geometry.
   */
  computeNumberOfVertices(geometry: Geometry): number;
}

/**
* Values and type information for geometry attributes.  A {@link Geometry}
* generally contains one or more attributes.  All attributes together form
* the geometry's vertices.
* @example
* const geometry = new SuperMap.Geometry({
*   attributes : {
*     position : new SuperMap.GeometryAttribute({
*       componentDatatype : SuperMap.ComponentDatatype.FLOAT,
*       componentsPerAttribute : 3,
*       values : new Float32Array([
*         0.0, 0.0, 0.0,
*         7500000.0, 0.0, 0.0,
*         0.0, 7500000.0, 0.0
*       ])
*     })
*   },
*   primitiveType : SuperMap.PrimitiveType.LINE_LOOP
* });
* @param [options] - Object with the following properties:
* @param [options.componentDatatype] - The datatype of each component in the attribute, e.g., individual elements in values.
* @param [options.componentsPerAttribute] - A number between 1 and 4 that defines the number of components in an attributes.
* @param [options.normalize = false] - When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.
* @param [options.values] - The values for the attributes stored in a typed array.
*/
export class GeometryAttribute {
  constructor(options?: {
    componentDatatype?: ComponentDatatype;
    componentsPerAttribute?: number;
    normalize?: boolean;
    values?: number[] | Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
  });
  /**
   * The datatype of each component in the attribute, e.g., individual elements in
   * {@link GeometryAttribute#values}.
   */
  componentDatatype: ComponentDatatype;
  /**
   * A number between 1 and 4 that defines the number of components in an attributes.
   * For example, a position attribute with x, y, and z components would have 3 as
   * shown in the code example.
   * @example
   * attribute.componentDatatype = SuperMap.ComponentDatatype.FLOAT;
   * attribute.componentsPerAttribute = 3;
   * attribute.values = new Float32Array([
   *   0.0, 0.0, 0.0,
   *   7500000.0, 0.0, 0.0,
   *   0.0, 7500000.0, 0.0
   * ]);
   */
  componentsPerAttribute: number;
  /**
   * When <code>true</code> and <code>componentDatatype</code> is an integer format,
   * indicate that the components should be mapped to the range [0, 1] (unsigned)
   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
   * <p>
   * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.
   * </p>
   * @example
   * attribute.componentDatatype = SuperMap.ComponentDatatype.UNSIGNED_BYTE;
   * attribute.componentsPerAttribute = 4;
   * attribute.normalize = true;
   * attribute.values = new Uint8Array([
   *   SuperMap.Color.floatToByte(color.red),
   *   SuperMap.Color.floatToByte(color.green),
   *   SuperMap.Color.floatToByte(color.blue),
   *   SuperMap.Color.floatToByte(color.alpha)
   * ]);
   */
  normalize: boolean;
  /**
   * The values for the attributes stored in a typed array.  In the code example,
   * every three elements in <code>values</code> defines one attributes since
   * <code>componentsPerAttribute</code> is 3.
   * @example
   * attribute.componentDatatype = SuperMap.ComponentDatatype.FLOAT;
   * attribute.componentsPerAttribute = 3;
   * attribute.values = new Float32Array([
   *   0.0, 0.0, 0.0,
   *   7500000.0, 0.0, 0.0,
   *   0.0, 7500000.0, 0.0
   * ]);
   */
  values: number[] | Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
}

/**
* Attributes, which make up a geometry's vertices.  Each property in this object corresponds to a
* {@link GeometryAttribute} containing the attribute's data.
* <p>
* Attributes are always stored non-interleaved in a Geometry.
* </p>
*/
export class GeometryAttributes {
  constructor();
  /**
   * The 3D position attribute.
   * <p>
   * 64-bit floating-point (for precision).  3 components per attribute.
   * </p>
   */
  position: GeometryAttribute;
  /**
   * The normal attribute (normalized), which is commonly used for lighting.
   * <p>
   * 32-bit floating-point.  3 components per attribute.
   * </p>
   */
  normal: GeometryAttribute;
  /**
   * The 2D texture coordinate attribute.
   * <p>
   * 32-bit floating-point.  2 components per attribute
   * </p>
   */
  st: GeometryAttribute;
  /**
   * The bitangent attribute (normalized), which is used for tangent-space effects like bump mapping.
   * <p>
   * 32-bit floating-point.  3 components per attribute.
   * </p>
   */
  bitangent: GeometryAttribute;
  /**
   * The tangent attribute (normalized), which is used for tangent-space effects like bump mapping.
   * <p>
   * 32-bit floating-point.  3 components per attribute.
   * </p>
   */
  tangent: GeometryAttribute;
  /**
   * The color attribute.
   * <p>
   * 8-bit unsigned integer. 4 components per attribute.
   * </p>
   */
  color: GeometryAttribute;
}
/**
 * Geometry instancing allows one {@link Geometry} object to be positions in several
 * different locations and colored uniquely.  For example, one {@link BoxGeometry} can
 * be instanced several times, each with a different <code>modelMatrix</code> to change
 * its position, rotation, and scale.
 * @example
 * // Create geometry for a box, and two instances that refer to it.
 * // One instance positions the box on the bottom and colored aqua.
 * // The other instance positions the box on the top and color white.
 * const geometry = SuperMap.BoxGeometry.fromDimensions({
 *   vertexFormat : SuperMap.VertexFormat.POSITION_AND_NORMAL,
 *   dimensions : new SuperMap.Cartesian3(1000000.0, 1000000.0, 500000.0)
 * });
 * const instanceBottom = new SuperMap.GeometryInstance({
 *   geometry : geometry,
 *   modelMatrix : SuperMap.Matrix4.multiplyByTranslation(SuperMap.Transforms.eastNorthUpToFixedFrame(
 *     SuperMap.Cartesian3.fromDegrees(-75.59777, 40.03883)), new SuperMap.Cartesian3(0.0, 0.0, 1000000.0), new SuperMap.Matrix4()),
 *   attributes : {
 *     color : SuperMap.ColorGeometryInstanceAttribute.fromColor(SuperMap.Color.AQUA)
 *   },
 *   id : 'bottom'
 * });
 * const instanceTop = new SuperMap.GeometryInstance({
 *   geometry : geometry,
 *   modelMatrix : SuperMap.Matrix4.multiplyByTranslation(SuperMap.Transforms.eastNorthUpToFixedFrame(
 *     SuperMap.Cartesian3.fromDegrees(-75.59777, 40.03883)), new SuperMap.Cartesian3(0.0, 0.0, 3000000.0), new SuperMap.Matrix4()),
 *   attributes : {
 *     color : SuperMap.ColorGeometryInstanceAttribute.fromColor(SuperMap.Color.AQUA)
 *   },
 *   id : 'top'
 * });
 * @param options - Object with the following properties:
 * @param options.geometry - The geometry to instance.
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The model matrix that transforms to transform the geometry from model to world coordinates.
 * @param [options.id] - A user-defined object to return when the instance is picked with {@link Scene#pick} or get/set per-instance attributes with {@link Primitive#getGeometryInstanceAttributes}.
 * @param [options.attributes] - Per-instance attributes like a show or color attribute shown in the example below.
 */
export class GeometryInstance {
  constructor(options: {
    geometry: Geometry | GeometryFactory;
    modelMatrix?: Matrix4;
    id?: any;
    attributes?: any;
  });
  /**
   * The geometry being instanced.
   */
  geometry: Geometry;
  /**
   * The 4x4 transformation matrix that transforms the geometry from model to world coordinates.
   * When this is the identity matrix, the geometry is drawn in world coordinates, i.e., Earth's WGS84 coordinates.
   * Local reference frames can be used by providing a different transformation matrix, like that returned
   * by {@link Transforms.eastNorthUpToFixedFrame}.
   */
  modelMatrix: Matrix4;
  /**
   * User-defined object returned when the instance is picked or used to get/set per-instance attributes.
   */
  id: any;
  /**
   * Per-instance attributes like {@link ColorGeometryInstanceAttribute} or {@link ShowGeometryInstanceAttribute}.
   * {@link Geometry} attributes varying per vertex; these attributes are constant for the entire instance.
   */
  attributes: any;
}

/**
* Values and type information for per-instance geometry attributes.
* @example
* const instance = new SuperMap.GeometryInstance({
*   geometry : SuperMap.BoxGeometry.fromDimensions({
*     dimensions : new SuperMap.Cartesian3(1000000.0, 1000000.0, 500000.0)
*   }),
*   modelMatrix : SuperMap.Matrix4.multiplyByTranslation(SuperMap.Transforms.eastNorthUpToFixedFrame(
*     SuperMap.Cartesian3.fromDegrees(0.0, 0.0)), new SuperMap.Cartesian3(0.0, 0.0, 1000000.0), new SuperMap.Matrix4()),
*   id : 'box',
*   attributes : {
*     color : new SuperMap.GeometryInstanceAttribute({
*       componentDatatype : SuperMap.ComponentDatatype.UNSIGNED_BYTE,
*       componentsPerAttribute : 4,
*       normalize : true,
*       value : [255, 255, 0, 255]
*     })
*   }
* });
* @param options - Object with the following properties:
* @param options.componentDatatype - The datatype of each component in the attribute, e.g., individual elements in values.
* @param options.componentsPerAttribute - A number between 1 and 4 that defines the number of components in an attributes.
* @param [options.normalize = false] - When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.
* @param options.value - The value for the attribute.
*/
export class GeometryInstanceAttribute {
  constructor(options: {
    componentDatatype: ComponentDatatype;
    componentsPerAttribute: number;
    normalize?: boolean;
    value: number[];
  });
  /**
   * The datatype of each component in the attribute, e.g., individual elements in
   * {@link GeometryInstanceAttribute#value}.
   */
  componentDatatype: ComponentDatatype;
  /**
   * A number between 1 and 4 that defines the number of components in an attributes.
   * For example, a position attribute with x, y, and z components would have 3 as
   * shown in the code example.
   * @example
   * show : new SuperMap.GeometryInstanceAttribute({
   *   componentDatatype : SuperMap.ComponentDatatype.UNSIGNED_BYTE,
   *   componentsPerAttribute : 1,
   *   normalize : true,
   *   value : [1.0]
   * })
   */
  componentsPerAttribute: number;
  /**
   * When <code>true</code> and <code>componentDatatype</code> is an integer format,
   * indicate that the components should be mapped to the range [0, 1] (unsigned)
   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
   * <p>
   * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.
   * </p>
   * @example
   * attribute.componentDatatype = SuperMap.ComponentDatatype.UNSIGNED_BYTE;
   * attribute.componentsPerAttribute = 4;
   * attribute.normalize = true;
   * attribute.value = [
   *   SuperMap.Color.floatToByte(color.red),
   *   SuperMap.Color.floatToByte(color.green),
   *   SuperMap.Color.floatToByte(color.blue),
   *   SuperMap.Color.floatToByte(color.alpha)
   * ];
   */
  normalize: boolean;
  /**
   * The values for the attributes stored in a typed array.  In the code example,
   * every three elements in <code>values</code> defines one attributes since
   * <code>componentsPerAttribute</code> is 3.
   * @example
   * show : new SuperMap.GeometryInstanceAttribute({
   *   componentDatatype : SuperMap.ComponentDatatype.UNSIGNED_BYTE,
   *   componentsPerAttribute : 1,
   *   normalize : true,
   *   value : [1.0]
   * })
   */
  value: number[];
}

/**
* Content pipeline functions for geometries.
*/
export namespace GeometryPipeline {
  /**
   * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>
   * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,
   * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.
   * <p>
   * This is commonly used to create a wireframe geometry for visual debugging.
   * </p>
   * @example
   * geometry = SuperMap.GeometryPipeline.toWireframe(geometry);
   * @param geometry - The geometry to modify.
   * @returns The modified <code>geometry</code> argument, with its triangle indices converted to lines.
   */
  function toWireframe(geometry: Geometry): Geometry;
  /**
   * Creates a new {@link Geometry} with <code>LINES</code> representing the provided
   * attribute (<code>attributeName</code>) for the provided geometry.  This is used to
   * visualize vector attributes like normals, tangents, and bitangents.
   * @example
   * const geometry = SuperMap.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);
   * @param geometry - The <code>Geometry</code> instance with the attribute.
   * @param [attributeName = 'normal'] - The name of the attribute.
   * @param [length = 10000.0] - The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.
   * @returns A new <code>Geometry</code> instance with line segments for the vector.
   */
  function createLineSegmentsForVectors(geometry: Geometry, attributeName?: string, length?: number): Geometry;
  /**
   * Creates an object that maps attribute names to unique locations (indices)
   * for matching vertex attributes and shader programs.
   * @example
   * const attributeLocations = SuperMap.GeometryPipeline.createAttributeLocations(geometry);
   * // Example output
   * // {
   * //   'position' : 0,
   * //   'normal' : 1
   * // }
   * @param geometry - The geometry, which is not modified, to create the object for.
   * @returns An object with attribute name / index pairs.
   */
  function createAttributeLocations(geometry: Geometry): any;
  /**
   * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.
   * @example
   * geometry = SuperMap.GeometryPipeline.reorderForPreVertexCache(geometry);
   * @param geometry - The geometry to modify.
   * @returns The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.
   */
  function reorderForPreVertexCache(geometry: Geometry): Geometry;
  /**
   * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's
   * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>
   * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.
   * @example
   * geometry = SuperMap.GeometryPipeline.reorderForPostVertexCache(geometry);
   * @param geometry - The geometry to modify.
   * @param [cacheCapacity = 24] - The number of vertices that can be held in the GPU's vertex cache.
   * @returns The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.
   */
  function reorderForPostVertexCache(geometry: Geometry, cacheCapacity?: number): Geometry;
  /**
   * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the
   * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements
   * when unsigned int indices are not supported.
   * <p>
   * If the geometry does not have any <code>indices</code>, this function has no effect.
   * </p>
   * @example
   * const geometries = SuperMap.GeometryPipeline.fitToUnsignedShortIndices(geometry);
   * @param geometry - The geometry to be split into multiple geometries.
   * @returns An array of geometries, each with indices that fit into unsigned shorts.
   */
  function fitToUnsignedShortIndices(geometry: Geometry): Geometry[];
  /**
   * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>
   * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.
   * <p>
   * If the geometry does not have a <code>position</code>, this function has no effect.
   * </p>
   * @example
   * geometry = SuperMap.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');
   * @param geometry - The geometry to modify.
   * @param attributeName - The name of the attribute.
   * @param attributeName3D - The name of the attribute in 3D.
   * @param attributeName2D - The name of the attribute in 2D.
   * @param [projection = new GeographicProjection()] - The projection to use.
   * @returns The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.
   */
  function projectTo2D(geometry: Geometry, attributeName: string, attributeName3D: string, attributeName2D: string, projection?: any): Geometry;
  /**
   * Encodes floating-point geometry attribute values as two separate attributes to improve
   * rendering precision.
   * <p>
   * This is commonly used to create high-precision position vertex attributes.
   * </p>
   * @example
   * geometry = SuperMap.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');
   * @param geometry - The geometry to modify.
   * @param attributeName - The name of the attribute.
   * @param attributeHighName - The name of the attribute for the encoded high bits.
   * @param attributeLowName - The name of the attribute for the encoded low bits.
   * @returns The modified <code>geometry</code> argument, with its encoded attribute.
   */
  function encodeAttribute(geometry: Geometry, attributeName: string, attributeHighName: string, attributeLowName: string): Geometry;
  /**
   * Transforms a geometry instance to world coordinates.  This changes
   * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the
   * following attributes if they are present: <code>position</code>, <code>normal</code>,
   * <code>tangent</code>, and <code>bitangent</code>.
   * @example
   * SuperMap.GeometryPipeline.transformToWorldCoordinates(instance);
   * @param instance - The geometry instance to modify.
   * @returns The modified <code>instance</code> argument, with its attributes transforms to world coordinates.
   */
  function transformToWorldCoordinates(instance: GeometryInstance): GeometryInstance;
  /**
   * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of
   * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.
   * This assumes a counter-clockwise winding order.
   * @example
   * SuperMap.GeometryPipeline.computeNormal(geometry);
   * @param geometry - The geometry to modify.
   * @returns The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.
   */
  function computeNormal(geometry: Geometry): Geometry;
  /**
   * Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.
   * The result is new <code>tangent</code> and <code>bitangent</code> attributes added to the geometry.
   * This assumes a counter-clockwise winding order.
   * @example
   * SuperMap.GeometryPipeline.computeTangentAndBiTangent(geometry);
   * @param geometry - The geometry to modify.
   * @returns The modified <code>geometry</code> argument with the computed <code>tangent</code> and <code>bitangent</code> attributes.
   */
  function computeTangentAndBitangent(geometry: Geometry): Geometry;
  /**
   * Compresses and packs geometry normal attribute values to save memory.
   * @example
   * geometry = SuperMap.GeometryPipeline.compressVertices(geometry);
   * @param geometry - The geometry to modify.
   * @returns The modified <code>geometry</code> argument, with its normals compressed and packed.
   */
  function compressVertices(geometry: Geometry): Geometry;
}

/**
* Provides metadata using the Google Earth Enterprise REST API. This is used by the GoogleEarthEnterpriseImageryProvider
*  and GoogleEarthEnterpriseTerrainProvider to share metadata requests.
* @param resourceOrUrl - The url of the Google Earth Enterprise server hosting the imagery
*/
export class GoogleEarthEnterpriseMetadata {
  constructor(resourceOrUrl: Resource | string);
  /**
   * True if imagery is available.
   */
  imageryPresent: boolean;
  /**
   * True if imagery is sent as a protocol buffer, false if sent as plain images. If undefined we will try both.
   */
  protoImagery: boolean;
  /**
   * True if terrain is available.
   */
  terrainPresent: boolean;
  /**
   * Exponent used to compute constant to calculate negative height values.
   */
  negativeAltitudeExponentBias: number;
  /**
   * Threshold where any numbers smaller are actually negative values. They are multiplied by -2^negativeAltitudeExponentBias.
   */
  negativeAltitudeThreshold: number;
  /**
   * Dictionary of provider id to copyright strings.
   */
  providers: any;
  /**
   * Key used to decode packets
   */
  key: ArrayBuffer;
  /**
   * Gets the name of the Google Earth Enterprise server.
   */
  readonly url: string;
  /**
   * Gets the proxy used for metadata requests.
   */
  readonly proxy: Proxy;
  /**
   * Gets the resource used for metadata requests.
   */
  readonly resource: Resource;
  /**
   * Gets a promise that resolves to true when the metadata is ready for use.
   */
  readonly readyPromise: Promise<boolean>;
  /**
   * Converts a tiles (x, y, level) position into a quadkey used to request an image
   * from a Google Earth Enterprise server.
   * @param x - The tile's x coordinate.
   * @param y - The tile's y coordinate.
   * @param level - The tile's zoom level.
   */
  tileXYToQuadKey(x: number, y: number, level: number): void;
  /**
   * Converts a tile's quadkey used to request an image from a Google Earth Enterprise server into the
   * (x, y, level) position.
   * @param quadkey - The tile's quad key
   */
  quadKeyToTileXY(quadkey: string): void;
}

/**
* Terrain data for a single tile from a Google Earth Enterprise server.
* @example
* const buffer = ...
* const childTileMask = ...
* const terrainData = new SuperMap.GoogleEarthEnterpriseTerrainData({
*   buffer : heightBuffer,
*   childTileMask : childTileMask
* });
* @param options - Object with the following properties:
* @param options.buffer - The buffer containing terrain data.
* @param options.negativeAltitudeExponentBias - Multiplier for negative terrain heights that are encoded as very small positive values.
* @param options.negativeElevationThreshold - Threshold for negative values
* @param [options.childTileMask = 15] - A bit mask indicating which of this tile's four children exist.
*                 If a child's bit is set, geometry will be requested for that tile as well when it
*                 is needed.  If the bit is cleared, the child tile is not requested and geometry is
*                 instead upsampled from the parent.  The bit values are as follows:
*                 <table>
*                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
*                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>
*                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>
*                  <tr><td>2</td><td>4</td><td>Northeast</td></tr>
*                  <tr><td>3</td><td>8</td><td>Northwest</td></tr>
*                 </table>
* @param [options.createdByUpsampling = false] - True if this instance was created by upsampling another instance;
*                  otherwise, false.
* @param [options.credits] - Array of credits for this tile.
*/
export class GoogleEarthEnterpriseTerrainData {
  constructor(options: {
    buffer: ArrayBuffer;
    negativeAltitudeExponentBias: number;
    negativeElevationThreshold: number;
    childTileMask?: number;
    createdByUpsampling?: boolean;
    credits?: Credit[];
  });
  /**
   * An array of credits for this tile
   */
  credits: Credit[];
  /**
   * The water mask included in this terrain data, if any.  A water mask is a rectangular
   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
   */
  waterMask: Uint8Array | HTMLImageElement | HTMLCanvasElement;
  /**
   * Computes the terrain height at a specified longitude and latitude.
   * @param rectangle - The rectangle covered by this terrain data.
   * @param longitude - The longitude in radians.
   * @param latitude - The latitude in radians.
   * @returns The terrain height at the specified position.  If the position
   *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly
   *          incorrect for positions far outside the rectangle.
   */
  interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;
  /**
   * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the
   * height samples in this instance, interpolated if necessary.
   * @param tilingScheme - The tiling scheme of this terrain data.
   * @param thisX - The X coordinate of this tile in the tiling scheme.
   * @param thisY - The Y coordinate of this tile in the tiling scheme.
   * @param thisLevel - The level of this tile in the tiling scheme.
   * @param descendantX - The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
   * @param descendantY - The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
   * @param descendantLevel - The level within the tiling scheme of the descendant tile for which we are upsampling.
   * @returns A promise for upsampled heightmap terrain data for the descendant tile,
   *          or undefined if too many asynchronous upsample operations are in progress and the request has been
   *          deferred.
   */
  upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): Promise<HeightmapTerrainData> | undefined;
  /**
   * Determines if a given child tile is available, based on the
   * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed
   * to be one of the four children of this tile.  If non-child tile coordinates are
   * given, the availability of the southeast child tile is returned.
   * @param thisX - The tile X coordinate of this (the parent) tile.
   * @param thisY - The tile Y coordinate of this (the parent) tile.
   * @param childX - The tile X coordinate of the child tile to check for availability.
   * @param childY - The tile Y coordinate of the child tile to check for availability.
   * @returns True if the child tile is available; otherwise, false.
   */
  isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): boolean;
  /**
   * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
   * terrain data.  If this value is false, the data was obtained from some other source, such
   * as by downloading it from a remote server.  This method should return true for instances
   * returned from a call to {@link HeightmapTerrainData#upsample}.
   * @returns True if this instance was created by upsampling; otherwise, false.
   */
  wasCreatedByUpsampling(): boolean;
}

/**
* Provides tiled terrain using the Google Earth Enterprise REST API.
* @example
* const geeMetadata = new GoogleEarthEnterpriseMetadata('http://www.earthenterprise.org/3d');
* const gee = new SuperMap.GoogleEarthEnterpriseTerrainProvider({
*     metadata : geeMetadata
* });
* @param options - Object with the following properties:
* @param options.url - The url of the Google Earth Enterprise server hosting the imagery.
* @param options.metadata - A metadata object that can be used to share metadata requests with a GoogleEarthEnterpriseImageryProvider.
* @param [options.ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
* @param [options.credit] - A credit for the data source, which is displayed on the canvas.
*/
export class GoogleEarthEnterpriseTerrainProvider {
  constructor(options: {
    url: Resource | string;
    metadata: GoogleEarthEnterpriseMetadata;
    ellipsoid?: Ellipsoid;
    credit?: Credit | string;
  });
  /**
   * Gets the name of the Google Earth Enterprise server url hosting the imagery.
   */
  readonly url: string;
  /**
   * Gets the proxy used by this provider.
   */
  readonly proxy: Proxy;
  /**
   * Gets the tiling scheme used by this provider.  This function should
   * not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.
   */
  readonly tilingScheme: TilingScheme;
  /**
   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
   * are passed an instance of {@link TileProviderError}.
   */
  readonly errorEvent: Event;
  /**
   * Gets a value indicating whether or not the provider is ready for use.
   */
  readonly ready: boolean;
  /**
   * Gets a promise that resolves to true when the provider is ready for use.
   */
  readonly readyPromise: Promise<boolean>;
  /**
   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
   * the source of the terrain.  This function should not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.
   */
  readonly credit: Credit;
  /**
   * Gets a value indicating whether or not the provider includes a water mask.  The water mask
   * indicates which areas of the globe are water rather than land, so they can be rendered
   * as a reflective surface with animated waves.  This function should not be
   * called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.
   */
  readonly hasWaterMask: boolean;
  /**
   * Gets a value indicating whether or not the requested tiles include vertex normals.
   * This function should not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.
   */
  readonly hasVertexNormals: boolean;
  /**
   * Gets an object that can be used to determine availability of terrain from this provider, such as
   * at points and in rectangles.  This function should not be called before
   * {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.  This property may be undefined if availability
   * information is not available.
   */
  readonly availability: TileAvailability;
  /**
   * Requests the geometry for a given tile.  This function should not be called before
   * {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.  The result must include terrain data and
   * may optionally include a water mask and an indication of which child tiles are available.
   * @param x - The X coordinate of the tile for which to request geometry.
   * @param y - The Y coordinate of the tile for which to request geometry.
   * @param level - The level of the tile for which to request geometry.
   * @param [request] - The request object. Intended for internal use only.
   * @returns A promise for the requested geometry.  If this method
   *          returns undefined instead of a promise, it is an indication that too many requests are already
   *          pending and the request will be retried later.
   */
  requestTileGeometry(x: number, y: number, level: number, request?: Request): Promise<TerrainData> | undefined;
  /**
   * Gets the maximum geometric error allowed in a tile at a given level.
   * @param level - The tile level for which to get the maximum geometric error.
   * @returns The maximum geometric error.
   */
  getLevelMaximumGeometricError(level: number): number;
  /**
   * Determines whether data for a tile is available to be loaded.
   * @param x - The X coordinate of the tile for which to request geometry.
   * @param y - The Y coordinate of the tile for which to request geometry.
   * @param level - The level of the tile for which to request geometry.
   * @returns Undefined if not supported, otherwise true or false.
   */
  getTileDataAvailable(x: number, y: number, level: number): boolean | undefined;
  /**
   * Makes sure we load availability data for a tile
   * @param x - The X coordinate of the tile for which to request geometry.
   * @param y - The Y coordinate of the tile for which to request geometry.
   * @param level - The level of the tile for which to request geometry.
   */
  loadTileDataAvailability(x: number, y: number, level: number): undefined;
}

/**
* Represents a Gregorian date in a more precise format than the JavaScript Date object.
* In addition to submillisecond precision, this object can also represent leap seconds.
* @param [year] - The year as a whole number.
* @param [month] - The month as a whole number with range [1, 12].
* @param [day] - The day of the month as a whole number starting at 1.
* @param [hour] - The hour as a whole number with range [0, 23].
* @param [minute] - The minute of the hour as a whole number with range [0, 59].
* @param [second] - The second of the minute as a whole number with range [0, 60], with 60 representing a leap second.
* @param [millisecond] - The millisecond of the second as a floating point number with range [0.0, 1000.0).
* @param [isLeapSecond] - Whether this time is during a leap second.
*/
export class GregorianDate {
  constructor(year?: number, month?: number, day?: number, hour?: number, minute?: number, second?: number, millisecond?: number, isLeapSecond?: boolean);
  /**
   * Gets or sets the year as a whole number.
   */
  year: number;
  /**
   * Gets or sets the month as a whole number with range [1, 12].
   */
  month: number;
  /**
   * Gets or sets the day of the month as a whole number starting at 1.
   */
  day: number;
  /**
   * Gets or sets the hour as a whole number with range [0, 23].
   */
  hour: number;
  /**
   * Gets or sets the minute of the hour as a whole number with range [0, 59].
   */
  minute: number;
  /**
   * Gets or sets the second of the minute as a whole number with range [0, 60], with 60 representing a leap second.
   */
  second: number;
  /**
   * Gets or sets the millisecond of the second as a floating point number with range [0.0, 1000.0).
   */
  millisecond: number;
  /**
   * Gets or sets whether this time is during a leap second.
   */
  isLeapSecond: boolean;
}

/**
* A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.
* @example
* const positions = SuperMap.Cartesian3.fromDegreesArray([
*   -112.1340164450331, 36.05494287836128,
*   -112.08821010582645, 36.097804071380715,
*   -112.13296079730024, 36.168769146801104
* ]);
*
* const geometry = new SuperMap.GroundPolylineGeometry({
*   positions : positions
* });
* @param options - Options with the following properties:
* @param options.positions - An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.
* @param [options.width = 1.0] - The screen space width in pixels.
* @param [options.granularity = 9999.0] - The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.
* @param [options.loop = false] - Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.
* @param [options.arcType = ArcType.GEODESIC] - The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
*/
export class GroundPolylineGeometry {
  constructor(options: {
    positions: Cartesian3[];
    width?: number;
    granularity?: number;
    loop?: boolean;
    arcType?: ArcType;
  });
  /**
   * The screen space width in pixels.
   */
  width: number;
  /**
   * The distance interval used for interpolating options.points. Zero indicates no interpolation.
   * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.
   */
  granularity: boolean;
  /**
   * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.
   * If the geometry has two positions this parameter will be ignored.
   */
  loop: boolean;
  /**
   * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
   */
  arcType: ArcType;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: PolygonGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   */
  unpack(array: number[], startingIndex?: number, result?: PolygonGeometry): void;
}

/**
* Defines a heading angle, pitch angle, and range in a local frame.
* Heading is the rotation from the local north direction where a positive angle is increasing eastward.
* Pitch is the rotation from the local xy-plane. Positive pitch angles are above the plane. Negative pitch
* angles are below the plane. Range is the distance from the center of the frame.
* @param [heading = 0.0] - The heading angle in radians.
* @param [pitch = 0.0] - The pitch angle in radians.
* @param [range = 0.0] - The distance from the center in meters.
*/
export class HeadingPitchRange {
  constructor(heading?: number, pitch?: number, range?: number);
  /**
   * Heading is the rotation from the local north direction where a positive angle is increasing eastward.
   */
  heading: number;
  /**
   * Pitch is the rotation from the local xy-plane. Positive pitch angles
   * are above the plane. Negative pitch angles are below the plane.
   */
  pitch: number;
  /**
   * Range is the distance from the center of the local frame.
   */
  range: number;
  /**
   * Duplicates a HeadingPitchRange instance.
   * @param hpr - The HeadingPitchRange to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new HeadingPitchRange instance if one was not provided. (Returns undefined if hpr is undefined)
   */
  clone(hpr: HeadingPitchRange, result?: HeadingPitchRange): HeadingPitchRange;
}

/**
* A rotation expressed as a heading, pitch, and roll. Heading is the rotation about the
* negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
* the positive x axis.
* @param [heading = 0.0] - The heading component in radians.
* @param [pitch = 0.0] - The pitch component in radians.
* @param [roll = 0.0] - The roll component in radians.
*/
export class HeadingPitchRoll {
  constructor(heading?: number, pitch?: number, roll?: number);
  /**
   * Gets or sets the heading.
   */
  heading: number;
  /**
   * Gets or sets the pitch.
   */
  pitch: number;
  /**
   * Gets or sets the roll.
   */
  roll: number;
  /**
   * @param quaternion - The quaternion from which to retrieve heading, pitch, and roll, all expressed in radians.
   * @param [result] - The object in which to store the result. If not provided, a new instance is created and returned.
   * @returns The modified result parameter or a new HeadingPitchRoll instance if one was not provided.
   */
  fromQuaternion(quaternion: Quaternion, result?: HeadingPitchRoll): HeadingPitchRoll;
  /**
   * Returns a new HeadingPitchRoll instance from angles given in degrees.
   * @param heading - the heading in degrees
   * @param pitch - the pitch in degrees
   * @param roll - the heading in degrees
   * @param [result] - The object in which to store the result. If not provided, a new instance is created and returned.
   * @returns A new HeadingPitchRoll instance
   */
  fromDegrees(heading: number, pitch: number, roll: number, result?: HeadingPitchRoll): HeadingPitchRoll;
  /**
   * Duplicates a HeadingPitchRoll instance.
   * @param headingPitchRoll - The HeadingPitchRoll to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new HeadingPitchRoll instance if one was not provided. (Returns undefined if headingPitchRoll is undefined)
   */
  clone(headingPitchRoll: HeadingPitchRoll, result?: HeadingPitchRoll): HeadingPitchRoll;
  /**
   * Compares the provided HeadingPitchRolls componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [left] - The first HeadingPitchRoll.
   * @param [right] - The second HeadingPitchRoll.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left?: HeadingPitchRoll, right?: HeadingPitchRoll): boolean;
  /**
   * Compares the provided HeadingPitchRolls componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param [left] - The first HeadingPitchRoll.
   * @param [right] - The second HeadingPitchRoll.
   * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
   * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(left?: HeadingPitchRoll, right?: HeadingPitchRoll, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
  /**
   * Duplicates this HeadingPitchRoll instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new HeadingPitchRoll instance if one was not provided.
   */
  clone(result?: HeadingPitchRoll): HeadingPitchRoll;
  /**
   * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The right hand side HeadingPitchRoll.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(right?: HeadingPitchRoll): boolean;
  /**
   * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param [right] - The right hand side HeadingPitchRoll.
   * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
   * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(right?: HeadingPitchRoll, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
  /**
   * Creates a string representing this HeadingPitchRoll in the format '(heading, pitch, roll)' in radians.
   * @returns A string representing the provided HeadingPitchRoll in the format '(heading, pitch, roll)'.
   */
  toString(): string;
}
/**
 * The encoding that is used for a heightmap
 */
export enum HeightmapEncoding {
  /**
   * No encoding
   */
  NONE = 0,
  /**
   * LERC encoding
   */
  LERC = 1
}

/**
* Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap
* is a rectangular array of heights in row-major order from north to south and west to east.
* @example
* const buffer = ...
* const heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);
* const childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];
* const waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);
* const terrainData = new SuperMap.HeightmapTerrainData({
*   buffer : heightBuffer,
*   width : 65,
*   height : 65,
*   childTileMask : childTileMask,
*   waterMask : waterMask
* });
* @param options - Object with the following properties:
* @param options.buffer - The buffer containing height data.
* @param options.width - The width (longitude direction) of the heightmap, in samples.
* @param options.height - The height (latitude direction) of the heightmap, in samples.
* @param [options.childTileMask = 15] - A bit mask indicating which of this tile's four children exist.
*                 If a child's bit is set, geometry will be requested for that tile as well when it
*                 is needed.  If the bit is cleared, the child tile is not requested and geometry is
*                 instead upsampled from the parent.  The bit values are as follows:
*                 <table>
*                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
*                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>
*                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>
*                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>
*                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>
*                 </table>
* @param [options.waterMask] - The water mask included in this terrain data, if any.  A water mask is a square
*                     Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
*                     Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
* @param [options.structure] - An object describing the structure of the height data.
* @param [options.structure.heightScale = 1.0] - The factor by which to multiply height samples in order to obtain
*                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting
*                 height after multiplying by the scale.
* @param [options.structure.heightOffset = 0.0] - The offset to add to the scaled height to obtain the final
*                 height in meters.  The offset is added after the height sample is multiplied by the
*                 heightScale.
* @param [options.structure.elementsPerHeight = 1] - The number of elements in the buffer that make up a single height
*                 sample.  This is usually 1, indicating that each element is a separate height sample.  If
*                 it is greater than 1, that number of elements together form the height sample, which is
*                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.
* @param [options.structure.stride = 1] - The number of elements to skip to get from the first element of
*                 one height to the first element of the next height.
* @param [options.structure.elementMultiplier = 256.0] - The multiplier used to compute the height value when the
*                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier
*                 is 256, the height is computed as follows:
*                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`
*                 This is assuming that the isBigEndian property is false.  If it is true, the order of the
*                 elements is reversed.
* @param [options.structure.isBigEndian = false] - Indicates endianness of the elements in the buffer when the
*                  stride property is greater than 1.  If this property is false, the first element is the
*                  low-order element.  If it is true, the first element is the high-order element.
* @param [options.structure.lowestEncodedHeight] - The lowest value that can be stored in the height buffer.  Any heights that are lower
*                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height
*                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is
*                 not specified, no minimum value is enforced.
* @param [options.structure.highestEncodedHeight] - The highest value that can be stored in the height buffer.  Any heights that are higher
*                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height
*                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger
*                 than 65535.  If this parameter is not specified, no maximum value is enforced.
* @param [options.encoding = HeightmapEncoding.NONE] - The encoding that is used on the buffer.
* @param [options.createdByUpsampling = false] - True if this instance was created by upsampling another instance;
*                  otherwise, false.
*/
export class HeightmapTerrainData {
  constructor(options: {
    buffer: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
    width: number;
    height: number;
    childTileMask?: number;
    waterMask?: Uint8Array;
    structure?: {
      heightScale?: number;
      heightOffset?: number;
      elementsPerHeight?: number;
      stride?: number;
      elementMultiplier?: number;
      isBigEndian?: boolean;
      lowestEncodedHeight?: number;
      highestEncodedHeight?: number;
    };
    encoding?: HeightmapEncoding;
    createdByUpsampling?: boolean;
  });
  /**
   * An array of credits for this tile.
   */
  credits: Credit[];
  /**
   * The water mask included in this terrain data, if any.  A water mask is a square
   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
   */
  waterMask: Uint8Array | HTMLImageElement | HTMLCanvasElement;
  /**
   * Computes the terrain height at a specified longitude and latitude.
   * @param rectangle - The rectangle covered by this terrain data.
   * @param longitude - The longitude in radians.
   * @param latitude - The latitude in radians.
   * @returns The terrain height at the specified position.  If the position
   *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly
   *          incorrect for positions far outside the rectangle.
   */
  interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;
  /**
   * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the
   * height samples in this instance, interpolated if necessary.
   * @param tilingScheme - The tiling scheme of this terrain data.
   * @param thisX - The X coordinate of this tile in the tiling scheme.
   * @param thisY - The Y coordinate of this tile in the tiling scheme.
   * @param thisLevel - The level of this tile in the tiling scheme.
   * @param descendantX - The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
   * @param descendantY - The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
   * @param descendantLevel - The level within the tiling scheme of the descendant tile for which we are upsampling.
   * @returns A promise for upsampled heightmap terrain data for the descendant tile,
   *          or undefined if the mesh is unavailable.
   */
  upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): Promise<HeightmapTerrainData> | undefined;
  /**
   * Determines if a given child tile is available, based on the
   * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed
   * to be one of the four children of this tile.  If non-child tile coordinates are
   * given, the availability of the southeast child tile is returned.
   * @param thisX - The tile X coordinate of this (the parent) tile.
   * @param thisY - The tile Y coordinate of this (the parent) tile.
   * @param childX - The tile X coordinate of the child tile to check for availability.
   * @param childY - The tile Y coordinate of the child tile to check for availability.
   * @returns True if the child tile is available; otherwise, false.
   */
  isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): boolean;
  /**
   * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
   * terrain data.  If this value is false, the data was obtained from some other source, such
   * as by downloading it from a remote server.  This method should return true for instances
   * returned from a call to {@link HeightmapTerrainData#upsample}.
   * @returns True if this instance was created by upsampling; otherwise, false.
   */
  wasCreatedByUpsampling(): boolean;
}

/**
* An {@link InterpolationAlgorithm} for performing Hermite interpolation.
*/
export namespace HermitePolynomialApproximation {
  /**
   * Given the desired degree, returns the number of data points required for interpolation.
   * @param degree - The desired degree of interpolation.
   * @param [inputOrder = 0] - The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).
   * @returns The number of required data points needed for the desired degree of interpolation.
   */
  function getRequiredDataPoints(degree: number, inputOrder?: number): number;
  /**
   * Interpolates values using Hermite Polynomial Approximation.
   * @param x - The independent variable for which the dependent variables will be interpolated.
   * @param xTable - The array of independent variables to use to interpolate.  The values
   * in this array must be in increasing order and the same value must not occur twice in the array.
   * @param yTable - The array of dependent variables to use to interpolate.  For a set of three
   * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
   * @param yStride - The number of dependent variable values in yTable corresponding to
   * each independent variable value in xTable.
   * @param [result] - An existing array into which to store the result.
   * @returns The array of interpolated values, or the result parameter if one was provided.
   */
  function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];
  /**
   * Interpolates values using Hermite Polynomial Approximation.
   * @param x - The independent variable for which the dependent variables will be interpolated.
   * @param xTable - The array of independent variables to use to interpolate.  The values
   * in this array must be in increasing order and the same value must not occur twice in the array.
   * @param yTable - The array of dependent variables to use to interpolate.  For a set of three
   * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
   * @param yStride - The number of dependent variable values in yTable corresponding to
   * each independent variable value in xTable.
   * @param inputOrder - The number of derivatives supplied for input.
   * @param outputOrder - The number of derivatives desired for output.
   * @param [result] - An existing array into which to store the result.
   * @returns The array of interpolated values, or the result parameter if one was provided.
   */
  function interpolate(x: number, xTable: number[], yTable: number[], yStride: number, inputOrder: number, outputOrder: number, result?: number[]): number[];
}

/**
* A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times
* must be defined for each control point. The outgoing tangents are defined for points [0, n - 2] and the incoming
* tangents are defined for points [1, n - 1]. For example, when interpolating a segment of the curve between <code>points[i]</code> and
* <code>points[i + 1]</code>, the tangents at the points will be <code>outTangents[i]</code> and <code>inTangents[i]</code>,
* respectively.
* @example
* // Create a G<sup>1</sup> continuous Hermite spline
* const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];
* const spline = new SuperMap.HermiteSpline({
*     times : times,
*     points : [
*         new SuperMap.Cartesian3(1235398.0, -4810983.0, 4146266.0),
*         new SuperMap.Cartesian3(1372574.0, -5345182.0, 4606657.0),
*         new SuperMap.Cartesian3(-757983.0, -5542796.0, 4514323.0),
*         new SuperMap.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
*         new SuperMap.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
*     ],
*     outTangents : [
*         new SuperMap.Cartesian3(1125196, -161816, 270551),
*         new SuperMap.Cartesian3(-996690.5, -365906.5, 184028.5),
*         new SuperMap.Cartesian3(-2096917, 48379.5, -292683.5),
*         new SuperMap.Cartesian3(-890902.5, 408999.5, -447115)
*     ],
*     inTangents : [
*         new SuperMap.Cartesian3(-1993381, -731813, 368057),
*         new SuperMap.Cartesian3(-4193834, 96759, -585367),
*         new SuperMap.Cartesian3(-1781805, 817999, -894230),
*         new SuperMap.Cartesian3(1165345, 112641, 47281)
*     ]
* });
*
* const p0 = spline.evaluate(times[0]);
* @param options - Object with the following properties:
* @param options.times - An array of strictly increasing, unit-less, floating-point times at each point.
*                The values are in no way connected to the clock time. They are the parameterization for the curve.
* @param options.points - The array of control points.
* @param options.inTangents - The array of incoming tangents at each control point.
* @param options.outTangents - The array of outgoing tangents at each control point.
*/
export class HermiteSpline {
  constructor(options: {
    times: number[];
    points: Cartesian3[];
    inTangents: Cartesian3[];
    outTangents: Cartesian3[];
  });
  /**
   * An array of times for the control points.
   */
  readonly times: number[];
  /**
   * An array of control points.
   */
  readonly points: Cartesian3[];
  /**
   * An array of incoming tangents at each control point.
   */
  readonly inTangents: Cartesian3[];
  /**
   * An array of outgoing tangents at each control point.
   */
  readonly outTangents: Cartesian3[];
  /**
   * Creates a spline where the tangents at each control point are the same.
   * The curves are guaranteed to be at least in the class C<sup>1</sup>.
   * @example
   * const points = [
   *     new SuperMap.Cartesian3(1235398.0, -4810983.0, 4146266.0),
   *     new SuperMap.Cartesian3(1372574.0, -5345182.0, 4606657.0),
   *     new SuperMap.Cartesian3(-757983.0, -5542796.0, 4514323.0),
   *     new SuperMap.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
   *     new SuperMap.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
   * ];
   *
   * // Add tangents
   * const tangents = new Array(points.length);
   * tangents[0] = new SuperMap.Cartesian3(1125196, -161816, 270551);
   * const temp = new SuperMap.Cartesian3();
   * for (let i = 1; i < tangents.length - 1; ++i) {
   *     tangents[i] = SuperMap.Cartesian3.multiplyByScalar(SuperMap.Cartesian3.subtract(points[i + 1], points[i - 1], temp), 0.5, new SuperMap.Cartesian3());
   * }
   * tangents[tangents.length - 1] = new SuperMap.Cartesian3(1165345, 112641, 47281);
   *
   * const spline = SuperMap.HermiteSpline.createC1({
   *     times : times,
   *     points : points,
   *     tangents : tangents
   * });
   * @param options - Object with the following properties:
   * @param options.times - The array of control point times.
   * @param options.points - The array of control points.
   * @param options.tangents - The array of tangents at the control points.
   * @returns A hermite spline.
   */
  createC1(options: {
    times: number[];
    points: Cartesian3[];
    tangents: Cartesian3[];
  }): HermiteSpline;
  /**
   * Creates a natural cubic spline. The tangents at the control points are generated
   * to create a curve in the class C<sup>2</sup>.
   * @example
   * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.
   * const spline = SuperMap.HermiteSpline.createNaturalCubic({
   *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],
   *     points : [
   *         new SuperMap.Cartesian3(1235398.0, -4810983.0, 4146266.0),
   *         new SuperMap.Cartesian3(1372574.0, -5345182.0, 4606657.0),
   *         new SuperMap.Cartesian3(-757983.0, -5542796.0, 4514323.0),
   *         new SuperMap.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
   *         new SuperMap.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
   *     ]
   * });
   * @param options - Object with the following properties:
   * @param options.times - The array of control point times.
   * @param options.points - The array of control points.
   * @returns A hermite spline, or a linear spline if less than 3 control points were given.
   */
  createNaturalCubic(options: {
    times: number[];
    points: Cartesian3[];
  }): HermiteSpline | LinearSpline;
  /**
   * Creates a clamped cubic spline. The tangents at the interior control points are generated
   * to create a curve in the class C<sup>2</sup>.
   * @example
   * // Create a clamped cubic spline above the earth from Philadelphia to Los Angeles.
   * const spline = SuperMap.HermiteSpline.createClampedCubic({
   *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],
   *     points : [
   *         new SuperMap.Cartesian3(1235398.0, -4810983.0, 4146266.0),
   *         new SuperMap.Cartesian3(1372574.0, -5345182.0, 4606657.0),
   *         new SuperMap.Cartesian3(-757983.0, -5542796.0, 4514323.0),
   *         new SuperMap.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
   *         new SuperMap.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
   *     ],
   *     firstTangent : new SuperMap.Cartesian3(1125196, -161816, 270551),
   *     lastTangent : new SuperMap.Cartesian3(1165345, 112641, 47281)
   * });
   * @param options - Object with the following properties:
   * @param options.times - The array of control point times.
   * @param options.points - The array of control points.
   * @param options.firstTangent - The outgoing tangent of the first control point.
   * @param options.lastTangent - The incoming tangent of the last control point.
   * @returns A hermite spline, or a linear spline if less than 3 control points were given.
   */
  createClampedCubic(options: {
    times: number[];
    points: number[] | Cartesian3[];
    firstTangent: Cartesian3;
    lastTangent: Cartesian3;
  }): HermiteSpline | LinearSpline;
  /**
   * Finds an index <code>i</code> in <code>times</code> such that the parameter
   * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
   * @param time - The time.
   * @returns The index for the element at the start of the interval.
   */
  findTimeInterval(time: number): number;
  /**
   * Wraps the given time to the period covered by the spline.
   * @param time - The time.
   * @returns The time, wrapped around to the updated animation.
   */
  wrapTime(time: number): number;
  /**
   * Clamps the given time to the period covered by the spline.
   * @param time - The time.
   * @returns The time, clamped to the animation period.
   */
  clampTime(time: number): number;
  /**
   * Evaluates the curve at a given time.
   * @param time - The time at which to evaluate the curve.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new instance of the point on the curve at the given time.
   */
  evaluate(time: number, result?: Cartesian3): Cartesian3;
}
/**
 * Constants for WebGL index datatypes.  These corresponds to the
 * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.
 */
export enum IndexDatatype {
  /**
   * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type
   * of an element in <code>Uint8Array</code>.
   */
  UNSIGNED_BYTE = WebGLConstants.UNSIGNED_BYTE,
  /**
   * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type
   * of an element in <code>Uint16Array</code>.
   */
  UNSIGNED_SHORT = WebGLConstants.UNSIGNED_SHORT,
  /**
   * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type
   * of an element in <code>Uint32Array</code>.
   */
  UNSIGNED_INT = WebGLConstants.UNSIGNED_INT
}

export namespace InterpolationAlgorithm {
  /**
   * Gets the name of this interpolation algorithm.
   */
  var type: string;
  /**
   * Given the desired degree, returns the number of data points required for interpolation.
   * @param degree - The desired degree of interpolation.
   * @returns The number of required data points needed for the desired degree of interpolation.
   */
  function getRequiredDataPoints(degree: number): number;
  /**
   * Performs zero order interpolation.
   * @param x - The independent variable for which the dependent variables will be interpolated.
   * @param xTable - The array of independent variables to use to interpolate.  The values
   * in this array must be in increasing order and the same value must not occur twice in the array.
   * @param yTable - The array of dependent variables to use to interpolate.  For a set of three
   * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
   * @param yStride - The number of dependent variable values in yTable corresponding to
   * each independent variable value in xTable.
   * @param [result] - An existing array into which to store the result.
   * @returns The array of interpolated values, or the result parameter if one was provided.
   */
  function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];
  /**
   * Performs higher order interpolation.  Not all interpolators need to support high-order interpolation,
   * if this function remains undefined on implementing objects, interpolateOrderZero will be used instead.
   * @param x - The independent variable for which the dependent variables will be interpolated.
   * @param xTable - The array of independent variables to use to interpolate.  The values
   * in this array must be in increasing order and the same value must not occur twice in the array.
   * @param yTable - The array of dependent variables to use to interpolate.  For a set of three
   * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
   * @param yStride - The number of dependent variable values in yTable corresponding to
   * each independent variable value in xTable.
   * @param inputOrder - The number of derivatives supplied for input.
   * @param outputOrder - The number of derivatives desired for output.
   * @param [result] - An existing array into which to store the result.
   * @returns The array of interpolated values, or the result parameter if one was provided.
   */
  function interpolate(x: number, xTable: number[], yTable: number[], yStride: number, inputOrder: number, outputOrder: number, result?: number[]): number[];
}

/**
* The interface for interpolation algorithms.
*/
export interface InterpolationAlgorithm {
}

/**
* This enumerated type is used in determining where, relative to the frustum, an
* object is located. The object can either be fully contained within the frustum (INSIDE),
* partially inside the frustum and partially outside (INTERSECTING), or somewhere entirely
* outside of the frustum's 6 planes (OUTSIDE).
*/
export enum Intersect {
  /**
   * Represents that an object is not contained within the frustum.
   */
  OUTSIDE = -1,
  /**
   * Represents that an object intersects one of the frustum's planes.
   */
  INTERSECTING = 0,
  /**
   * Represents that an object is fully within the frustum.
   */
  INSIDE = 1
}

/**
* Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.
*/
export namespace IntersectionTests {
  /**
   * Computes the intersection of a ray and a plane.
   * @param ray - The ray.
   * @param plane - The plane.
   * @param [result] - The object onto which to store the result.
   * @returns The intersection point or undefined if there is no intersections.
   */
  function rayPlane(ray: Ray, plane: Plane, result?: Cartesian3): Cartesian3;
  /**
   * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.
   *
   * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|
   * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.
   * @param ray - The ray.
   * @param p0 - The first vertex of the triangle.
   * @param p1 - The second vertex of the triangle.
   * @param p2 - The third vertex of the triangle.
   * @param [cullBackFaces = false] - If <code>true</code>, will only compute an intersection with the front face of the triangle
   *                  and return undefined for intersections with the back face.
   * @returns The intersection as a parametric distance along the ray, or undefined if there is no intersection.
   */
  function rayTriangleParametric(ray: Ray, p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, cullBackFaces?: boolean): number;
  /**
   * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.
   *
   * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|
   * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.
   * @param ray - The ray.
   * @param p0 - The first vertex of the triangle.
   * @param p1 - The second vertex of the triangle.
   * @param p2 - The third vertex of the triangle.
   * @param [cullBackFaces = false] - If <code>true</code>, will only compute an intersection with the front face of the triangle
   *                  and return undefined for intersections with the back face.
   * @param [result] - The <code>Cartesian3</code> onto which to store the result.
   * @returns The intersection point or undefined if there is no intersections.
   */
  function rayTriangle(ray: Ray, p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, cullBackFaces?: boolean, result?: Cartesian3): Cartesian3;
  /**
   * Computes the intersection of a line segment and a triangle.
   * @param v0 - The an end point of the line segment.
   * @param v1 - The other end point of the line segment.
   * @param p0 - The first vertex of the triangle.
   * @param p1 - The second vertex of the triangle.
   * @param p2 - The third vertex of the triangle.
   * @param [cullBackFaces = false] - If <code>true</code>, will only compute an intersection with the front face of the triangle
   *                  and return undefined for intersections with the back face.
   * @param [result] - The <code>Cartesian3</code> onto which to store the result.
   * @returns The intersection point or undefined if there is no intersections.
   */
  function lineSegmentTriangle(v0: Cartesian3, v1: Cartesian3, p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, cullBackFaces?: boolean, result?: Cartesian3): Cartesian3;
  /**
   * Computes the intersection points of a ray with a sphere.
   * @param ray - The ray.
   * @param sphere - The sphere.
   * @param [result] - The result onto which to store the result.
   * @returns The interval containing scalar points along the ray or undefined if there are no intersections.
   */
  function raySphere(ray: Ray, sphere: BoundingSphere, result?: Interval): Interval;
  /**
   * Computes the intersection points of a line segment with a sphere.
   * @param p0 - An end point of the line segment.
   * @param p1 - The other end point of the line segment.
   * @param sphere - The sphere.
   * @param [result] - The result onto which to store the result.
   * @returns The interval containing scalar points along the ray or undefined if there are no intersections.
   */
  function lineSegmentSphere(p0: Cartesian3, p1: Cartesian3, sphere: BoundingSphere, result?: Interval): Interval;
  /**
   * Computes the intersection points of a ray with an ellipsoid.
   * @param ray - The ray.
   * @param ellipsoid - The ellipsoid.
   * @returns The interval containing scalar points along the ray or undefined if there are no intersections.
   */
  function rayEllipsoid(ray: Ray, ellipsoid: Ellipsoid): Interval;
  /**
   * Provides the point along the ray which is nearest to the ellipsoid.
   * @param ray - The ray.
   * @param ellipsoid - The ellipsoid.
   * @returns The nearest planetodetic point on the ray.
   */
  function grazingAltitudeLocation(ray: Ray, ellipsoid: Ellipsoid): Cartesian3;
  /**
   * Computes the intersection of a line segment and a plane.
   * @example
   * const origin = SuperMap.Cartesian3.fromDegrees(-75.59777, 40.03883);
   * const normal = ellipsoid.geodeticSurfaceNormal(origin);
   * const plane = SuperMap.Plane.fromPointNormal(origin, normal);
   *
   * const p0 = new SuperMap.Cartesian3(...);
   * const p1 = new SuperMap.Cartesian3(...);
   *
   * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.
   * const intersection = SuperMap.IntersectionTests.lineSegmentPlane(p0, p1, plane);
   * @param endPoint0 - An end point of the line segment.
   * @param endPoint1 - The other end point of the line segment.
   * @param plane - The plane.
   * @param [result] - The object onto which to store the result.
   * @returns The intersection point or undefined if there is no intersection.
   */
  function lineSegmentPlane(endPoint0: Cartesian3, endPoint1: Cartesian3, plane: Plane, result?: Cartesian3): Cartesian3;
  /**
   * Computes the intersection of a triangle and a plane
   * @example
   * const origin = SuperMap.Cartesian3.fromDegrees(-75.59777, 40.03883);
   * const normal = ellipsoid.geodeticSurfaceNormal(origin);
   * const plane = SuperMap.Plane.fromPointNormal(origin, normal);
   *
   * const p0 = new SuperMap.Cartesian3(...);
   * const p1 = new SuperMap.Cartesian3(...);
   * const p2 = new SuperMap.Cartesian3(...);
   *
   * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane
   * const triangles = SuperMap.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);
   * @param p0 - First point of the triangle
   * @param p1 - Second point of the triangle
   * @param p2 - Third point of the triangle
   * @param plane - Intersection plane
   * @returns An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)
   */
  function trianglePlaneIntersection(p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, plane: Plane): any;
}

/**
* Contains functions for operating on 2D triangles.
*/
export namespace Intersections2D {
  /**
   * Splits a 2D triangle at given axis-aligned threshold value and returns the resulting
   * polygon on a given side of the threshold.  The resulting polygon may have 0, 1, 2,
   * 3, or 4 vertices.
   * @example
   * const result = SuperMap.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);
   * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]
   * @param threshold - The threshold coordinate value at which to clip the triangle.
   * @param keepAbove - true to keep the portion of the triangle above the threshold, or false
   *                            to keep the portion below.
   * @param u0 - The coordinate of the first vertex in the triangle, in counter-clockwise order.
   * @param u1 - The coordinate of the second vertex in the triangle, in counter-clockwise order.
   * @param u2 - The coordinate of the third vertex in the triangle, in counter-clockwise order.
   * @param [result] - The array into which to copy the result.  If this parameter is not supplied,
   *                            a new array is constructed and returned.
   * @returns The polygon that results after the clip, specified as a list of
   *                     vertices.  The vertices are specified in counter-clockwise order.
   *                     Each vertex is either an index from the existing list (identified as
   *                     a 0, 1, or 2) or -1 indicating a new vertex not in the original triangle.
   *                     For new vertices, the -1 is followed by three additional numbers: the
   *                     index of each of the two original vertices forming the line segment that
   *                     the new vertex lies on, and the fraction of the distance from the first
   *                     vertex to the second one.
   */
  function clipTriangleAtAxisAlignedThreshold(threshold: number, keepAbove: boolean, u0: number, u1: number, u2: number, result?: number[]): number[];
  /**
   * Compute the barycentric coordinates of a 2D position within a 2D triangle.
   * @example
   * const result = SuperMap.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);
   * // result === new SuperMap.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);
   * @param x - The x coordinate of the position for which to find the barycentric coordinates.
   * @param y - The y coordinate of the position for which to find the barycentric coordinates.
   * @param x1 - The x coordinate of the triangle's first vertex.
   * @param y1 - The y coordinate of the triangle's first vertex.
   * @param x2 - The x coordinate of the triangle's second vertex.
   * @param y2 - The y coordinate of the triangle's second vertex.
   * @param x3 - The x coordinate of the triangle's third vertex.
   * @param y3 - The y coordinate of the triangle's third vertex.
   * @param [result] - The instance into to which to copy the result.  If this parameter
   *                     is undefined, a new instance is created and returned.
   * @returns The barycentric coordinates of the position within the triangle.
   */
  function computeBarycentricCoordinates(x: number, y: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, result?: Cartesian3): Cartesian3;
  /**
   * Compute the intersection between 2 line segments
   * @example
   * const result = SuperMap.Intersections2D.computeLineSegmentLineSegmentIntersection(0.0, 0.0, 0.0, 2.0, -1, 1, 1, 1);
   * // result === new SuperMap.Cartesian2(0.0, 1.0);
   * @param x00 - The x coordinate of the first line's first vertex.
   * @param y00 - The y coordinate of the first line's first vertex.
   * @param x01 - The x coordinate of the first line's second vertex.
   * @param y01 - The y coordinate of the first line's second vertex.
   * @param x10 - The x coordinate of the second line's first vertex.
   * @param y10 - The y coordinate of the second line's first vertex.
   * @param x11 - The x coordinate of the second line's second vertex.
   * @param y11 - The y coordinate of the second line's second vertex.
   * @param [result] - The instance into to which to copy the result. If this parameter
   *                     is undefined, a new instance is created and returned.
   * @returns The intersection point, undefined if there is no intersection point or lines are coincident.
   */
  function computeLineSegmentLineSegmentIntersection(x00: number, y00: number, x01: number, y01: number, x10: number, y10: number, x11: number, y11: number, result?: Cartesian2): Cartesian2;
}

/**
* Represents the closed interval [start, stop].
* @param [start = 0.0] - The beginning of the interval.
* @param [stop = 0.0] - The end of the interval.
*/
export class Interval {
  constructor(start?: number, stop?: number);
  /**
   * The beginning of the interval.
   */
  start: number;
  /**
   * The end of the interval.
   */
  stop: number;
}
/**
 * Constants related to ISO8601 support.
 */
export namespace Iso8601 {
  /**
   * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.
   * This is equivalent to the date string '0000-01-01T00:00:00Z'
   */
  const MINIMUM_VALUE: JulianDate;
  /**
   * A {@link JulianDate} representing the latest time representable by an ISO8601 date.
   * This is equivalent to the date string '9999-12-31T24:00:00Z'
   */
  const MAXIMUM_VALUE: JulianDate;
  /**
   * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.
   * This is equivalent to the interval string '0000-01-01T00:00:00Z/9999-12-31T24:00:00Z'
   */
  const MAXIMUM_INTERVAL: TimeInterval;
}

/**
* Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).
* For increased precision, this class stores the whole number part of the date and the seconds
* part of the date in separate components.  In order to be safe for arithmetic and represent
* leap seconds, the date is always stored in the International Atomic Time standard
* {@link TimeStandard.TAI}.
* @param [julianDayNumber = 0.0] - The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.
* @param [secondsOfDay = 0.0] - The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.
* @param [timeStandard = TimeStandard.UTC] - The time standard in which the first two parameters are defined.
*/
export class JulianDate {
  constructor(julianDayNumber?: number, secondsOfDay?: number, timeStandard?: TimeStandard);
  /**
   * Gets or sets the number of whole days.
   */
  dayNumber: number;
  /**
   * Gets or sets the number of seconds into the current day.
   */
  secondsOfDay: number;
  /**
   * Creates a new instance from a GregorianDate.
   * @param date - A GregorianDate.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  fromGregorianDate(date: GregorianDate, result?: JulianDate): JulianDate;
  /**
   * Creates a new instance from a JavaScript Date.
   * @param date - A JavaScript Date.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  fromDate(date: Date, result?: JulianDate): JulianDate;
  /**
   * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.
   * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601
   * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.
   * @param iso8601String - An ISO 8601 date.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  fromIso8601(iso8601String: string, result?: JulianDate): JulianDate;
  /**
   * Creates a new instance that represents the current system time.
   * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  now(result?: JulianDate): JulianDate;
  /**
   * Creates a {@link GregorianDate} from the provided instance.
   * @param julianDate - The date to be converted.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  toGregorianDate(julianDate: JulianDate, result?: GregorianDate): GregorianDate;
  /**
   * Creates a JavaScript Date from the provided instance.
   * Since JavaScript dates are only accurate to the nearest millisecond and
   * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.
   * If the provided JulianDate is during a leap second, the previous second is used.
   * @param julianDate - The date to be converted.
   * @returns A new instance representing the provided date.
   */
  toDate(julianDate: JulianDate): Date;
  /**
   * Creates an ISO8601 representation of the provided date.
   * @param julianDate - The date to be converted.
   * @param [precision] - The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
   * @returns The ISO8601 representation of the provided date.
   */
  toIso8601(julianDate: JulianDate, precision?: number): string;
  /**
   * Duplicates a JulianDate instance.
   * @param julianDate - The date to duplicate.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.
   */
  clone(julianDate: JulianDate, result?: JulianDate): JulianDate;
  /**
   * Compares two instances.
   * @param left - The first instance.
   * @param right - The second instance.
   * @returns A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.
   */
  compare(left: JulianDate, right: JulianDate): number;
  /**
   * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [left] - The first instance.
   * @param [right] - The second instance.
   * @returns <code>true</code> if the dates are equal; otherwise, <code>false</code>.
   */
  equals(left?: JulianDate, right?: JulianDate): boolean;
  /**
   * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
   * each other.  That is, in order for the dates to be considered equal (and for
   * this function to return <code>true</code>), the absolute value of the difference between them, in
   * seconds, must be less than <code>epsilon</code>.
   * @param [left] - The first instance.
   * @param [right] - The second instance.
   * @param [epsilon = 0] - The maximum number of seconds that should separate the two instances.
   * @returns <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
   */
  equalsEpsilon(left?: JulianDate, right?: JulianDate, epsilon?: number): boolean;
  /**
   * Computes the total number of whole and fractional days represented by the provided instance.
   * @param julianDate - The date.
   * @returns The Julian date as single floating point number.
   */
  totalDays(julianDate: JulianDate): number;
  /**
   * Computes the difference in seconds between the provided instance.
   * @param left - The first instance.
   * @param right - The second instance.
   * @returns The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.
   */
  secondsDifference(left: JulianDate, right: JulianDate): number;
  /**
   * Computes the difference in days between the provided instance.
   * @param left - The first instance.
   * @param right - The second instance.
   * @returns The difference, in days, when subtracting <code>right</code> from <code>left</code>.
   */
  daysDifference(left: JulianDate, right: JulianDate): number;
  /**
   * Computes the number of seconds the provided instance is ahead of UTC.
   * @param julianDate - The date.
   * @returns The number of seconds the provided instance is ahead of UTC
   */
  computeTaiMinusUtc(julianDate: JulianDate): number;
  /**
   * Adds the provided number of seconds to the provided date instance.
   * @param julianDate - The date.
   * @param seconds - The number of seconds to add or subtract.
   * @param result - An existing instance to use for the result.
   * @returns The modified result parameter.
   */
  addSeconds(julianDate: JulianDate, seconds: number, result: JulianDate): JulianDate;
  /**
   * Adds the provided number of minutes to the provided date instance.
   * @param julianDate - The date.
   * @param minutes - The number of minutes to add or subtract.
   * @param result - An existing instance to use for the result.
   * @returns The modified result parameter.
   */
  addMinutes(julianDate: JulianDate, minutes: number, result: JulianDate): JulianDate;
  /**
   * Adds the provided number of hours to the provided date instance.
   * @param julianDate - The date.
   * @param hours - The number of hours to add or subtract.
   * @param result - An existing instance to use for the result.
   * @returns The modified result parameter.
   */
  addHours(julianDate: JulianDate, hours: number, result: JulianDate): JulianDate;
  /**
   * Adds the provided number of days to the provided date instance.
   * @param julianDate - The date.
   * @param days - The number of days to add or subtract.
   * @param result - An existing instance to use for the result.
   * @returns The modified result parameter.
   */
  addDays(julianDate: JulianDate, days: number, result: JulianDate): JulianDate;
  /**
   * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
   * @param left - The first instance.
   * @param right - The second instance.
   * @returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
   */
  lessThan(left: JulianDate, right: JulianDate): boolean;
  /**
   * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
   * @param left - The first instance.
   * @param right - The second instance.
   * @returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
   */
  lessThanOrEquals(left: JulianDate, right: JulianDate): boolean;
  /**
   * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
   * @param left - The first instance.
   * @param right - The second instance.
   * @returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
   */
  greaterThan(left: JulianDate, right: JulianDate): boolean;
  /**
   * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
   * @param left - The first instance.
   * @param right - The second instance.
   * @returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
   */
  greaterThanOrEquals(left: JulianDate, right: JulianDate): boolean;
  /**
   * Duplicates this instance.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  clone(result?: JulianDate): JulianDate;
  /**
   * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The second instance.
   * @returns <code>true</code> if the dates are equal; otherwise, <code>false</code>.
   */
  equals(right?: JulianDate): boolean;
  /**
   * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of
   * each other.  That is, in order for the dates to be considered equal (and for
   * this function to return <code>true</code>), the absolute value of the difference between them, in
   * seconds, must be less than <code>epsilon</code>.
   * @param [right] - The second instance.
   * @param [epsilon = 0] - The maximum number of seconds that should separate the two instances.
   * @returns <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
   */
  equalsEpsilon(right?: JulianDate, epsilon?: number): boolean;
  /**
   * Creates a string representing this date in ISO8601 format.
   * @returns A string representing this date in ISO8601 format.
   */
  toString(): string;
  /**
   * Gets or sets the list of leap seconds used throughout SuperMap.
   */
  leapSeconds: LeapSecond[];
}

/**
* This enumerated type is for representing keyboard modifiers. These are keys
* that are held down in addition to other event types.
*/
export enum KeyboardEventModifier {
  /**
   * Represents the shift key being held down.
   */
  SHIFT = 0,
  /**
   * Represents the control key being held down.
   */
  CTRL = 1,
  /**
   * Represents the alt key being held down.
   */
  ALT = 2
}

/**
* An {@link InterpolationAlgorithm} for performing Lagrange interpolation.
*/
export namespace LagrangePolynomialApproximation {
  /**
   * Given the desired degree, returns the number of data points required for interpolation.
   * @param degree - The desired degree of interpolation.
   * @returns The number of required data points needed for the desired degree of interpolation.
   */
  function getRequiredDataPoints(degree: number): number;
  /**
   * Interpolates values using Lagrange Polynomial Approximation.
   * @param x - The independent variable for which the dependent variables will be interpolated.
   * @param xTable - The array of independent variables to use to interpolate.  The values
   * in this array must be in increasing order and the same value must not occur twice in the array.
   * @param yTable - The array of dependent variables to use to interpolate.  For a set of three
   * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
   * @param yStride - The number of dependent variable values in yTable corresponding to
   * each independent variable value in xTable.
   * @param [result] - An existing array into which to store the result.
   * @returns The array of interpolated values, or the result parameter if one was provided.
   */
  function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];
}

/**
* Describes a single leap second, which is constructed from a {@link JulianDate} and a
* numerical offset representing the number of seconds TAI is ahead of the UTC time standard.
* @param [date] - A Julian date representing the time of the leap second.
* @param [offset] - The cumulative number of seconds that TAI is ahead of UTC at the provided date.
*/
export class LeapSecond {
  constructor(date?: JulianDate, offset?: number);
  /**
   * Gets or sets the date at which this leap second occurs.
   */
  julianDate: JulianDate;
  /**
   * Gets or sets the cumulative number of seconds between the UTC and TAI time standards at the time
   * of this leap second.
   */
  offset: number;
}

/**
* An {@link InterpolationAlgorithm} for performing linear interpolation.
*/
export namespace LinearApproximation {
  /**
   * Given the desired degree, returns the number of data points required for interpolation.
   * Since linear interpolation can only generate a first degree polynomial, this function
   * always returns 2.
   * @param degree - The desired degree of interpolation.
   * @returns This function always returns 2.
   */
  function getRequiredDataPoints(degree: number): number;
  /**
   * Interpolates values using linear approximation.
   * @param x - The independent variable for which the dependent variables will be interpolated.
   * @param xTable - The array of independent variables to use to interpolate.  The values
   * in this array must be in increasing order and the same value must not occur twice in the array.
   * @param yTable - The array of dependent variables to use to interpolate.  For a set of three
   * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
   * @param yStride - The number of dependent variable values in yTable corresponding to
   * each independent variable value in xTable.
   * @param [result] - An existing array into which to store the result.
   * @returns The array of interpolated values, or the result parameter if one was provided.
   */
  function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];
}

/**
* A spline that uses piecewise linear interpolation to create a curve.
* @example
* const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];
* const spline = new SuperMap.LinearSpline({
*     times : times,
*     points : [
*         new SuperMap.Cartesian3(1235398.0, -4810983.0, 4146266.0),
*         new SuperMap.Cartesian3(1372574.0, -5345182.0, 4606657.0),
*         new SuperMap.Cartesian3(-757983.0, -5542796.0, 4514323.0),
*         new SuperMap.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
*         new SuperMap.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
*     ]
* });
*
* const p0 = spline.evaluate(times[0]);
* @param options - Object with the following properties:
* @param options.times - An array of strictly increasing, unit-less, floating-point times at each point.
*                The values are in no way connected to the clock time. They are the parameterization for the curve.
* @param options.points - The array of control points.
*/
export class LinearSpline {
  constructor(options: {
    times: number[];
    points: number[] | Cartesian3[];
  });
  /**
   * An array of times for the control points.
   */
  readonly times: number[];
  /**
   * An array of {@link Cartesian3} control points.
   */
  readonly points: number[] | Cartesian3[];
  /**
   * Finds an index <code>i</code> in <code>times</code> such that the parameter
   * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
   * @param time - The time.
   * @returns The index for the element at the start of the interval.
   */
  findTimeInterval(time: number): number;
  /**
   * Wraps the given time to the period covered by the spline.
   * @param time - The time.
   * @returns The time, wrapped around to the updated animation.
   */
  wrapTime(time: number): number;
  /**
   * Clamps the given time to the period covered by the spline.
   * @param time - The time.
   * @returns The time, clamped to the animation period.
   */
  clampTime(time: number): number;
  /**
   * Evaluates the curve at a given time.
   * @param time - The time at which to evaluate the curve.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new instance of the point on the curve at the given time.
   */
  evaluate(time: number, result?: Cartesian3): number | Cartesian3;
}

/**
* Defines how geodetic ellipsoid coordinates ({@link Cartographic}) project to a
* flat map like SuperMap's 2D and Columbus View modes.
*/
export class MapProjection {
  constructor();
  /**
   * Gets the {@link Ellipsoid}.
   */
  readonly ellipsoid: Ellipsoid;
  /**
   * Projects {@link Cartographic} coordinates, in radians, to projection-specific map coordinates, in meters.
   * @param cartographic - The coordinates to project.
   * @param [result] - An instance into which to copy the result.  If this parameter is
   *        undefined, a new instance is created and returned.
   * @returns The projected coordinates.  If the result parameter is not undefined, the
   *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
   *          created and returned.
   */
  project(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
  /**
   * Unprojects projection-specific map {@link Cartesian3} coordinates, in meters, to {@link Cartographic}
   * coordinates, in radians.
   * @param cartesian - The Cartesian position to unproject with height (z) in meters.
   * @param [result] - An instance into which to copy the result.  If this parameter is
   *        undefined, a new instance is created and returned.
   * @returns The unprojected coordinates.  If the result parameter is not undefined, the
   *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
   *          created and returned.
   */
  unproject(cartesian: Cartesian3, result?: Cartographic): Cartographic;
}

/**
 * Math functions.
 */
export namespace Math {
  /**
   * 0.1
   */
  const EPSILON1 = 0.1;
  /**
   * 0.01
   */
  const EPSILON2 = 0.01;
  /**
   * 0.001
   */
  const EPSILON3 = 0.001;
  /**
   * 0.0001
   */
  const EPSILON4 = 0.0001;
  /**
   * 0.00001
   */
  const EPSILON5 = 0.00001;
  /**
   * 0.000001
   */
  const EPSILON6 = 0.000001;
  /**
   * 0.0000001
   */
  const EPSILON7 = 1e-7;
  /**
   * 0.00000001
   */
  const EPSILON8 = 1e-8;
  /**
   * 0.000000001
   */
  const EPSILON9 = 1e-9;
  /**
   * 0.0000000001
   */
  const EPSILON10 = 1e-10;
  /**
   * 0.00000000001
   */
  const EPSILON11 = 1e-11;
  /**
   * 0.000000000001
   */
  const EPSILON12 = 1e-12;
  /**
   * 0.0000000000001
   */
  const EPSILON13 = 1e-13;
  /**
   * 0.00000000000001
   */
  const EPSILON14 = 1e-14;
  /**
   * 0.000000000000001
   */
  const EPSILON15 = 1e-15;
  /**
   * 0.0000000000000001
   */
  const EPSILON16 = 1e-16;
  /**
   * 0.00000000000000001
   */
  const EPSILON17 = 1e-17;
  /**
   * 0.000000000000000001
   */
  const EPSILON18 = 1e-18;
  /**
   * 0.0000000000000000001
   */
  const EPSILON19 = 1e-19;
  /**
   * 0.00000000000000000001
   */
  const EPSILON20 = 1e-20;
  /**
   * 0.000000000000000000001
   */
  const EPSILON21 = 1e-21;
  /**
   * The gravitational parameter of the Earth in meters cubed
   * per second squared as defined by the WGS84 model: 3.986004418e14
   */
  const GRAVITATIONALPARAMETER = 398600441800000;
  /**
   * Radius of the sun in meters: 6.955e8
   */
  const SOLAR_RADIUS = 695500000;
  /**
   * The mean radius of the moon, according to the "Report of the IAU/IAG Working Group on
   * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000",
   * Celestial Mechanics 82: 83-110, 2002.
   */
  const LUNAR_RADIUS = 1737400;
  /**
   * 64 * 1024
   */
  const SIXTY_FOUR_KILOBYTES: number;
  /**
   * 4 * 1024 * 1024 * 1024
   */
  const FOUR_GIGABYTES: number;
  /**
   * Returns the sign of the value; 1 if the value is positive, -1 if the value is
   * negative, or 0 if the value is 0.
   * @param value - The value to return the sign of.
   * @returns The sign of value.
   */
  function sign(value: number): number;
  /**
   * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.
   * This is similar to {@link Math#sign} except that returns 1.0 instead of
   * 0.0 when the input value is 0.0.
   * @param value - The value to return the sign of.
   * @returns The sign of value.
   */
  function signNotZero(value: number): number;
  /**
   * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]
   * @param value - The scalar value in the range [-1.0, 1.0]
   * @param [rangeMaximum = 255] - The maximum value in the mapped range, 255 by default.
   * @returns A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.
   */
  function toSNorm(value: number, rangeMaximum?: number): number;
  /**
   * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].
   * @param value - SNORM value in the range [0, rangeMaximum]
   * @param [rangeMaximum = 255] - The maximum value in the SNORM range, 255 by default.
   * @returns Scalar in the range [-1.0, 1.0].
   */
  function fromSNorm(value: number, rangeMaximum?: number): number;
  /**
   * Converts a scalar value in the range [rangeMinimum, rangeMaximum] to a scalar in the range [0.0, 1.0]
   * @param value - The scalar value in the range [rangeMinimum, rangeMaximum]
   * @param rangeMinimum - The minimum value in the mapped range.
   * @param rangeMaximum - The maximum value in the mapped range.
   * @returns A scalar value, where rangeMinimum maps to 0.0 and rangeMaximum maps to 1.0.
   */
  function normalize(value: number, rangeMinimum: number, rangeMaximum: number): number;
  /**
   * Returns the hyperbolic sine of a number.
   * The hyperbolic sine of <em>value</em> is defined to be
   * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0
   * where <i>e</i> is Euler's number, approximately 2.71828183.
   *
   * <p>Special cases:
   *   <ul>
   *     <li>If the argument is NaN, then the result is NaN.</li>
   *
   *     <li>If the argument is infinite, then the result is an infinity
   *     with the same sign as the argument.</li>
   *
   *     <li>If the argument is zero, then the result is a zero with the
   *     same sign as the argument.</li>
   *   </ul>
   * </p>
   * @param value - The number whose hyperbolic sine is to be returned.
   * @returns The hyperbolic sine of <code>value</code>.
   */
  function sinh(value: number): number;
  /**
   * Returns the hyperbolic cosine of a number.
   * The hyperbolic cosine of <strong>value</strong> is defined to be
   * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0
   * where <i>e</i> is Euler's number, approximately 2.71828183.
   *
   * <p>Special cases:
   *   <ul>
   *     <li>If the argument is NaN, then the result is NaN.</li>
   *
   *     <li>If the argument is infinite, then the result is positive infinity.</li>
   *
   *     <li>If the argument is zero, then the result is 1.0.</li>
   *   </ul>
   * </p>
   * @param value - The number whose hyperbolic cosine is to be returned.
   * @returns The hyperbolic cosine of <code>value</code>.
   */
  function cosh(value: number): number;
  /**
   * Computes the linear interpolation of two values.
   * @example
   * const n = SuperMap.Math.lerp(0.0, 2.0, 0.5); // returns 1.0
   * @param p - The start value to interpolate.
   * @param q - The end value to interpolate.
   * @param time - The time of interpolation generally in the range <code>[0.0, 1.0]</code>.
   * @returns The linearly interpolated value.
   */
  function lerp(p: number, q: number, time: number): number;
  /**
   * pi
   */
  const PI: number;
  /**
   * 1/pi
   */
  const ONE_OVER_PI: number;
  /**
   * pi/2
   */
  const PI_OVER_TWO: number;
  /**
   * pi/3
   */
  const PI_OVER_THREE: number;
  /**
   * pi/4
   */
  const PI_OVER_FOUR: number;
  /**
   * pi/6
   */
  const PI_OVER_SIX: number;
  /**
   * 3pi/2
   */
  const THREE_PI_OVER_TWO: number;
  /**
   * 2pi
   */
  const TWO_PI: number;
  /**
   * 1/2pi
   */
  const ONE_OVER_TWO_PI: number;
  /**
   * The number of radians in a degree.
   */
  const RADIANS_PER_DEGREE: number;
  /**
   * The number of degrees in a radian.
   */
  const DEGREES_PER_RADIAN: number;
  /**
   * The number of radians in an arc second.
   */
  const RADIANS_PER_ARCSECOND: number;
  /**
   * Converts degrees to radians.
   * @param degrees - The angle to convert in degrees.
   * @returns The corresponding angle in radians.
   */
  function toRadians(degrees: number): number;
  /**
   * Converts radians to degrees.
   * @param radians - The angle to convert in radians.
   * @returns The corresponding angle in degrees.
   */
  function toDegrees(radians: number): number;
  /**
   * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
   * @example
   * // Convert 270 degrees to -90 degrees longitude
   * const longitude = SuperMap.Math.convertLongitudeRange(SuperMap.Math.toRadians(270.0));
   * @param angle - The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
   * @returns The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).
   */
  function convertLongitudeRange(angle: number): number;
  /**
   * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
   * Useful for sanitizing data before use in objects requiring correct range.
   * @example
   * // Clamp 108 degrees latitude to 90 degrees latitude
   * const latitude = SuperMap.Math.clampToLatitudeRange(SuperMap.Math.toRadians(108.0));
   * @param angle - The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
   * @returns The latitude value clamped to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
   */
  function clampToLatitudeRange(angle: number): number;
  /**
   * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.
   * @param angle - in radians
   * @returns The angle in the range [<code>-Math.PI</code>, <code>Math.PI</code>].
   */
  function negativePiToPi(angle: number): number;
  /**
   * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.
   * @param angle - in radians
   * @returns The angle in the range [0, <code>Math.TWO_PI</code>].
   */
  function zeroToTwoPi(angle: number): number;
  /**
   * The modulo operation that also works for negative dividends.
   * @param m - The dividend.
   * @param n - The divisor.
   * @returns The remainder.
   */
  function mod(m: number, n: number): number;
  /**
   * Determines if two values are equal using an absolute or relative tolerance test. This is useful
   * to avoid problems due to roundoff error when comparing floating-point values directly. The values are
   * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.
   * Use this test if you are unsure of the magnitudes of left and right.
   * @example
   * const a = SuperMap.Math.equalsEpsilon(0.0, 0.01, SuperMap.Math.EPSILON2); // true
   * const b = SuperMap.Math.equalsEpsilon(0.0, 0.1, SuperMap.Math.EPSILON2);  // false
   * const c = SuperMap.Math.equalsEpsilon(3699175.1634344, 3699175.2, SuperMap.Math.EPSILON7); // true
   * const d = SuperMap.Math.equalsEpsilon(3699175.1634344, 3699175.2, SuperMap.Math.EPSILON9); // false
   * @param left - The first value to compare.
   * @param right - The other value to compare.
   * @param [relativeEpsilon = 0] - The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.
   * @param [absoluteEpsilon = relativeEpsilon] - The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.
   * @returns <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.
   */
  function equalsEpsilon(left: number, right: number, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
  /**
   * Determines if the left value is less than the right value. If the two values are within
   * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.
   * @param left - The first number to compare.
   * @param right - The second number to compare.
   * @param absoluteEpsilon - The absolute epsilon to use in comparison.
   * @returns <code>true</code> if <code>left</code> is less than <code>right</code> by more than
   *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is greater or if the two
   *          values are nearly equal.
   */
  function lessThan(left: number, right: number, absoluteEpsilon: number): boolean;
  /**
   * Determines if the left value is less than or equal to the right value. If the two values are within
   * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.
   * @param left - The first number to compare.
   * @param right - The second number to compare.
   * @param absoluteEpsilon - The absolute epsilon to use in comparison.
   * @returns <code>true</code> if <code>left</code> is less than <code>right</code> or if the
   *          the values are nearly equal.
   */
  function lessThanOrEquals(left: number, right: number, absoluteEpsilon: number): boolean;
  /**
   * Determines if the left value is greater the right value. If the two values are within
   * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.
   * @param left - The first number to compare.
   * @param right - The second number to compare.
   * @param absoluteEpsilon - The absolute epsilon to use in comparison.
   * @returns <code>true</code> if <code>left</code> is greater than <code>right</code> by more than
   *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is less or if the two
   *          values are nearly equal.
   */
  function greaterThan(left: number, right: number, absoluteEpsilon: number): boolean;
  /**
   * Determines if the left value is greater than or equal to the right value. If the two values are within
   * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.
   * @param left - The first number to compare.
   * @param right - The second number to compare.
   * @param absoluteEpsilon - The absolute epsilon to use in comparison.
   * @returns <code>true</code> if <code>left</code> is greater than <code>right</code> or if the
   *          the values are nearly equal.
   */
  function greaterThanOrEquals(left: number, right: number, absoluteEpsilon: number): boolean;
  /**
   * Computes the factorial of the provided number.
   * @example
   * //Compute 7!, which is equal to 5040
   * const computedFactorial = SuperMap.Math.factorial(7);
   * @param n - The number whose factorial is to be computed.
   * @returns The factorial of the provided number or undefined if the number is less than 0.
   */
  function factorial(n: number): number;
  /**
   * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.
   * @example
   * const n = SuperMap.Math.incrementWrap(5, 10, 0); // returns 6
   * const m = SuperMap.Math.incrementWrap(10, 10, 0); // returns 0
   * @param [n] - The number to be incremented.
   * @param [maximumValue] - The maximum incremented value before rolling over to the minimum value.
   * @param [minimumValue = 0.0] - The number reset to after the maximum value has been exceeded.
   * @returns The incremented number.
   */
  function incrementWrap(n?: number, maximumValue?: number, minimumValue?: number): number;
  /**
   * Determines if a non-negative integer is a power of two.
   * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.
   * @example
   * const t = SuperMap.Math.isPowerOfTwo(16); // true
   * const f = SuperMap.Math.isPowerOfTwo(20); // false
   * @param n - The integer to test in the range [0, (2^32)-1].
   * @returns <code>true</code> if the number if a power of two; otherwise, <code>false</code>.
   */
  function isPowerOfTwo(n: number): boolean;
  /**
   * Computes the next power-of-two integer greater than or equal to the provided non-negative integer.
   * The maximum allowed input is 2^31 due to 32-bit bitwise operator limitation in Javascript.
   * @example
   * const n = SuperMap.Math.nextPowerOfTwo(29); // 32
   * const m = SuperMap.Math.nextPowerOfTwo(32); // 32
   * @param n - The integer to test in the range [0, 2^31].
   * @returns The next power-of-two integer.
   */
  function nextPowerOfTwo(n: number): number;
  /**
   * Computes the previous power-of-two integer less than or equal to the provided non-negative integer.
   * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.
   * @example
   * const n = SuperMap.Math.previousPowerOfTwo(29); // 16
   * const m = SuperMap.Math.previousPowerOfTwo(32); // 32
   * @param n - The integer to test in the range [0, (2^32)-1].
   * @returns The previous power-of-two integer.
   */
  function previousPowerOfTwo(n: number): number;
  /**
   * Constraint a value to lie between two values.
   * @param value - The value to clamp.
   * @param min - The minimum value.
   * @param max - The maximum value.
   * @returns The clamped value such that min <= result <= max.
   */
  function clamp(value: number, min: number, max: number): number;
  /**
   * Sets the seed used by the random number generator
   * in {@link Math#nextRandomNumber}.
   * @param seed - An integer used as the seed.
   */
  function setRandomNumberSeed(seed: number): void;
  /**
   * Generates a random floating point number in the range of [0.0, 1.0)
   * using a Mersenne twister.
   * @returns A random number in the range of [0.0, 1.0).
   */
  function nextRandomNumber(): number;
  /**
   * Generates a random number between two numbers.
   * @param min - The minimum value.
   * @param max - The maximum value.
   * @returns A random number between the min and max.
   */
  function randomBetween(min: number, max: number): number;
  /**
   * Computes <code>Math.acos(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]
   * so that the function will never return NaN.
   * @param value - The value for which to compute acos.
   * @returns The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,
   *          whichever is closer, if the value is outside the range.
   */
  function acosClamped(value: number): number;
  /**
   * Computes <code>Math.asin(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]
   * so that the function will never return NaN.
   * @param value - The value for which to compute asin.
   * @returns The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,
   *          whichever is closer, if the value is outside the range.
   */
  function asinClamped(value: number): number;
  /**
   * Finds the chord length between two points given the circle's radius and the angle between the points.
   * @param angle - The angle between the two points.
   * @param radius - The radius of the circle.
   * @returns The chord length.
   */
  function chordLength(angle: number, radius: number): number;
  /**
   * Finds the logarithm of a number to a base.
   * @param number - The number.
   * @param base - The base.
   * @returns The result.
   */
  function logBase(number: number, base: number): number;
  /**
   * Finds the cube root of a number.
   * Returns NaN if <code>number</code> is not provided.
   * @param [number] - The number.
   * @returns The result.
   */
  function cbrt(number?: number): number;
  /**
   * Finds the base 2 logarithm of a number.
   * @param number - The number.
   * @returns The result.
   */
  function log2(number: number): number;
  /**
   * Computes a fast approximation of Atan for input in the range [-1, 1].
   *
   * Based on Michal Drobot's approximation from ShaderFastLibs,
   * which in turn is based on "Efficient approximations for the arctangent function,"
   * Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.
   * Adapted from ShaderFastLibs under MIT License.
   * @param x - An input number in the range [-1, 1]
   * @returns An approximation of atan(x)
   */
  function fastApproximateAtan(x: number): number;
  /**
   * Computes a fast approximation of Atan2(x, y) for arbitrary input scalars.
   *
   * Range reduction math based on nvidia's cg reference implementation: http://developer.download.nvidia.com/cg/atan2.html
   * @param x - An input number that isn't zero if y is zero.
   * @param y - An input number that isn't zero if x is zero.
   * @returns An approximation of atan2(x, y)
   */
  function fastApproximateAtan2(x: number, y: number): number;
}

export interface Matrix2 extends ArrayLike<number> {
}

/**
* A 2x2 matrix, indexable as a column-major order array.
* Constructor parameters are in row-major order for code readability.
* @param [column0Row0 = 0.0] - The value for column 0, row 0.
* @param [column1Row0 = 0.0] - The value for column 1, row 0.
* @param [column0Row1 = 0.0] - The value for column 0, row 1.
* @param [column1Row1 = 0.0] - The value for column 1, row 1.
*/
export class Matrix2 implements ArrayLike<number> {
  constructor(column0Row0?: number, column1Row0?: number, column0Row1?: number, column1Row1?: number);
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: Matrix2, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Matrix2 instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: Matrix2): Matrix2;
  /**
   * Flattens an array of Matrix2s into an array of components. The components
   * are stored in column-major order.
   * @param array - The array of matrices to pack.
   * @param [result] - The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.
   * @returns The packed array.
   */
  packArray(array: Matrix2[], result?: number[]): number[];
  /**
   * Unpacks an array of column-major matrix components into an array of Matrix2s.
   * @param array - The array of components to unpack.
   * @param [result] - The array onto which to store the result.
   * @returns The unpacked array.
   */
  unpackArray(array: number[], result?: Matrix2[]): Matrix2[];
  /**
   * Duplicates a Matrix2 instance.
   * @param matrix - The matrix to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)
   */
  clone(matrix: Matrix2, result?: Matrix2): Matrix2;
  /**
   * Creates a Matrix2 from 4 consecutive elements in an array.
   * @example
   * // Create the Matrix2:
   * // [1.0, 2.0]
   * // [1.0, 2.0]
   *
   * const v = [1.0, 1.0, 2.0, 2.0];
   * const m = SuperMap.Matrix2.fromArray(v);
   *
   * // Create same Matrix2 with using an offset into an array
   * const v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];
   * const m2 = SuperMap.Matrix2.fromArray(v2, 2);
   * @param array - The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
   * @param [startingIndex = 0] - The offset into the array of the first element, which corresponds to first column first row position in the matrix.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix2 instance if one was not provided.
   */
  fromArray(array: number[], startingIndex?: number, result?: Matrix2): Matrix2;
  /**
   * Creates a Matrix2 instance from a column-major order array.
   * @param values - The column-major order array.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix2 instance if one was not provided.
   */
  fromColumnMajorArray(values: number[], result?: Matrix2): Matrix2;
  /**
   * Creates a Matrix2 instance from a row-major order array.
   * The resulting matrix will be in column-major order.
   * @param values - The row-major order array.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix2 instance if one was not provided.
   */
  fromRowMajorArray(values: number[], result?: Matrix2): Matrix2;
  /**
   * Computes a Matrix2 instance representing a non-uniform scale.
   * @example
   * // Creates
   * //   [7.0, 0.0]
   * //   [0.0, 8.0]
   * const m = SuperMap.Matrix2.fromScale(new SuperMap.Cartesian2(7.0, 8.0));
   * @param scale - The x and y scale factors.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix2 instance if one was not provided.
   */
  fromScale(scale: Cartesian2, result?: Matrix2): Matrix2;
  /**
   * Computes a Matrix2 instance representing a uniform scale.
   * @example
   * // Creates
   * //   [2.0, 0.0]
   * //   [0.0, 2.0]
   * const m = SuperMap.Matrix2.fromUniformScale(2.0);
   * @param scale - The uniform scale factor.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix2 instance if one was not provided.
   */
  fromUniformScale(scale: number, result?: Matrix2): Matrix2;
  /**
   * Creates a rotation matrix.
   * @example
   * // Rotate a point 45 degrees counterclockwise.
   * const p = new SuperMap.Cartesian2(5, 6);
   * const m = SuperMap.Matrix2.fromRotation(SuperMap.Math.toRadians(45.0));
   * const rotated = SuperMap.Matrix2.multiplyByVector(m, p, new SuperMap.Cartesian2());
   * @param angle - The angle, in radians, of the rotation.  Positive angles are counterclockwise.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix2 instance if one was not provided.
   */
  fromRotation(angle: number, result?: Matrix2): Matrix2;
  /**
   * Creates an Array from the provided Matrix2 instance.
   * The array will be in column-major order.
   * @param matrix - The matrix to use..
   * @param [result] - The Array onto which to store the result.
   * @returns The modified Array parameter or a new Array instance if one was not provided.
   */
  toArray(matrix: Matrix2, result?: number[]): number[];
  /**
   * Computes the array index of the element at the provided row and column.
   * @example
   * const myMatrix = new SuperMap.Matrix2();
   * const column1Row0Index = SuperMap.Matrix2.getElementIndex(1, 0);
   * const column1Row0 = myMatrix[column1Row0Index]
   * myMatrix[column1Row0Index] = 10.0;
   * @param row - The zero-based index of the row.
   * @param column - The zero-based index of the column.
   * @returns The index of the element at the provided row and column.
   */
  getElementIndex(row: number, column: number): number;
  /**
   * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.
   * @param matrix - The matrix to use.
   * @param index - The zero-based index of the column to retrieve.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getColumn(matrix: Matrix2, index: number, result: Cartesian2): Cartesian2;
  /**
   * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.
   * @param matrix - The matrix to use.
   * @param index - The zero-based index of the column to set.
   * @param cartesian - The Cartesian whose values will be assigned to the specified column.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setColumn(matrix: Matrix2, index: number, cartesian: Cartesian2, result: Cartesian2): Matrix2;
  /**
   * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.
   * @param matrix - The matrix to use.
   * @param index - The zero-based index of the row to retrieve.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getRow(matrix: Matrix2, index: number, result: Cartesian2): Cartesian2;
  /**
   * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.
   * @param matrix - The matrix to use.
   * @param index - The zero-based index of the row to set.
   * @param cartesian - The Cartesian whose values will be assigned to the specified row.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setRow(matrix: Matrix2, index: number, cartesian: Cartesian2, result: Matrix2): Matrix2;
  /**
   * Computes a new matrix that replaces the scale with the provided scale.
   * This assumes the matrix is an affine transformation.
   * @param matrix - The matrix to use.
   * @param scale - The scale that replaces the scale of the provided matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setScale(matrix: Matrix2, scale: Cartesian2, result: Matrix2): Matrix2;
  /**
   * Computes a new matrix that replaces the scale with the provided uniform scale.
   * This assumes the matrix is an affine transformation.
   * @param matrix - The matrix to use.
   * @param scale - The uniform scale that replaces the scale of the provided matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setUniformScale(matrix: Matrix2, scale: number, result: Matrix2): Matrix2;
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * @param matrix - The matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getScale(matrix: Matrix2, result: Cartesian2): Cartesian2;
  /**
   * Computes the maximum scale assuming the matrix is an affine transformation.
   * The maximum scale is the maximum length of the column vectors.
   * @param matrix - The matrix.
   * @returns The maximum scale.
   */
  getMaximumScale(matrix: Matrix2): number;
  /**
   * Sets the rotation assuming the matrix is an affine transformation.
   * @param matrix - The matrix.
   * @param rotation - The rotation matrix.
   * @returns The modified result parameter.
   */
  setRotation(matrix: Matrix2, rotation: Matrix2): Matrix2;
  /**
   * Extracts the rotation matrix assuming the matrix is an affine transformation.
   * @param matrix - The matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getRotation(matrix: Matrix2, result: Matrix2): Matrix2;
  /**
   * Computes the product of two matrices.
   * @param left - The first matrix.
   * @param right - The second matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiply(left: Matrix2, right: Matrix2, result: Matrix2): Matrix2;
  /**
   * Computes the sum of two matrices.
   * @param left - The first matrix.
   * @param right - The second matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  add(left: Matrix2, right: Matrix2, result: Matrix2): Matrix2;
  /**
   * Computes the difference of two matrices.
   * @param left - The first matrix.
   * @param right - The second matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  subtract(left: Matrix2, right: Matrix2, result: Matrix2): Matrix2;
  /**
   * Computes the product of a matrix and a column vector.
   * @param matrix - The matrix.
   * @param cartesian - The column.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByVector(matrix: Matrix2, cartesian: Cartesian2, result: Cartesian2): Cartesian2;
  /**
   * Computes the product of a matrix and a scalar.
   * @param matrix - The matrix.
   * @param scalar - The number to multiply by.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByScalar(matrix: Matrix2, scalar: number, result: Matrix2): Matrix2;
  /**
   * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.
   * @example
   * // Instead of SuperMap.Matrix2.multiply(m, SuperMap.Matrix2.fromScale(scale), m);
   * SuperMap.Matrix2.multiplyByScale(m, scale, m);
   * @param matrix - The matrix on the left-hand side.
   * @param scale - The non-uniform scale on the right-hand side.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByScale(matrix: Matrix2, scale: number, result: Matrix2): Matrix2;
  /**
   * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.
   * @example
   * // Instead of SuperMap.Matrix2.multiply(m, SuperMap.Matrix2.fromUniformScale(scale), m);
   * SuperMap.Matrix2.multiplyByUniformScale(m, scale, m);
   * @param matrix - The matrix on the left-hand side.
   * @param scale - The uniform scale on the right-hand side.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByUniformScale(matrix: Matrix2, scale: number, result: Matrix2): Matrix2;
  /**
   * Creates a negated copy of the provided matrix.
   * @param matrix - The matrix to negate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  negate(matrix: Matrix2, result: Matrix2): Matrix2;
  /**
   * Computes the transpose of the provided matrix.
   * @param matrix - The matrix to transpose.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  transpose(matrix: Matrix2, result: Matrix2): Matrix2;
  /**
   * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
   * @param matrix - The matrix with signed elements.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  abs(matrix: Matrix2, result: Matrix2): Matrix2;
  /**
   * Compares the provided matrices componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [left] - The first matrix.
   * @param [right] - The second matrix.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left?: Matrix2, right?: Matrix2): boolean;
  /**
   * Compares the provided matrices componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   * @param [left] - The first matrix.
   * @param [right] - The second matrix.
   * @param [epsilon = 0] - The epsilon to use for equality testing.
   * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(left?: Matrix2, right?: Matrix2, epsilon?: number): boolean;
  /**
   * An immutable Matrix2 instance initialized to the identity matrix.
   */
  readonly IDENTITY: Matrix2;
  /**
   * An immutable Matrix2 instance initialized to the zero matrix.
   */
  readonly ZERO: Matrix2;
  /**
   * The index into Matrix2 for column 0, row 0.
   * @example
   * const matrix = new SuperMap.Matrix2();
   * matrix[SuperMap.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0
   */
  readonly COLUMN0ROW0: number;
  /**
   * The index into Matrix2 for column 0, row 1.
   * @example
   * const matrix = new SuperMap.Matrix2();
   * matrix[SuperMap.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0
   */
  readonly COLUMN0ROW1: number;
  /**
   * The index into Matrix2 for column 1, row 0.
   * @example
   * const matrix = new SuperMap.Matrix2();
   * matrix[SuperMap.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0
   */
  readonly COLUMN1ROW0: number;
  /**
   * The index into Matrix2 for column 1, row 1.
   * @example
   * const matrix = new SuperMap.Matrix2();
   * matrix[SuperMap.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0
   */
  readonly COLUMN1ROW1: number;
  /**
   * Gets the number of items in the collection.
   */
  length: number;
  /**
   * Duplicates the provided Matrix2 instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix2 instance if one was not provided.
   */
  clone(result?: Matrix2): Matrix2;
  /**
   * Compares this matrix to the provided matrix componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The right hand side matrix.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(right?: Matrix2): boolean;
  /**
   * Compares this matrix to the provided matrix componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   * @param [right] - The right hand side matrix.
   * @param [epsilon = 0] - The epsilon to use for equality testing.
   * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(right?: Matrix2, epsilon?: number): boolean;
  /**
   * Creates a string representing this Matrix with each row being
   * on a separate line and in the format '(column0, column1)'.
   * @returns A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.
   */
  toString(): string;
}

export interface Matrix3 extends ArrayLike<number> {
}

/**
* A 3x3 matrix, indexable as a column-major order array.
* Constructor parameters are in row-major order for code readability.
* @param [column0Row0 = 0.0] - The value for column 0, row 0.
* @param [column1Row0 = 0.0] - The value for column 1, row 0.
* @param [column2Row0 = 0.0] - The value for column 2, row 0.
* @param [column0Row1 = 0.0] - The value for column 0, row 1.
* @param [column1Row1 = 0.0] - The value for column 1, row 1.
* @param [column2Row1 = 0.0] - The value for column 2, row 1.
* @param [column0Row2 = 0.0] - The value for column 0, row 2.
* @param [column1Row2 = 0.0] - The value for column 1, row 2.
* @param [column2Row2 = 0.0] - The value for column 2, row 2.
*/
export class Matrix3 implements ArrayLike<number> {
  constructor(column0Row0?: number, column1Row0?: number, column2Row0?: number, column0Row1?: number, column1Row1?: number, column2Row1?: number, column0Row2?: number, column1Row2?: number, column2Row2?: number);
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: Matrix3, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Matrix3 instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: Matrix3): Matrix3;
  /**
   * Flattens an array of Matrix3s into an array of components. The components
   * are stored in column-major order.
   * @param array - The array of matrices to pack.
   * @param [result] - The array onto which to store the result. If this is a typed array, it must have array.length * 9 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 9) elements.
   * @returns The packed array.
   */
  packArray(array: Matrix3[], result?: number[]): number[];
  /**
   * Unpacks an array of column-major matrix components into an array of Matrix3s.
   * @param array - The array of components to unpack.
   * @param [result] - The array onto which to store the result.
   * @returns The unpacked array.
   */
  unpackArray(array: number[], result?: Matrix3[]): Matrix3[];
  /**
   * Duplicates a Matrix3 instance.
   * @param matrix - The matrix to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)
   */
  clone(matrix: Matrix3, result?: Matrix3): Matrix3;
  /**
   * Creates a Matrix3 from 9 consecutive elements in an array.
   * @example
   * // Create the Matrix3:
   * // [1.0, 2.0, 3.0]
   * // [1.0, 2.0, 3.0]
   * // [1.0, 2.0, 3.0]
   *
   * const v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
   * const m = SuperMap.Matrix3.fromArray(v);
   *
   * // Create same Matrix3 with using an offset into an array
   * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
   * const m2 = SuperMap.Matrix3.fromArray(v2, 2);
   * @param array - The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
   * @param [startingIndex = 0] - The offset into the array of the first element, which corresponds to first column first row position in the matrix.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix3 instance if one was not provided.
   */
  fromArray(array: number[], startingIndex?: number, result?: Matrix3): Matrix3;
  /**
   * Creates a Matrix3 instance from a column-major order array.
   * @param values - The column-major order array.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
   */
  fromColumnMajorArray(values: number[], result?: Matrix3): Matrix3;
  /**
   * Creates a Matrix3 instance from a row-major order array.
   * The resulting matrix will be in column-major order.
   * @param values - The row-major order array.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
   */
  fromRowMajorArray(values: number[], result?: Matrix3): Matrix3;
  /**
   * Computes a 3x3 rotation matrix from the provided quaternion.
   * @param quaternion - the quaternion to use.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The 3x3 rotation matrix from this quaternion.
   */
  fromQuaternion(quaternion: Quaternion, result?: Matrix3): Matrix3;
  /**
   * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )
   * @param headingPitchRoll - the headingPitchRoll to use.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The 3x3 rotation matrix from this headingPitchRoll.
   */
  fromHeadingPitchRoll(headingPitchRoll: HeadingPitchRoll, result?: Matrix3): Matrix3;
  /**
   * Computes a Matrix3 instance representing a non-uniform scale.
   * @example
   * // Creates
   * //   [7.0, 0.0, 0.0]
   * //   [0.0, 8.0, 0.0]
   * //   [0.0, 0.0, 9.0]
   * const m = SuperMap.Matrix3.fromScale(new SuperMap.Cartesian3(7.0, 8.0, 9.0));
   * @param scale - The x, y, and z scale factors.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
   */
  fromScale(scale: Cartesian3, result?: Matrix3): Matrix3;
  /**
   * Computes a Matrix3 instance representing a uniform scale.
   * @example
   * // Creates
   * //   [2.0, 0.0, 0.0]
   * //   [0.0, 2.0, 0.0]
   * //   [0.0, 0.0, 2.0]
   * const m = SuperMap.Matrix3.fromUniformScale(2.0);
   * @param scale - The uniform scale factor.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
   */
  fromUniformScale(scale: number, result?: Matrix3): Matrix3;
  /**
   * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.
   * @example
   * // Creates
   * //   [0.0, -9.0,  8.0]
   * //   [9.0,  0.0, -7.0]
   * //   [-8.0, 7.0,  0.0]
   * const m = SuperMap.Matrix3.fromCrossProduct(new SuperMap.Cartesian3(7.0, 8.0, 9.0));
   * @param vector - the vector on the left hand side of the cross product operation.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
   */
  fromCrossProduct(vector: Cartesian3, result?: Matrix3): Matrix3;
  /**
   * Creates a rotation matrix around the x-axis.
   * @example
   * // Rotate a point 45 degrees counterclockwise around the x-axis.
   * const p = new SuperMap.Cartesian3(5, 6, 7);
   * const m = SuperMap.Matrix3.fromRotationX(SuperMap.Math.toRadians(45.0));
   * const rotated = SuperMap.Matrix3.multiplyByVector(m, p, new SuperMap.Cartesian3());
   * @param angle - The angle, in radians, of the rotation.  Positive angles are counterclockwise.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
   */
  fromRotationX(angle: number, result?: Matrix3): Matrix3;
  /**
   * Creates a rotation matrix around the y-axis.
   * @example
   * // Rotate a point 45 degrees counterclockwise around the y-axis.
   * const p = new SuperMap.Cartesian3(5, 6, 7);
   * const m = SuperMap.Matrix3.fromRotationY(SuperMap.Math.toRadians(45.0));
   * const rotated = SuperMap.Matrix3.multiplyByVector(m, p, new SuperMap.Cartesian3());
   * @param angle - The angle, in radians, of the rotation.  Positive angles are counterclockwise.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
   */
  fromRotationY(angle: number, result?: Matrix3): Matrix3;
  /**
   * Creates a rotation matrix around the z-axis.
   * @example
   * // Rotate a point 45 degrees counterclockwise around the z-axis.
   * const p = new SuperMap.Cartesian3(5, 6, 7);
   * const m = SuperMap.Matrix3.fromRotationZ(SuperMap.Math.toRadians(45.0));
   * const rotated = SuperMap.Matrix3.multiplyByVector(m, p, new SuperMap.Cartesian3());
   * @param angle - The angle, in radians, of the rotation.  Positive angles are counterclockwise.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
   */
  fromRotationZ(angle: number, result?: Matrix3): Matrix3;
  /**
   * Creates an Array from the provided Matrix3 instance.
   * The array will be in column-major order.
   * @param matrix - The matrix to use..
   * @param [result] - The Array onto which to store the result.
   * @returns The modified Array parameter or a new Array instance if one was not provided.
   */
  toArray(matrix: Matrix3, result?: number[]): number[];
  /**
   * Computes the array index of the element at the provided row and column.
   * @example
   * const myMatrix = new SuperMap.Matrix3();
   * const column1Row0Index = SuperMap.Matrix3.getElementIndex(1, 0);
   * const column1Row0 = myMatrix[column1Row0Index]
   * myMatrix[column1Row0Index] = 10.0;
   * @param column - The zero-based index of the column.
   * @param row - The zero-based index of the row.
   * @returns The index of the element at the provided row and column.
   */
  getElementIndex(column: number, row: number): number;
  /**
   * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.
   * @param matrix - The matrix to use.
   * @param index - The zero-based index of the column to retrieve.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getColumn(matrix: Matrix3, index: number, result: Cartesian3): Cartesian3;
  /**
   * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.
   * @param matrix - The matrix to use.
   * @param index - The zero-based index of the column to set.
   * @param cartesian - The Cartesian whose values will be assigned to the specified column.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setColumn(matrix: Matrix3, index: number, cartesian: Cartesian3, result: Matrix3): Matrix3;
  /**
   * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.
   * @param matrix - The matrix to use.
   * @param index - The zero-based index of the row to retrieve.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getRow(matrix: Matrix3, index: number, result: Cartesian3): Cartesian3;
  /**
   * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.
   * @param matrix - The matrix to use.
   * @param index - The zero-based index of the row to set.
   * @param cartesian - The Cartesian whose values will be assigned to the specified row.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setRow(matrix: Matrix3, index: number, cartesian: Cartesian3, result: Matrix3): Matrix3;
  /**
   * Computes a new matrix that replaces the scale with the provided scale.
   * This assumes the matrix is an affine transformation.
   * @param matrix - The matrix to use.
   * @param scale - The scale that replaces the scale of the provided matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setScale(matrix: Matrix3, scale: Cartesian3, result: Matrix3): Matrix3;
  /**
   * Computes a new matrix that replaces the scale with the provided uniform scale.
   * This assumes the matrix is an affine transformation.
   * @param matrix - The matrix to use.
   * @param scale - The uniform scale that replaces the scale of the provided matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setUniformScale(matrix: Matrix3, scale: number, result: Matrix3): Matrix3;
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * @param matrix - The matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getScale(matrix: Matrix3, result: Cartesian3): Cartesian3;
  /**
   * Computes the maximum scale assuming the matrix is an affine transformation.
   * The maximum scale is the maximum length of the column vectors.
   * @param matrix - The matrix.
   * @returns The maximum scale.
   */
  getMaximumScale(matrix: Matrix3): number;
  /**
   * Sets the rotation assuming the matrix is an affine transformation.
   * @param matrix - The matrix.
   * @param rotation - The rotation matrix.
   * @returns The modified result parameter.
   */
  setRotation(matrix: Matrix3, rotation: Matrix3): Matrix3;
  /**
   * Extracts the rotation matrix assuming the matrix is an affine transformation.
   * @param matrix - The matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getRotation(matrix: Matrix3, result: Matrix3): Matrix3;
  /**
   * Computes the product of two matrices.
   * @param left - The first matrix.
   * @param right - The second matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiply(left: Matrix3, right: Matrix3, result: Matrix3): Matrix3;
  /**
   * Computes the sum of two matrices.
   * @param left - The first matrix.
   * @param right - The second matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  add(left: Matrix3, right: Matrix3, result: Matrix3): Matrix3;
  /**
   * Computes the difference of two matrices.
   * @param left - The first matrix.
   * @param right - The second matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  subtract(left: Matrix3, right: Matrix3, result: Matrix3): Matrix3;
  /**
   * Computes the product of a matrix and a column vector.
   * @param matrix - The matrix.
   * @param cartesian - The column.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByVector(matrix: Matrix3, cartesian: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Computes the product of a matrix and a scalar.
   * @param matrix - The matrix.
   * @param scalar - The number to multiply by.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByScalar(matrix: Matrix3, scalar: number, result: Matrix3): Matrix3;
  /**
   * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.
   * @example
   * // Instead of SuperMap.Matrix3.multiply(m, SuperMap.Matrix3.fromScale(scale), m);
   * SuperMap.Matrix3.multiplyByScale(m, scale, m);
   * @param matrix - The matrix on the left-hand side.
   * @param scale - The non-uniform scale on the right-hand side.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByScale(matrix: Matrix3, scale: number, result: Matrix3): Matrix3;
  /**
   * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.
   * @example
   * // Instead of SuperMap.Matrix3.multiply(m, SuperMap.Matrix3.fromUniformScale(scale), m);
   * SuperMap.Matrix3.multiplyByUniformScale(m, scale, m);
   * @param matrix - The matrix on the left-hand side.
   * @param scale - The uniform scale on the right-hand side.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByUniformScale(matrix: Matrix3, scale: number, result: Matrix3): Matrix3;
  /**
   * Creates a negated copy of the provided matrix.
   * @param matrix - The matrix to negate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  negate(matrix: Matrix3, result: Matrix3): Matrix3;
  /**
   * Computes the transpose of the provided matrix.
   * @param matrix - The matrix to transpose.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  transpose(matrix: Matrix3, result: Matrix3): Matrix3;
  /**
   * Computes the eigenvectors and eigenvalues of a symmetric matrix.
   * <p>
   * Returns a diagonal matrix and unitary matrix such that:
   * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>
   * </p>
   * <p>
   * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns
   * of the unitary matrix are the corresponding eigenvectors.
   * </p>
   * @example
   * const a = //... symetric matrix
   * const result = {
   *     unitary : new SuperMap.Matrix3(),
   *     diagonal : new SuperMap.Matrix3()
   * };
   * SuperMap.Matrix3.computeEigenDecomposition(a, result);
   *
   * const unitaryTranspose = SuperMap.Matrix3.transpose(result.unitary, new SuperMap.Matrix3());
   * const b = SuperMap.Matrix3.multiply(result.unitary, result.diagonal, new SuperMap.Matrix3());
   * SuperMap.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a
   *
   * const lambda = SuperMap.Matrix3.getColumn(result.diagonal, 0, new SuperMap.Cartesian3()).x;  // first eigenvalue
   * const v = SuperMap.Matrix3.getColumn(result.unitary, 0, new SuperMap.Cartesian3());          // first eigenvector
   * const c = SuperMap.Cartesian3.multiplyByScalar(v, lambda, new SuperMap.Cartesian3());        // equal to SuperMap.Matrix3.multiplyByVector(a, v)
   * @param matrix - The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.
   * @param [result] - An object with unitary and diagonal properties which are matrices onto which to store the result.
   * @returns An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.
   */
  computeEigenDecomposition(matrix: Matrix3, result?: any): any;
  /**
   * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
   * @param matrix - The matrix with signed elements.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  abs(matrix: Matrix3, result: Matrix3): Matrix3;
  /**
   * Computes the determinant of the provided matrix.
   * @param matrix - The matrix to use.
   * @returns The value of the determinant of the matrix.
   */
  determinant(matrix: Matrix3): number;
  /**
   * Computes the inverse of the provided matrix.
   * @param matrix - The matrix to invert.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  inverse(matrix: Matrix3, result: Matrix3): Matrix3;
  /**
   * Computes the inverse transpose of a matrix.
   * @param matrix - The matrix to transpose and invert.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  inverseTranspose(matrix: Matrix3, result: Matrix3): Matrix3;
  /**
   * Compares the provided matrices componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [left] - The first matrix.
   * @param [right] - The second matrix.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left?: Matrix3, right?: Matrix3): boolean;
  /**
   * Compares the provided matrices componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   * @param [left] - The first matrix.
   * @param [right] - The second matrix.
   * @param [epsilon = 0] - The epsilon to use for equality testing.
   * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(left?: Matrix3, right?: Matrix3, epsilon?: number): boolean;
  /**
   * An immutable Matrix3 instance initialized to the identity matrix.
   */
  readonly IDENTITY: Matrix3;
  /**
   * An immutable Matrix3 instance initialized to the zero matrix.
   */
  readonly ZERO: Matrix3;
  /**
   * The index into Matrix3 for column 0, row 0.
   */
  readonly COLUMN0ROW0: number;
  /**
   * The index into Matrix3 for column 0, row 1.
   */
  readonly COLUMN0ROW1: number;
  /**
   * The index into Matrix3 for column 0, row 2.
   */
  readonly COLUMN0ROW2: number;
  /**
   * The index into Matrix3 for column 1, row 0.
   */
  readonly COLUMN1ROW0: number;
  /**
   * The index into Matrix3 for column 1, row 1.
   */
  readonly COLUMN1ROW1: number;
  /**
   * The index into Matrix3 for column 1, row 2.
   */
  readonly COLUMN1ROW2: number;
  /**
   * The index into Matrix3 for column 2, row 0.
   */
  readonly COLUMN2ROW0: number;
  /**
   * The index into Matrix3 for column 2, row 1.
   */
  readonly COLUMN2ROW1: number;
  /**
   * The index into Matrix3 for column 2, row 2.
   */
  readonly COLUMN2ROW2: number;
  /**
   * Gets the number of items in the collection.
   */
  length: number;
  /**
   * Duplicates the provided Matrix3 instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix3 instance if one was not provided.
   */
  clone(result?: Matrix3): Matrix3;
  /**
   * Compares this matrix to the provided matrix componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The right hand side matrix.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(right?: Matrix3): boolean;
  /**
   * Compares this matrix to the provided matrix componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   * @param [right] - The right hand side matrix.
   * @param [epsilon = 0] - The epsilon to use for equality testing.
   * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(right?: Matrix3, epsilon?: number): boolean;
  /**
   * Creates a string representing this Matrix with each row being
   * on a separate line and in the format '(column0, column1, column2)'.
   * @returns A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.
   */
  toString(): string;
}

export interface Matrix4 extends ArrayLike<number> {
}

/**
* A 4x4 matrix, indexable as a column-major order array.
* Constructor parameters are in row-major order for code readability.
* @param [column0Row0 = 0.0] - The value for column 0, row 0.
* @param [column1Row0 = 0.0] - The value for column 1, row 0.
* @param [column2Row0 = 0.0] - The value for column 2, row 0.
* @param [column3Row0 = 0.0] - The value for column 3, row 0.
* @param [column0Row1 = 0.0] - The value for column 0, row 1.
* @param [column1Row1 = 0.0] - The value for column 1, row 1.
* @param [column2Row1 = 0.0] - The value for column 2, row 1.
* @param [column3Row1 = 0.0] - The value for column 3, row 1.
* @param [column0Row2 = 0.0] - The value for column 0, row 2.
* @param [column1Row2 = 0.0] - The value for column 1, row 2.
* @param [column2Row2 = 0.0] - The value for column 2, row 2.
* @param [column3Row2 = 0.0] - The value for column 3, row 2.
* @param [column0Row3 = 0.0] - The value for column 0, row 3.
* @param [column1Row3 = 0.0] - The value for column 1, row 3.
* @param [column2Row3 = 0.0] - The value for column 2, row 3.
* @param [column3Row3 = 0.0] - The value for column 3, row 3.
*/
export class Matrix4 implements ArrayLike<number> {
  constructor(column0Row0?: number, column1Row0?: number, column2Row0?: number, column3Row0?: number, column0Row1?: number, column1Row1?: number, column2Row1?: number, column3Row1?: number, column0Row2?: number, column1Row2?: number, column2Row2?: number, column3Row2?: number, column0Row3?: number, column1Row3?: number, column2Row3?: number, column3Row3?: number);
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: Matrix4, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Matrix4 instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: Matrix4): Matrix4;
  /**
   * Flattens an array of Matrix4s into an array of components. The components
   * are stored in column-major order.
   * @param array - The array of matrices to pack.
   * @param [result] - The array onto which to store the result. If this is a typed array, it must have array.length * 16 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 16) elements.
   * @returns The packed array.
   */
  packArray(array: Matrix4[], result?: number[]): number[];
  /**
   * Unpacks an array of column-major matrix components into an array of Matrix4s.
   * @param array - The array of components to unpack.
   * @param [result] - The array onto which to store the result.
   * @returns The unpacked array.
   */
  unpackArray(array: number[], result?: Matrix4[]): Matrix4[];
  /**
   * Duplicates a Matrix4 instance.
   * @param matrix - The matrix to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix4 instance if one was not provided. (Returns undefined if matrix is undefined)
   */
  clone(matrix: Matrix4, result?: Matrix4): Matrix4;
  /**
   * Creates a Matrix4 from 16 consecutive elements in an array.
   * @example
   * // Create the Matrix4:
   * // [1.0, 2.0, 3.0, 4.0]
   * // [1.0, 2.0, 3.0, 4.0]
   * // [1.0, 2.0, 3.0, 4.0]
   * // [1.0, 2.0, 3.0, 4.0]
   *
   * const v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
   * const m = SuperMap.Matrix4.fromArray(v);
   *
   * // Create same Matrix4 with using an offset into an array
   * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
   * const m2 = SuperMap.Matrix4.fromArray(v2, 2);
   * @param array - The array whose 16 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
   * @param [startingIndex = 0] - The offset into the array of the first element, which corresponds to first column first row position in the matrix.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix4 instance if one was not provided.
   */
  fromArray(array: number[], startingIndex?: number, result?: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance from a column-major order array.
   * @param values - The column-major order array.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
   */
  fromColumnMajorArray(values: number[], result?: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance from a row-major order array.
   * The resulting matrix will be in column-major order.
   * @param values - The row-major order array.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
   */
  fromRowMajorArray(values: number[], result?: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance from a Matrix3 representing the rotation
   * and a Cartesian3 representing the translation.
   * @param rotation - The upper left portion of the matrix representing the rotation.
   * @param [translation = Cartesian3.ZERO] - The upper right portion of the matrix representing the translation.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
   */
  fromRotationTranslation(rotation: Matrix3, translation?: Cartesian3, result?: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance from a translation, rotation, and scale (TRS)
   * representation with the rotation represented as a quaternion.
   * @example
   * const result = SuperMap.Matrix4.fromTranslationQuaternionRotationScale(
   *   new SuperMap.Cartesian3(1.0, 2.0, 3.0), // translation
   *   SuperMap.Quaternion.IDENTITY,           // rotation
   *   new SuperMap.Cartesian3(7.0, 8.0, 9.0), // scale
   *   result);
   * @param translation - The translation transformation.
   * @param rotation - The rotation transformation.
   * @param scale - The non-uniform scale transformation.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
   */
  fromTranslationQuaternionRotationScale(translation: Cartesian3, rotation: Quaternion, scale: Cartesian3, result?: Matrix4): Matrix4;
  /**
   * Creates a Matrix4 instance from a {@link TranslationRotationScale} instance.
   * @param translationRotationScale - The instance.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
   */
  fromTranslationRotationScale(translationRotationScale: TranslationRotationScale, result?: Matrix4): Matrix4;
  /**
   * Creates a Matrix4 instance from a Cartesian3 representing the translation.
   * @param translation - The upper right portion of the matrix representing the translation.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
   */
  fromTranslation(translation: Cartesian3, result?: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance representing a non-uniform scale.
   * @example
   * // Creates
   * //   [7.0, 0.0, 0.0, 0.0]
   * //   [0.0, 8.0, 0.0, 0.0]
   * //   [0.0, 0.0, 9.0, 0.0]
   * //   [0.0, 0.0, 0.0, 1.0]
   * const m = SuperMap.Matrix4.fromScale(new SuperMap.Cartesian3(7.0, 8.0, 9.0));
   * @param scale - The x, y, and z scale factors.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
   */
  fromScale(scale: Cartesian3, result?: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance representing a uniform scale.
   * @example
   * // Creates
   * //   [2.0, 0.0, 0.0, 0.0]
   * //   [0.0, 2.0, 0.0, 0.0]
   * //   [0.0, 0.0, 2.0, 0.0]
   * //   [0.0, 0.0, 0.0, 1.0]
   * const m = SuperMap.Matrix4.fromUniformScale(2.0);
   * @param scale - The uniform scale factor.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
   */
  fromUniformScale(scale: number, result?: Matrix4): Matrix4;
  /**
   * Creates a rotation matrix.
   * @param rotation - The rotation matrix.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
   */
  fromRotation(rotation: Matrix3, result?: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance from a Camera.
   * @param camera - The camera to use.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
   */
  fromCamera(camera: Camera, result?: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance representing a perspective transformation matrix.
   * @param fovY - The field of view along the Y axis in radians.
   * @param aspectRatio - The aspect ratio.
   * @param near - The distance to the near plane in meters.
   * @param far - The distance to the far plane in meters.
   * @param result - The object in which the result will be stored.
   * @returns The modified result parameter.
   */
  computePerspectiveFieldOfView(fovY: number, aspectRatio: number, near: number, far: number, result: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance representing an orthographic transformation matrix.
   * @param left - The number of meters to the left of the camera that will be in view.
   * @param right - The number of meters to the right of the camera that will be in view.
   * @param bottom - The number of meters below of the camera that will be in view.
   * @param top - The number of meters above of the camera that will be in view.
   * @param near - The distance to the near plane in meters.
   * @param far - The distance to the far plane in meters.
   * @param result - The object in which the result will be stored.
   * @returns The modified result parameter.
   */
  computeOrthographicOffCenter(left: number, right: number, bottom: number, top: number, near: number, far: number, result: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance representing an off center perspective transformation.
   * @param left - The number of meters to the left of the camera that will be in view.
   * @param right - The number of meters to the right of the camera that will be in view.
   * @param bottom - The number of meters below of the camera that will be in view.
   * @param top - The number of meters above of the camera that will be in view.
   * @param near - The distance to the near plane in meters.
   * @param far - The distance to the far plane in meters.
   * @param result - The object in which the result will be stored.
   * @returns The modified result parameter.
   */
  computePerspectiveOffCenter(left: number, right: number, bottom: number, top: number, near: number, far: number, result: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance representing an infinite off center perspective transformation.
   * @param left - The number of meters to the left of the camera that will be in view.
   * @param right - The number of meters to the right of the camera that will be in view.
   * @param bottom - The number of meters below of the camera that will be in view.
   * @param top - The number of meters above of the camera that will be in view.
   * @param near - The distance to the near plane in meters.
   * @param result - The object in which the result will be stored.
   * @returns The modified result parameter.
   */
  computeInfinitePerspectiveOffCenter(left: number, right: number, bottom: number, top: number, near: number, result: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.
   * @example
   * // Create viewport transformation using an explicit viewport and depth range.
   * const m = SuperMap.Matrix4.computeViewportTransformation({
   *     x : 0.0,
   *     y : 0.0,
   *     width : 1024.0,
   *     height : 768.0
   * }, 0.0, 1.0, new SuperMap.Matrix4());
   * @param [viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] - The viewport's corners as shown in Example 1.
   * @param [nearDepthRange = 0.0] - The near plane distance in window coordinates.
   * @param [farDepthRange = 1.0] - The far plane distance in window coordinates.
   * @param [result] - The object in which the result will be stored.
   * @returns The modified result parameter.
   */
  computeViewportTransformation(viewport?: any, nearDepthRange?: number, farDepthRange?: number, result?: Matrix4): Matrix4;
  /**
   * Computes a Matrix4 instance that transforms from world space to view space.
   * @param position - The position of the camera.
   * @param direction - The forward direction.
   * @param up - The up direction.
   * @param right - The right direction.
   * @param result - The object in which the result will be stored.
   * @returns The modified result parameter.
   */
  computeView(position: Cartesian3, direction: Cartesian3, up: Cartesian3, right: Cartesian3, result: Matrix4): Matrix4;
  /**
   * Computes an Array from the provided Matrix4 instance.
   * The array will be in column-major order.
   * @example
   * //create an array from an instance of Matrix4
   * // m = [10.0, 14.0, 18.0, 22.0]
   * //     [11.0, 15.0, 19.0, 23.0]
   * //     [12.0, 16.0, 20.0, 24.0]
   * //     [13.0, 17.0, 21.0, 25.0]
   * const a = SuperMap.Matrix4.toArray(m);
   *
   * // m remains the same
   * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]
   * @param matrix - The matrix to use..
   * @param [result] - The Array onto which to store the result.
   * @returns The modified Array parameter or a new Array instance if one was not provided.
   */
  toArray(matrix: Matrix4, result?: number[]): number[];
  /**
   * Computes the array index of the element at the provided row and column.
   * @example
   * const myMatrix = new SuperMap.Matrix4();
   * const column1Row0Index = SuperMap.Matrix4.getElementIndex(1, 0);
   * const column1Row0 = myMatrix[column1Row0Index];
   * myMatrix[column1Row0Index] = 10.0;
   * @param row - The zero-based index of the row.
   * @param column - The zero-based index of the column.
   * @returns The index of the element at the provided row and column.
   */
  getElementIndex(row: number, column: number): number;
  /**
   * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.
   * @example
   * //returns a Cartesian4 instance with values from the specified column
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * //Example 1: Creates an instance of Cartesian
   * const a = SuperMap.Matrix4.getColumn(m, 2, new SuperMap.Cartesian4());
   * @example
   * //Example 2: Sets values for Cartesian instance
   * const a = new SuperMap.Cartesian4();
   * SuperMap.Matrix4.getColumn(m, 2, a);
   *
   * // a.x = 12.0; a.y = 16.0; a.z = 20.0; a.w = 24.0;
   * @param matrix - The matrix to use.
   * @param index - The zero-based index of the column to retrieve.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getColumn(matrix: Matrix4, index: number, result: Cartesian4): Cartesian4;
  /**
   * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.
   * @example
   * //creates a new Matrix4 instance with new column values from the Cartesian4 instance
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * const a = SuperMap.Matrix4.setColumn(m, 2, new SuperMap.Cartesian4(99.0, 98.0, 97.0, 96.0), new SuperMap.Matrix4());
   *
   * // m remains the same
   * // a = [10.0, 11.0, 99.0, 13.0]
   * //     [14.0, 15.0, 98.0, 17.0]
   * //     [18.0, 19.0, 97.0, 21.0]
   * //     [22.0, 23.0, 96.0, 25.0]
   * @param matrix - The matrix to use.
   * @param index - The zero-based index of the column to set.
   * @param cartesian - The Cartesian whose values will be assigned to the specified column.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setColumn(matrix: Matrix4, index: number, cartesian: Cartesian4, result: Matrix4): Matrix4;
  /**
   * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.
   * @example
   * //returns a Cartesian4 instance with values from the specified column
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * //Example 1: Returns an instance of Cartesian
   * const a = SuperMap.Matrix4.getRow(m, 2, new SuperMap.Cartesian4());
   * @example
   * //Example 2: Sets values for a Cartesian instance
   * const a = new SuperMap.Cartesian4();
   * SuperMap.Matrix4.getRow(m, 2, a);
   *
   * // a.x = 18.0; a.y = 19.0; a.z = 20.0; a.w = 21.0;
   * @param matrix - The matrix to use.
   * @param index - The zero-based index of the row to retrieve.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getRow(matrix: Matrix4, index: number, result: Cartesian4): Cartesian4;
  /**
   * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.
   * @example
   * //create a new Matrix4 instance with new row values from the Cartesian4 instance
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * const a = SuperMap.Matrix4.setRow(m, 2, new SuperMap.Cartesian4(99.0, 98.0, 97.0, 96.0), new SuperMap.Matrix4());
   *
   * // m remains the same
   * // a = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [99.0, 98.0, 97.0, 96.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   * @param matrix - The matrix to use.
   * @param index - The zero-based index of the row to set.
   * @param cartesian - The Cartesian whose values will be assigned to the specified row.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setRow(matrix: Matrix4, index: number, cartesian: Cartesian4, result: Matrix4): Matrix4;
  /**
   * Computes a new matrix that replaces the translation in the rightmost column of the provided
   * matrix with the provided translation. This assumes the matrix is an affine transformation.
   * @param matrix - The matrix to use.
   * @param translation - The translation that replaces the translation of the provided matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setTranslation(matrix: Matrix4, translation: Cartesian3, result: Matrix4): Matrix4;
  /**
   * Computes a new matrix that replaces the scale with the provided scale.
   * This assumes the matrix is an affine transformation.
   * @param matrix - The matrix to use.
   * @param scale - The scale that replaces the scale of the provided matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setScale(matrix: Matrix4, scale: Cartesian3, result: Matrix4): Matrix4;
  /**
   * Computes a new matrix that replaces the scale with the provided uniform scale.
   * This assumes the matrix is an affine transformation.
   * @param matrix - The matrix to use.
   * @param scale - The uniform scale that replaces the scale of the provided matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  setUniformScale(matrix: Matrix4, scale: number, result: Matrix4): Matrix4;
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * @param matrix - The matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter
   */
  getScale(matrix: Matrix4, result: Cartesian3): Cartesian3;
  /**
   * Computes the maximum scale assuming the matrix is an affine transformation.
   * The maximum scale is the maximum length of the column vectors in the upper-left
   * 3x3 matrix.
   * @param matrix - The matrix.
   * @returns The maximum scale.
   */
  getMaximumScale(matrix: Matrix4): number;
  /**
   * Sets the rotation assuming the matrix is an affine transformation.
   * @param matrix - The matrix.
   * @param rotation - The rotation matrix.
   * @returns The modified result parameter.
   */
  setRotation(matrix: Matrix4, rotation: Matrix4): Matrix4;
  /**
   * Extracts the rotation matrix assuming the matrix is an affine transformation.
   * @param matrix - The matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getRotation(matrix: Matrix4, result: Matrix4): Matrix4;
  /**
   * Computes the product of two matrices.
   * @param left - The first matrix.
   * @param right - The second matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiply(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;
  /**
   * Computes the sum of two matrices.
   * @param left - The first matrix.
   * @param right - The second matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  add(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;
  /**
   * Computes the difference of two matrices.
   * @param left - The first matrix.
   * @param right - The second matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  subtract(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;
  /**
   * Computes the product of two matrices assuming the matrices are affine transformation matrices,
   * where the upper left 3x3 elements are any matrix, and
   * the upper three elements in the fourth column are the translation.
   * The bottom row is assumed to be [0, 0, 0, 1].
   * The matrix is not verified to be in the proper form.
   * This method is faster than computing the product for general 4x4
   * matrices using {@link Matrix4.multiply}.
   * @example
   * const m1 = new SuperMap.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);
   * const m2 = SuperMap.Transforms.eastNorthUpToFixedFrame(new SuperMap.Cartesian3(1.0, 1.0, 1.0));
   * const m3 = SuperMap.Matrix4.multiplyTransformation(m1, m2, new SuperMap.Matrix4());
   * @param left - The first matrix.
   * @param right - The second matrix.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyTransformation(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;
  /**
   * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
   * by a 3x3 rotation matrix.  This is an optimization
   * for <code>Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m);</code> with less allocations and arithmetic operations.
   * @example
   * // Instead of SuperMap.Matrix4.multiply(m, SuperMap.Matrix4.fromRotationTranslation(rotation), m);
   * SuperMap.Matrix4.multiplyByMatrix3(m, rotation, m);
   * @param matrix - The matrix on the left-hand side.
   * @param rotation - The 3x3 rotation matrix on the right-hand side.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByMatrix3(matrix: Matrix4, rotation: Matrix3, result: Matrix4): Matrix4;
  /**
   * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
   * by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization
   * for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.
   * @example
   * // Instead of SuperMap.Matrix4.multiply(m, SuperMap.Matrix4.fromTranslation(position), m);
   * SuperMap.Matrix4.multiplyByTranslation(m, position, m);
   * @param matrix - The matrix on the left-hand side.
   * @param translation - The translation on the right-hand side.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByTranslation(matrix: Matrix4, translation: Cartesian3, result: Matrix4): Matrix4;
  /**
   * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
   * by an implicit non-uniform scale matrix. This is an optimization
   * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where
   * <code>m</code> must be an affine matrix.
   * This function performs fewer allocations and arithmetic operations.
   * @example
   * // Instead of SuperMap.Matrix4.multiply(m, SuperMap.Matrix4.fromScale(scale), m);
   * SuperMap.Matrix4.multiplyByScale(m, scale, m);
   * @param matrix - The affine matrix on the left-hand side.
   * @param scale - The non-uniform scale on the right-hand side.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByScale(matrix: Matrix4, scale: Cartesian3, result: Matrix4): Matrix4;
  /**
   * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.
   * @example
   * // Instead of SuperMap.Matrix4.multiply(m, SuperMap.Matrix4.fromUniformScale(scale), m);
   * SuperMap.Matrix4.multiplyByUniformScale(m, scale, m);
   * @param matrix - The matrix on the left-hand side.
   * @param scale - The uniform scale on the right-hand side.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByUniformScale(matrix: Matrix4, scale: number, result: Matrix4): Matrix4;
  /**
   * Computes the product of a matrix and a column vector.
   * @param matrix - The matrix.
   * @param cartesian - The vector.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByVector(matrix: Matrix4, cartesian: Cartesian4, result: Cartesian4): Cartesian4;
  /**
   * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}
   * with a {@link Cartesian4} with a <code>w</code> component of zero.
   * @example
   * const p = new SuperMap.Cartesian3(1.0, 2.0, 3.0);
   * const result = SuperMap.Matrix4.multiplyByPointAsVector(matrix, p, new SuperMap.Cartesian3());
   * // A shortcut for
   * //   Cartesian3 p = ...
   * //   SuperMap.Matrix4.multiplyByVector(matrix, new SuperMap.Cartesian4(p.x, p.y, p.z, 0.0), result);
   * @param matrix - The matrix.
   * @param cartesian - The point.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByPointAsVector(matrix: Matrix4, cartesian: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}
   * with a {@link Cartesian4} with a <code>w</code> component of 1, but returns a {@link Cartesian3} instead of a {@link Cartesian4}.
   * @example
   * const p = new SuperMap.Cartesian3(1.0, 2.0, 3.0);
   * const result = SuperMap.Matrix4.multiplyByPoint(matrix, p, new SuperMap.Cartesian3());
   * @param matrix - The matrix.
   * @param cartesian - The point.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByPoint(matrix: Matrix4, cartesian: Cartesian3, result: Cartesian3): Cartesian3;
  /**
   * Computes the product of a matrix and a scalar.
   * @example
   * //create a Matrix4 instance which is a scaled version of the supplied Matrix4
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * const a = SuperMap.Matrix4.multiplyByScalar(m, -2, new SuperMap.Matrix4());
   *
   * // m remains the same
   * // a = [-20.0, -22.0, -24.0, -26.0]
   * //     [-28.0, -30.0, -32.0, -34.0]
   * //     [-36.0, -38.0, -40.0, -42.0]
   * //     [-44.0, -46.0, -48.0, -50.0]
   * @param matrix - The matrix.
   * @param scalar - The number to multiply by.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByScalar(matrix: Matrix4, scalar: number, result: Matrix4): Matrix4;
  /**
   * Computes a negated copy of the provided matrix.
   * @example
   * //create a new Matrix4 instance which is a negation of a Matrix4
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * const a = SuperMap.Matrix4.negate(m, new SuperMap.Matrix4());
   *
   * // m remains the same
   * // a = [-10.0, -11.0, -12.0, -13.0]
   * //     [-14.0, -15.0, -16.0, -17.0]
   * //     [-18.0, -19.0, -20.0, -21.0]
   * //     [-22.0, -23.0, -24.0, -25.0]
   * @param matrix - The matrix to negate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  negate(matrix: Matrix4, result: Matrix4): Matrix4;
  /**
   * Computes the transpose of the provided matrix.
   * @example
   * //returns transpose of a Matrix4
   * // m = [10.0, 11.0, 12.0, 13.0]
   * //     [14.0, 15.0, 16.0, 17.0]
   * //     [18.0, 19.0, 20.0, 21.0]
   * //     [22.0, 23.0, 24.0, 25.0]
   *
   * const a = SuperMap.Matrix4.transpose(m, new SuperMap.Matrix4());
   *
   * // m remains the same
   * // a = [10.0, 14.0, 18.0, 22.0]
   * //     [11.0, 15.0, 19.0, 23.0]
   * //     [12.0, 16.0, 20.0, 24.0]
   * //     [13.0, 17.0, 21.0, 25.0]
   * @param matrix - The matrix to transpose.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  transpose(matrix: Matrix4, result: Matrix4): Matrix4;
  /**
   * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
   * @param matrix - The matrix with signed elements.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  abs(matrix: Matrix4, result: Matrix4): Matrix4;
  /**
   * Compares the provided matrices componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @example
   * //compares two Matrix4 instances
   *
   * // a = [10.0, 14.0, 18.0, 22.0]
   * //     [11.0, 15.0, 19.0, 23.0]
   * //     [12.0, 16.0, 20.0, 24.0]
   * //     [13.0, 17.0, 21.0, 25.0]
   *
   * // b = [10.0, 14.0, 18.0, 22.0]
   * //     [11.0, 15.0, 19.0, 23.0]
   * //     [12.0, 16.0, 20.0, 24.0]
   * //     [13.0, 17.0, 21.0, 25.0]
   *
   * if(SuperMap.Matrix4.equals(a,b)) {
   *      console.log("Both matrices are equal");
   * } else {
   *      console.log("They are not equal");
   * }
   *
   * //Prints "Both matrices are equal" on the console
   * @param [left] - The first matrix.
   * @param [right] - The second matrix.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left?: Matrix4, right?: Matrix4): boolean;
  /**
   * Compares the provided matrices componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   * @example
   * //compares two Matrix4 instances
   *
   * // a = [10.5, 14.5, 18.5, 22.5]
   * //     [11.5, 15.5, 19.5, 23.5]
   * //     [12.5, 16.5, 20.5, 24.5]
   * //     [13.5, 17.5, 21.5, 25.5]
   *
   * // b = [10.0, 14.0, 18.0, 22.0]
   * //     [11.0, 15.0, 19.0, 23.0]
   * //     [12.0, 16.0, 20.0, 24.0]
   * //     [13.0, 17.0, 21.0, 25.0]
   *
   * if(SuperMap.Matrix4.equalsEpsilon(a,b,0.1)){
   *      console.log("Difference between both the matrices is less than 0.1");
   * } else {
   *      console.log("Difference between both the matrices is not less than 0.1");
   * }
   *
   * //Prints "Difference between both the matrices is not less than 0.1" on the console
   * @param [left] - The first matrix.
   * @param [right] - The second matrix.
   * @param [epsilon = 0] - The epsilon to use for equality testing.
   * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(left?: Matrix4, right?: Matrix4, epsilon?: number): boolean;
  /**
   * Gets the translation portion of the provided matrix, assuming the matrix is an affine transformation matrix.
   * @param matrix - The matrix to use.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getTranslation(matrix: Matrix4, result: Cartesian3): Cartesian3;
  /**
   * Gets the upper left 3x3 matrix of the provided matrix.
   * @example
   * // returns a Matrix3 instance from a Matrix4 instance
   *
   * // m = [10.0, 14.0, 18.0, 22.0]
   * //     [11.0, 15.0, 19.0, 23.0]
   * //     [12.0, 16.0, 20.0, 24.0]
   * //     [13.0, 17.0, 21.0, 25.0]
   *
   * const b = new SuperMap.Matrix3();
   * SuperMap.Matrix4.getMatrix3(m,b);
   *
   * // b = [10.0, 14.0, 18.0]
   * //     [11.0, 15.0, 19.0]
   * //     [12.0, 16.0, 20.0]
   * @param matrix - The matrix to use.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  getMatrix3(matrix: Matrix4, result: Matrix3): Matrix3;
  /**
   * Computes the inverse of the provided matrix using Cramers Rule.
   * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.
   * If the matrix is a proper rigid transformation, it is more efficient
   * to invert it with {@link Matrix4.inverseTransformation}.
   * @param matrix - The matrix to invert.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  inverse(matrix: Matrix4, result: Matrix4): Matrix4;
  /**
   * Computes the inverse of the provided matrix assuming it is a proper rigid matrix,
   * where the upper left 3x3 elements are a rotation matrix,
   * and the upper three elements in the fourth column are the translation.
   * The bottom row is assumed to be [0, 0, 0, 1].
   * The matrix is not verified to be in the proper form.
   * This method is faster than computing the inverse for a general 4x4
   * matrix using {@link Matrix4.inverse}.
   * @param matrix - The matrix to invert.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  inverseTransformation(matrix: Matrix4, result: Matrix4): Matrix4;
  /**
   * Computes the inverse transpose of a matrix.
   * @param matrix - The matrix to transpose and invert.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  inverseTranspose(matrix: Matrix4, result: Matrix4): Matrix4;
  /**
   * An immutable Matrix4 instance initialized to the identity matrix.
   */
  readonly IDENTITY: Matrix4;
  /**
   * An immutable Matrix4 instance initialized to the zero matrix.
   */
  readonly ZERO: Matrix4;
  /**
   * The index into Matrix4 for column 0, row 0.
   */
  readonly COLUMN0ROW0: number;
  /**
   * The index into Matrix4 for column 0, row 1.
   */
  readonly COLUMN0ROW1: number;
  /**
   * The index into Matrix4 for column 0, row 2.
   */
  readonly COLUMN0ROW2: number;
  /**
   * The index into Matrix4 for column 0, row 3.
   */
  readonly COLUMN0ROW3: number;
  /**
   * The index into Matrix4 for column 1, row 0.
   */
  readonly COLUMN1ROW0: number;
  /**
   * The index into Matrix4 for column 1, row 1.
   */
  readonly COLUMN1ROW1: number;
  /**
   * The index into Matrix4 for column 1, row 2.
   */
  readonly COLUMN1ROW2: number;
  /**
   * The index into Matrix4 for column 1, row 3.
   */
  readonly COLUMN1ROW3: number;
  /**
   * The index into Matrix4 for column 2, row 0.
   */
  readonly COLUMN2ROW0: number;
  /**
   * The index into Matrix4 for column 2, row 1.
   */
  readonly COLUMN2ROW1: number;
  /**
   * The index into Matrix4 for column 2, row 2.
   */
  readonly COLUMN2ROW2: number;
  /**
   * The index into Matrix4 for column 2, row 3.
   */
  readonly COLUMN2ROW3: number;
  /**
   * The index into Matrix4 for column 3, row 0.
   */
  readonly COLUMN3ROW0: number;
  /**
   * The index into Matrix4 for column 3, row 1.
   */
  readonly COLUMN3ROW1: number;
  /**
   * The index into Matrix4 for column 3, row 2.
   */
  readonly COLUMN3ROW2: number;
  /**
   * The index into Matrix4 for column 3, row 3.
   */
  readonly COLUMN3ROW3: number;
  /**
   * Gets the number of items in the collection.
   */
  length: number;
  /**
   * Duplicates the provided Matrix4 instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix4 instance if one was not provided.
   */
  clone(result?: Matrix4): Matrix4;
  /**
   * Compares this matrix to the provided matrix componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The right hand side matrix.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(right?: Matrix4): boolean;
  /**
   * Compares this matrix to the provided matrix componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   * @param [right] - The right hand side matrix.
   * @param [epsilon = 0] - The epsilon to use for equality testing.
   * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(right?: Matrix4, epsilon?: number): boolean;
  /**
   * Computes a string representing this Matrix with each row being
   * on a separate line and in the format '(column0, column1, column2, column3)'.
   * @returns A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.
   */
  toString(): string;
}

/**
 * Represents a scalar value's lower and upper bound at a near distance and far distance in eye space.
 * @param [near = 0.0] - The lower bound of the camera range.
 * @param [nearValue = 0.0] - The value at the lower bound of the camera range.
 * @param [far = 1.0] - The upper bound of the camera range.
 * @param [farValue = 0.0] - The value at the upper bound of the camera range.
 */
export class NearFarScalar {
  constructor(near?: number, nearValue?: number, far?: number, farValue?: number);
  /**
   * The lower bound of the camera range.
   */
  near: number;
  /**
   * The value at the lower bound of the camera range.
   */
  nearValue: number;
  /**
   * The upper bound of the camera range.
   */
  far: number;
  /**
   * The value at the upper bound of the camera range.
   */
  farValue: number;
  /**
   * Duplicates a NearFarScalar instance.
   * @param nearFarScalar - The NearFarScalar to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new NearFarScalar instance if one was not provided. (Returns undefined if nearFarScalar is undefined)
   */
  clone(nearFarScalar: NearFarScalar, result?: NearFarScalar): NearFarScalar;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: NearFarScalar, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new NearFarScalar instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: NearFarScalar): NearFarScalar;
  /**
   * Compares the provided NearFarScalar and returns <code>true</code> if they are equal,
   * <code>false</code> otherwise.
   * @param [left] - The first NearFarScalar.
   * @param [right] - The second NearFarScalar.
   * @returns <code>true</code> if left and right are equal; otherwise <code>false</code>.
   */
  equals(left?: NearFarScalar, right?: NearFarScalar): boolean;
  /**
   * Duplicates this instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new NearFarScalar instance if one was not provided.
   */
  clone(result?: NearFarScalar): NearFarScalar;
  /**
   * Compares this instance to the provided NearFarScalar and returns <code>true</code> if they are equal,
   * <code>false</code> otherwise.
   * @param [right] - The right hand side NearFarScalar.
   * @returns <code>true</code> if left and right are equal; otherwise <code>false</code>.
   */
  equals(right?: NearFarScalar): boolean;
}

/**
* Creates an Occluder derived from an object's position and radius, as well as the camera position.
* The occluder can be used to determine whether or not other objects are visible or hidden behind the
* visible horizon defined by the occluder and camera position.
* @example
* // Construct an occluder one unit away from the origin with a radius of one.
* const cameraPosition = SuperMap.Cartesian3.ZERO;
* const occluderBoundingSphere = new SuperMap.BoundingSphere(new SuperMap.Cartesian3(0, 0, -1), 1);
* const occluder = new SuperMap.Occluder(occluderBoundingSphere, cameraPosition);
* @param occluderBoundingSphere - The bounding sphere surrounding the occluder.
* @param cameraPosition - The coordinate of the viewer/camera.
*/
export class Occluder {
  constructor(occluderBoundingSphere: BoundingSphere, cameraPosition: Cartesian3);
  /**
   * The position of the occluder.
   */
  position: Cartesian3;
  /**
   * The radius of the occluder.
   */
  radius: number;
  /**
   * The position of the camera.
   */
  cameraPosition: Cartesian3;
  /**
   * Creates an occluder from a bounding sphere and the camera position.
   * @param occluderBoundingSphere - The bounding sphere surrounding the occluder.
   * @param cameraPosition - The coordinate of the viewer/camera.
   * @param [result] - The object onto which to store the result.
   * @returns The occluder derived from an object's position and radius, as well as the camera position.
   */
  fromBoundingSphere(occluderBoundingSphere: BoundingSphere, cameraPosition: Cartesian3, result?: Occluder): Occluder;
  /**
   * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.
   * @example
   * const cameraPosition = new SuperMap.Cartesian3(0, 0, 0);
   * const littleSphere = new SuperMap.BoundingSphere(new SuperMap.Cartesian3(0, 0, -1), 0.25);
   * const occluder = new SuperMap.Occluder(littleSphere, cameraPosition);
   * const point = new SuperMap.Cartesian3(0, 0, -3);
   * occluder.isPointVisible(point); //returns true
   * @param occludee - The point surrounding the occludee object.
   * @returns <code>true</code> if the occludee is visible; otherwise <code>false</code>.
   */
  isPointVisible(occludee: Cartesian3): boolean;
  /**
   * Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.
   * @example
   * const cameraPosition = new SuperMap.Cartesian3(0, 0, 0);
   * const littleSphere = new SuperMap.BoundingSphere(new SuperMap.Cartesian3(0, 0, -1), 0.25);
   * const occluder = new SuperMap.Occluder(littleSphere, cameraPosition);
   * const bigSphere = new SuperMap.BoundingSphere(new SuperMap.Cartesian3(0, 0, -3), 1);
   * occluder.isBoundingSphereVisible(bigSphere); //returns true
   * @param occludee - The bounding sphere surrounding the occludee object.
   * @returns <code>true</code> if the occludee is visible; otherwise <code>false</code>.
   */
  isBoundingSphereVisible(occludee: BoundingSphere): boolean;
  /**
   * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).
   * @example
   * const sphere1 = new SuperMap.BoundingSphere(new SuperMap.Cartesian3(0, 0, -1.5), 0.5);
   * const sphere2 = new SuperMap.BoundingSphere(new SuperMap.Cartesian3(0, 0, -2.5), 0.5);
   * const cameraPosition = new SuperMap.Cartesian3(0, 0, 0);
   * const occluder = new SuperMap.Occluder(sphere1, cameraPosition);
   * occluder.computeVisibility(sphere2); //returns Visibility.NONE
   * @param occludeeBS - The bounding sphere of the occludee.
   * @returns Visibility.NONE if the occludee is not visible,
   *                       Visibility.PARTIAL if the occludee is partially visible, or
   *                       Visibility.FULL if the occludee is fully visible.
   */
  computeVisibility(occludeeBS: BoundingSphere): Visibility;
  /**
   * Computes a point that can be used as the occludee position to the visibility functions.
   * Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around
   * an object that is used for visibility; however it is also possible to compute a point that if
   * seen/not seen would also indicate if an object is visible/not visible.  This function is better
   * called for objects that do not move relative to the occluder and is large, such as a chunk of
   * terrain.  You are better off not calling this and using the object's bounding sphere for objects
   * such as a satellite or ground vehicle.
   * @example
   * const cameraPosition = new SuperMap.Cartesian3(0, 0, 0);
   * const occluderBoundingSphere = new SuperMap.BoundingSphere(new SuperMap.Cartesian3(0, 0, -8), 2);
   * const occluder = new SuperMap.Occluder(occluderBoundingSphere, cameraPosition);
   * const positions = [new SuperMap.Cartesian3(-0.25, 0, -5.3), new SuperMap.Cartesian3(0.25, 0, -5.3)];
   * const tileOccluderSphere = SuperMap.BoundingSphere.fromPoints(positions);
   * const occludeePosition = tileOccluderSphere.center;
   * const occludeePt = SuperMap.Occluder.computeOccludeePoint(occluderBoundingSphere, occludeePosition, positions);
   * @param occluderBoundingSphere - The bounding sphere surrounding the occluder.
   * @param occludeePosition - The point where the occludee (bounding sphere of radius 0) is located.
   * @param positions - List of altitude points on the horizon near the surface of the occluder.
   * @returns An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>
   * which is a boolean value.
   */
  computeOccludeePoint(occluderBoundingSphere: BoundingSphere, occludeePosition: Cartesian3, positions: Cartesian3[]): any;
  /**
   * Computes a point that can be used as the occludee position to the visibility functions from a rectangle.
   * @param rectangle - The rectangle used to create a bounding sphere.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid used to determine positions of the rectangle.
   * @returns An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>
   * which is a boolean value.
   */
  computeOccludeePointFromRectangle(rectangle: Rectangle, ellipsoid?: Ellipsoid): any;
}

/**
* Provides geocoding via a {@link https://opencagedata.com/|OpenCage} server.
* @example
* // Configure a Viewer to use the OpenCage Geocoder
* const viewer = new SuperMap.Viewer('CesiumContainer', {
*   geocoder: new SuperMap.OpenCageGeocoderService('https://api.opencagedata.com/geocode/v1/', '<API key>')
* });
* @param url - The endpoint to the OpenCage server.
* @param apiKey - The OpenCage API Key.
* @param [params] - An object with the following properties (See https://opencagedata.com/api#forward-opt):
* @param [params.abbrv] - When set to 1 we attempt to abbreviate and shorten the formatted string we return.
* @param [options.add_request] - When set to 1 the various request parameters are added to the response for ease of debugging.
* @param [options.bounds] - Provides the geocoder with a hint to the region that the query resides in.
* @param [options.countrycode] - Restricts the results to the specified country or countries (as defined by the ISO 3166-1 Alpha 2 standard).
* @param [options.jsonp] - Wraps the returned JSON with a function name.
* @param [options.language] - An IETF format language code.
* @param [options.limit] - The maximum number of results we should return.
* @param [options.min_confidence] - An integer from 1-10. Only results with at least this confidence will be returned.
* @param [options.no_annotations] - When set to 1 results will not contain annotations.
* @param [options.no_dedupe] - When set to 1 results will not be deduplicated.
* @param [options.no_record] - When set to 1 the query contents are not logged.
* @param [options.pretty] - When set to 1 results are 'pretty' printed for easier reading. Useful for debugging.
* @param [options.proximity] - Provides the geocoder with a hint to bias results in favour of those closer to the specified location (For example: 41.40139,2.12870).
*/
export class OpenCageGeocoderService {
  constructor(url: Resource | string, apiKey: string, params?: {
    abbrv?: number;
  });
  /**
   * The Resource used to access the OpenCage endpoint.
   */
  readonly url: Resource;
  /**
   * Optional params passed to OpenCage in order to customize geocoding
   */
  readonly params: any;
  /**
   * @param query - The query to be sent to the geocoder service
   */
  geocode(query: string): Promise<GeocoderService.Result[]>;
}

/**
* Creates an instance of an OrientedBoundingBox.
* An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.
* @example
* // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.
* const center = new SuperMap.Cartesian3(1.0, 0.0, 0.0);
* const halfAxes = SuperMap.Matrix3.fromScale(new SuperMap.Cartesian3(1.0, 3.0, 2.0), new SuperMap.Matrix3());
*
* const obb = new SuperMap.OrientedBoundingBox(center, halfAxes);
* @param [center = Cartesian3.ZERO] - The center of the box.
* @param [halfAxes = Matrix3.ZERO] - The three orthogonal half-axes of the bounding box.
*                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0
*                                          cube centered at the origin.
*/
export class OrientedBoundingBox {
  constructor(center?: Cartesian3, halfAxes?: Matrix3);
  /**
   * The center of the box.
   */
  center: Cartesian3;
  /**
   * The transformation matrix, to rotate the box to the right position.
   */
  halfAxes: Matrix3;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: OrientedBoundingBox, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new OrientedBoundingBox instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: OrientedBoundingBox): OrientedBoundingBox;
  /**
   * Computes an instance of an OrientedBoundingBox of the given positions.
   * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).
   * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf
   * @example
   * // Compute an object oriented bounding box enclosing two points.
   * const box = SuperMap.OrientedBoundingBox.fromPoints([new SuperMap.Cartesian3(2, 0, 0), new SuperMap.Cartesian3(-2, 0, 0)]);
   * @param [positions] - List of {@link Cartesian3} points that the bounding box will enclose.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new OrientedBoundingBox instance if one was not provided.
   */
  fromPoints(positions?: Cartesian3[], result?: OrientedBoundingBox): OrientedBoundingBox;
  /**
   * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.
   * There are no guarantees about the orientation of the bounding box.
   * @param rectangle - The cartographic rectangle on the surface of the ellipsoid.
   * @param [minimumHeight = 0.0] - The minimum height (elevation) within the tile.
   * @param [maximumHeight = 0.0] - The maximum height (elevation) within the tile.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the rectangle is defined.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new OrientedBoundingBox instance if none was provided.
   */
  fromRectangle(rectangle: Rectangle, minimumHeight?: number, maximumHeight?: number, ellipsoid?: Ellipsoid, result?: OrientedBoundingBox): OrientedBoundingBox;
  /**
   * Computes an OrientedBoundingBox that bounds an affine transformation.
   * @param transformation - The affine transformation.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new OrientedBoundingBox instance if none was provided.
   */
  fromTransformation(transformation: Matrix4, result?: OrientedBoundingBox): OrientedBoundingBox;
  /**
   * Duplicates a OrientedBoundingBox instance.
   * @param box - The bounding box to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)
   */
  clone(box: OrientedBoundingBox, result?: OrientedBoundingBox): OrientedBoundingBox;
  /**
   * Determines which side of a plane the oriented bounding box is located.
   * @param box - The oriented bounding box to test.
   * @param plane - The plane to test against.
   * @returns {@link Intersect.INSIDE} if the entire box is on the side of the plane
   *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
   *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
   *                      intersects the plane.
   */
  intersectPlane(box: OrientedBoundingBox, plane: Plane): Intersect;
  /**
   * Computes the estimated distance squared from the closest point on a bounding box to a point.
   * @example
   * // Sort bounding boxes from back to front
   * boxes.sort(function(a, b) {
   *     return SuperMap.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - SuperMap.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);
   * });
   * @param box - The box.
   * @param cartesian - The point
   * @returns The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.
   */
  distanceSquaredTo(box: OrientedBoundingBox, cartesian: Cartesian3): number;
  /**
   * The distances calculated by the vector from the center of the bounding box to position projected onto direction.
   * <br>
   * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
   * closest and farthest planes from position that intersect the bounding box.
   * @param box - The bounding box to calculate the distance to.
   * @param position - The position to calculate the distance from.
   * @param direction - The direction from position.
   * @param [result] - A Interval to store the nearest and farthest distances.
   * @returns The nearest and farthest distances on the bounding box from position in direction.
   */
  computePlaneDistances(box: OrientedBoundingBox, position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;
  /**
   * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).
   * @param box - The oriented bounding box.
   * @param [result] - An array of eight {@link Cartesian3} instances onto which to store the corners.
   * @returns The modified result parameter or a new array if none was provided.
   */
  computeCorners(box: OrientedBoundingBox, result?: Cartesian3[]): Cartesian3[];
  /**
   * Computes a transformation matrix from an oriented bounding box.
   * @param box - The oriented bounding box.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter or a new {@link Matrix4} instance if none was provided.
   */
  computeTransformation(box: OrientedBoundingBox, result: Matrix4): Matrix4;
  /**
   * Determines whether or not a bounding box is hidden from view by the occluder.
   * @param box - The bounding box surrounding the occludee object.
   * @param occluder - The occluder.
   * @returns <code>true</code> if the box is not visible; otherwise <code>false</code>.
   */
  isOccluded(box: OrientedBoundingBox, occluder: Occluder): boolean;
  /**
   * Determines which side of a plane the oriented bounding box is located.
   * @param plane - The plane to test against.
   * @returns {@link Intersect.INSIDE} if the entire box is on the side of the plane
   *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
   *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
   *                      intersects the plane.
   */
  intersectPlane(plane: Plane): Intersect;
  /**
   * Computes the estimated distance squared from the closest point on a bounding box to a point.
   * @example
   * // Sort bounding boxes from back to front
   * boxes.sort(function(a, b) {
   *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);
   * });
   * @param cartesian - The point
   * @returns The estimated distance squared from the bounding sphere to the point.
   */
  distanceSquaredTo(cartesian: Cartesian3): number;
  /**
   * The distances calculated by the vector from the center of the bounding box to position projected onto direction.
   * <br>
   * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
   * closest and farthest planes from position that intersect the bounding box.
   * @param position - The position to calculate the distance from.
   * @param direction - The direction from position.
   * @param [result] - A Interval to store the nearest and farthest distances.
   * @returns The nearest and farthest distances on the bounding box from position in direction.
   */
  computePlaneDistances(position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;
  /**
   * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).
   * @param [result] - An array of eight {@link Cartesian3} instances onto which to store the corners.
   * @returns The modified result parameter or a new array if none was provided.
   */
  computeCorners(result?: Cartesian3[]): Cartesian3[];
  /**
   * Computes a transformation matrix from an oriented bounding box.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter or a new {@link Matrix4} instance if none was provided.
   */
  computeTransformation(result: Matrix4): Matrix4;
  /**
   * Determines whether or not a bounding box is hidden from view by the occluder.
   * @param occluder - The occluder.
   * @returns <code>true</code> if the sphere is not visible; otherwise <code>false</code>.
   */
  isOccluded(occluder: Occluder): boolean;
  /**
   * Compares the provided OrientedBoundingBox componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param left - The first OrientedBoundingBox.
   * @param right - The second OrientedBoundingBox.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left: OrientedBoundingBox, right: OrientedBoundingBox): boolean;
  /**
   * Duplicates this OrientedBoundingBox instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new OrientedBoundingBox instance if one was not provided.
   */
  clone(result?: OrientedBoundingBox): OrientedBoundingBox;
  /**
   * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The right hand side OrientedBoundingBox.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(right?: OrientedBoundingBox): boolean;
}

/**
* The viewing frustum is defined by 6 planes.
* Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
* define the unit vector normal to the plane, and the w component is the distance of the
* plane from the origin/camera position.
* @example
* const maxRadii = ellipsoid.maximumRadius;
*
* const frustum = new SuperMap.OrthographicFrustum();
* frustum.near = 0.01 * maxRadii;
* frustum.far = 50.0 * maxRadii;
* @param [options] - An object with the following properties:
* @param [options.width] - The width of the frustum in meters.
* @param [options.aspectRatio] - The aspect ratio of the frustum's width to it's height.
* @param [options.near = 1.0] - The distance of the near plane.
* @param [options.far = 500000000.0] - The distance of the far plane.
*/
export class OrthographicFrustum {
  constructor(options?: {
    width?: number;
    aspectRatio?: number;
    near?: number;
    far?: number;
  });
  /**
   * The horizontal width of the frustum in meters.
   */
  width: number;
  /**
   * The aspect ratio of the frustum's width to it's height.
   */
  aspectRatio: number;
  /**
   * The distance of the near plane.
   */
  near: number;
  /**
   * The distance of the far plane.
   */
  far: number;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: OrthographicFrustum, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new OrthographicFrustum instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: OrthographicFrustum): OrthographicFrustum;
  /**
   * Gets the orthographic projection matrix computed from the view frustum.
   */
  readonly projectionMatrix: Matrix4;
  /**
   * Creates a culling volume for this frustum.
   * @example
   * // Check if a bounding volume intersects the frustum.
   * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
   * const intersect = cullingVolume.computeVisibility(boundingVolume);
   * @param position - The eye position.
   * @param direction - The view direction.
   * @param up - The up direction.
   * @returns A culling volume at the given position and orientation.
   */
  computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;
  /**
   * Returns the pixel's width and height in meters.
   * @example
   * // Example 1
   * // Get the width and height of a pixel.
   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new SuperMap.Cartesian2());
   * @param drawingBufferWidth - The width of the drawing buffer.
   * @param drawingBufferHeight - The height of the drawing buffer.
   * @param distance - The distance to the near plane in meters.
   * @param pixelRatio - The scaling factor from pixel space to coordinate space.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
   */
  getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, pixelRatio: number, result: Cartesian2): Cartesian2;
  /**
   * Returns a duplicate of a OrthographicFrustum instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new OrthographicFrustum instance if one was not provided.
   */
  clone(result?: OrthographicFrustum): OrthographicFrustum;
  /**
   * Compares the provided OrthographicFrustum componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The right hand side OrthographicFrustum.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(other?: OrthographicFrustum): boolean;
  /**
   * Compares the provided OrthographicFrustum componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param other - The right hand side OrthographicFrustum.
   * @param relativeEpsilon - The relative epsilon tolerance to use for equality testing.
   * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(other: OrthographicFrustum, relativeEpsilon: number, absoluteEpsilon?: number): boolean;
}

/**
* The viewing frustum is defined by 6 planes.
* Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
* define the unit vector normal to the plane, and the w component is the distance of the
* plane from the origin/camera position.
* @example
* const maxRadii = ellipsoid.maximumRadius;
*
* const frustum = new SuperMap.OrthographicOffCenterFrustum();
* frustum.right = maxRadii * SuperMap.Math.PI;
* frustum.left = -c.frustum.right;
* frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);
* frustum.bottom = -c.frustum.top;
* frustum.near = 0.01 * maxRadii;
* frustum.far = 50.0 * maxRadii;
* @param [options] - An object with the following properties:
* @param [options.left] - The left clipping plane distance.
* @param [options.right] - The right clipping plane distance.
* @param [options.top] - The top clipping plane distance.
* @param [options.bottom] - The bottom clipping plane distance.
* @param [options.near = 1.0] - The near clipping plane distance.
* @param [options.far = 500000000.0] - The far clipping plane distance.
*/
export class OrthographicOffCenterFrustum {
  constructor(options?: {
    left?: number;
    right?: number;
    top?: number;
    bottom?: number;
    near?: number;
    far?: number;
  });
  /**
   * The left clipping plane.
   */
  left: number;
  /**
   * The right clipping plane.
   */
  right: number;
  /**
   * The top clipping plane.
   */
  top: number;
  /**
   * The bottom clipping plane.
   */
  bottom: number;
  /**
   * The distance of the near plane.
   */
  near: number;
  /**
   * The distance of the far plane.
   */
  far: number;
  /**
   * Gets the orthographic projection matrix computed from the view frustum.
   */
  readonly projectionMatrix: Matrix4;
  /**
   * Creates a culling volume for this frustum.
   * @example
   * // Check if a bounding volume intersects the frustum.
   * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
   * const intersect = cullingVolume.computeVisibility(boundingVolume);
   * @param position - The eye position.
   * @param direction - The view direction.
   * @param up - The up direction.
   * @returns A culling volume at the given position and orientation.
   */
  computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;
  /**
   * Returns the pixel's width and height in meters.
   * @example
   * // Example 1
   * // Get the width and height of a pixel.
   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new SuperMap.Cartesian2());
   * @param drawingBufferWidth - The width of the drawing buffer.
   * @param drawingBufferHeight - The height of the drawing buffer.
   * @param distance - The distance to the near plane in meters.
   * @param pixelRatio - The scaling factor from pixel space to coordinate space.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
   */
  getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, pixelRatio: number, result: Cartesian2): Cartesian2;
  /**
   * Returns a duplicate of a OrthographicOffCenterFrustum instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new OrthographicOffCenterFrustum instance if one was not provided.
   */
  clone(result?: OrthographicOffCenterFrustum): OrthographicOffCenterFrustum;
  /**
   * Compares the provided OrthographicOffCenterFrustum componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The right hand side OrthographicOffCenterFrustum.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(other?: OrthographicOffCenterFrustum): boolean;
  /**
   * Compares the provided OrthographicOffCenterFrustum componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param other - The right hand side OrthographicOffCenterFrustum.
   * @param relativeEpsilon - The relative epsilon tolerance to use for equality testing.
   * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(other: OrthographicOffCenterFrustum, relativeEpsilon: number, absoluteEpsilon?: number): boolean;
}

export namespace Packable {
  /**
   * The number of elements used to pack the object into an array.
   */
  var packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   */
  function pack(value: any, array: number[], startingIndex?: number): void;
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Object instance if one was not provided.
   */
  function unpack(array: number[], startingIndex?: number, result?: any): any;
}

/**
* Static interface for types which can store their values as packed
* elements in an array.  These methods and properties are expected to be
* defined on a constructor function.
*/
export interface Packable {
}

/**
* Static interface for {@link Packable} types which are interpolated in a
* different representation than their packed value.  These methods and
* properties are expected to be defined on a constructor function.
*/
export namespace PackableForInterpolation {
  /**
   * The number of elements used to store the object into an array in its interpolatable form.
   */
  var packedInterpolationLength: number;
  /**
   * Converts a packed array into a form suitable for interpolation.
   * @param packedArray - The packed array.
   * @param [startingIndex = 0] - The index of the first element to be converted.
   * @param [lastIndex = packedArray.length] - The index of the last element to be converted.
   * @param [result] - The object into which to store the result.
   */
  function convertPackedArrayForInterpolation(packedArray: number[], startingIndex?: number, lastIndex?: number, result?: number[]): void;
  /**
   * Retrieves an instance from a packed array converted with {@link PackableForInterpolation.convertPackedArrayForInterpolation}.
   * @param array - The array previously packed for interpolation.
   * @param sourceArray - The original packed array.
   * @param [startingIndex = 0] - The startingIndex used to convert the array.
   * @param [lastIndex = packedArray.length] - The lastIndex used to convert the array.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Object instance if one was not provided.
   */
  function unpackInterpolationResult(array: number[], sourceArray: number[], startingIndex?: number, lastIndex?: number, result?: any): any;
}

/**
* Provides geocoding via a {@link https://pelias.io/|Pelias} server.
* @example
* // Configure a Viewer to use the Pelias server hosted by https://geocode.earth/
* const viewer = new SuperMap.Viewer('CesiumContainer', {
*   geocoder: new SuperMap.PeliasGeocoderService(new SuperMap.Resource({
*     url: 'https://api.geocode.earth/v1/',
*       queryParameters: {
*         api_key: '<Your geocode.earth API key>'
*     }
*   }))
* });
* @param url - The endpoint to the Pelias server.
*/
export class PeliasGeocoderService {
  constructor(url: Resource | string);
  /**
   * The Resource used to access the Pelias endpoint.
   */
  readonly url: Resource;
  /**
   * @param query - The query to be sent to the geocoder service
   * @param [type = GeocodeType.SEARCH] - The type of geocode to perform.
   */
  geocode(query: string, type?: GeocodeType): Promise<GeocoderService.Result[]>;
}

/**
* The viewing frustum is defined by 6 planes.
* Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
* define the unit vector normal to the plane, and the w component is the distance of the
* plane from the origin/camera position.
* @example
* const frustum = new SuperMap.PerspectiveFrustum({
*     fov : SuperMap.Math.PI_OVER_THREE,
*     aspectRatio : canvas.clientWidth / canvas.clientHeight
*     near : 1.0,
*     far : 1000.0
* });
* @param [options] - An object with the following properties:
* @param [options.fov] - The angle of the field of view (FOV), in radians.
* @param [options.aspectRatio] - The aspect ratio of the frustum's width to it's height.
* @param [options.near = 1.0] - The distance of the near plane.
* @param [options.far = 500000000.0] - The distance of the far plane.
* @param [options.xOffset = 0.0] - The offset in the x direction.
* @param [options.yOffset = 0.0] - The offset in the y direction.
*/
export class PerspectiveFrustum {
  constructor(options?: {
    fov?: number;
    aspectRatio?: number;
    near?: number;
    far?: number;
    xOffset?: number;
    yOffset?: number;
  });
  /**
   * The angle of the field of view (FOV), in radians.  This angle will be used
   * as the horizontal FOV if the width is greater than the height, otherwise
   * it will be the vertical FOV.
   */
  fov: number;
  /**
   * The aspect ratio of the frustum's width to it's height.
   */
  aspectRatio: number;
  /**
   * The distance of the near plane.
   */
  near: number;
  /**
   * The distance of the far plane.
   */
  far: number;
  /**
   * Offsets the frustum in the x direction.
   */
  xOffset: number;
  /**
   * Offsets the frustum in the y direction.
   */
  yOffset: number;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: PerspectiveFrustum, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: PerspectiveFrustum): PerspectiveFrustum;
  /**
   * Gets the perspective projection matrix computed from the view frustum.
   */
  readonly projectionMatrix: Matrix4;
  /**
   * The perspective projection matrix computed from the view frustum with an infinite far plane.
   */
  readonly infiniteProjectionMatrix: Matrix4;
  /**
   * Gets the angle of the vertical field of view, in radians.
   */
  readonly fovy: number;
  /**
   * Creates a culling volume for this frustum.
   * @example
   * // Check if a bounding volume intersects the frustum.
   * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
   * const intersect = cullingVolume.computeVisibility(boundingVolume);
   * @param position - The eye position.
   * @param direction - The view direction.
   * @param up - The up direction.
   * @returns A culling volume at the given position and orientation.
   */
  computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;
  /**
   * Returns the pixel's width and height in meters.
   * @example
   * // Example 1
   * // Get the width and height of a pixel.
   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new SuperMap.Cartesian2());
   * @example
   * // Example 2
   * // Get the width and height of a pixel if the near plane was set to 'distance'.
   * // For example, get the size of a pixel of an image on a billboard.
   * const position = camera.position;
   * const direction = camera.direction;
   * const toCenter = SuperMap.Cartesian3.subtract(primitive.boundingVolume.center, position, new SuperMap.Cartesian3());      // vector from camera to a primitive
   * const toCenterProj = SuperMap.Cartesian3.multiplyByScalar(direction, SuperMap.Cartesian3.dot(direction, toCenter), new SuperMap.Cartesian3()); // project vector onto camera direction vector
   * const distance = SuperMap.Cartesian3.magnitude(toCenterProj);
   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new SuperMap.Cartesian2());
   * @param drawingBufferWidth - The width of the drawing buffer.
   * @param drawingBufferHeight - The height of the drawing buffer.
   * @param distance - The distance to the near plane in meters.
   * @param pixelRatio - The scaling factor from pixel space to coordinate space.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
   */
  getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, pixelRatio: number, result: Cartesian2): Cartesian2;
  /**
   * Returns a duplicate of a PerspectiveFrustum instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
   */
  clone(result?: PerspectiveFrustum): PerspectiveFrustum;
  /**
   * Compares the provided PerspectiveFrustum componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The right hand side PerspectiveFrustum.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(other?: PerspectiveFrustum): boolean;
  /**
   * Compares the provided PerspectiveFrustum componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param other - The right hand side PerspectiveFrustum.
   * @param relativeEpsilon - The relative epsilon tolerance to use for equality testing.
   * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(other: PerspectiveFrustum, relativeEpsilon: number, absoluteEpsilon?: number): boolean;
}

/**
* The viewing frustum is defined by 6 planes.
* Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
* define the unit vector normal to the plane, and the w component is the distance of the
* plane from the origin/camera position.
* @example
* const frustum = new SuperMap.PerspectiveOffCenterFrustum({
*     left : -1.0,
*     right : 1.0,
*     top : 1.0,
*     bottom : -1.0,
*     near : 1.0,
*     far : 100.0
* });
* @param [options] - An object with the following properties:
* @param [options.left] - The left clipping plane distance.
* @param [options.right] - The right clipping plane distance.
* @param [options.top] - The top clipping plane distance.
* @param [options.bottom] - The bottom clipping plane distance.
* @param [options.near = 1.0] - The near clipping plane distance.
* @param [options.far = 500000000.0] - The far clipping plane distance.
*/
export class PerspectiveOffCenterFrustum {
  constructor(options?: {
    left?: number;
    right?: number;
    top?: number;
    bottom?: number;
    near?: number;
    far?: number;
  });
  /**
   * Defines the left clipping plane.
   */
  left: number;
  /**
   * Defines the right clipping plane.
   */
  right: number;
  /**
   * Defines the top clipping plane.
   */
  top: number;
  /**
   * Defines the bottom clipping plane.
   */
  bottom: number;
  /**
   * The distance of the near plane.
   */
  near: number;
  /**
   * The distance of the far plane.
   */
  far: number;
  /**
   * Gets the perspective projection matrix computed from the view frustum.
   */
  readonly projectionMatrix: Matrix4;
  /**
   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.
   */
  readonly infiniteProjectionMatrix: Matrix4;
  /**
   * Creates a culling volume for this frustum.
   * @example
   * // Check if a bounding volume intersects the frustum.
   * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
   * const intersect = cullingVolume.computeVisibility(boundingVolume);
   * @param position - The eye position.
   * @param direction - The view direction.
   * @param up - The up direction.
   * @returns A culling volume at the given position and orientation.
   */
  computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;
  /**
   * Returns the pixel's width and height in meters.
   * @example
   * // Example 1
   * // Get the width and height of a pixel.
   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new SuperMap.Cartesian2());
   * @example
   * // Example 2
   * // Get the width and height of a pixel if the near plane was set to 'distance'.
   * // For example, get the size of a pixel of an image on a billboard.
   * const position = camera.position;
   * const direction = camera.direction;
   * const toCenter = SuperMap.Cartesian3.subtract(primitive.boundingVolume.center, position, new SuperMap.Cartesian3());      // vector from camera to a primitive
   * const toCenterProj = SuperMap.Cartesian3.multiplyByScalar(direction, SuperMap.Cartesian3.dot(direction, toCenter), new SuperMap.Cartesian3()); // project vector onto camera direction vector
   * const distance = SuperMap.Cartesian3.magnitude(toCenterProj);
   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new SuperMap.Cartesian2());
   * @param drawingBufferWidth - The width of the drawing buffer.
   * @param drawingBufferHeight - The height of the drawing buffer.
   * @param distance - The distance to the near plane in meters.
   * @param pixelRatio - The scaling factor from pixel space to coordinate space.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
   */
  getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, pixelRatio: number, result: Cartesian2): Cartesian2;
  /**
   * Returns a duplicate of a PerspectiveOffCenterFrustum instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
   */
  clone(result?: PerspectiveOffCenterFrustum): PerspectiveOffCenterFrustum;
  /**
   * Compares the provided PerspectiveOffCenterFrustum componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The right hand side PerspectiveOffCenterFrustum.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(other?: PerspectiveOffCenterFrustum): boolean;
  /**
   * Compares the provided PerspectiveOffCenterFrustum componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param other - The right hand side PerspectiveOffCenterFrustum.
   * @param relativeEpsilon - The relative epsilon tolerance to use for equality testing.
   * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(other: PerspectiveOffCenterFrustum, relativeEpsilon: number, absoluteEpsilon?: number): boolean;
}

/**
* A utility class for generating custom map pins as canvas elements.
* <br /><br />
* <div align='center'>
* <img src='Images/PinBuilder.png' width='500'/><br />
* Example pins generated using both the maki icon set, which ships with SuperMap, and single character text.
* </div>
*/
export class PinBuilder {
  constructor();
  /**
   * Creates an empty pin of the specified color and size.
   * @param color - The color of the pin.
   * @param size - The size of the pin, in pixels.
   * @returns The canvas element that represents the generated pin.
   */
  fromColor(color: Color, size: number): HTMLCanvasElement;
  /**
   * Creates a pin with the specified icon, color, and size.
   * @param url - The url of the image to be stamped onto the pin.
   * @param color - The color of the pin.
   * @param size - The size of the pin, in pixels.
   * @returns The canvas element or a Promise to the canvas element that represents the generated pin.
   */
  fromUrl(url: Resource | string, color: Color, size: number): HTMLCanvasElement | Promise<HTMLCanvasElement>;
  /**
   * Creates a pin with the specified {@link https://www.mapbox.com/maki/|maki} icon identifier, color, and size.
   * @param id - The id of the maki icon to be stamped onto the pin.
   * @param color - The color of the pin.
   * @param size - The size of the pin, in pixels.
   * @returns The canvas element or a Promise to the canvas element that represents the generated pin.
   */
  fromMakiIconId(id: string, color: Color, size: number): HTMLCanvasElement | Promise<HTMLCanvasElement>;
  /**
   * Creates a pin with the specified text, color, and size.  The text will be sized to be as large as possible
   * while still being contained completely within the pin.
   * @param text - The text to be stamped onto the pin.
   * @param color - The color of the pin.
   * @param size - The size of the pin, in pixels.
   * @returns The canvas element that represents the generated pin.
   */
  fromText(text: string, color: Color, size: number): HTMLCanvasElement;
}

/**
* The format of a pixel, i.e., the number of components it has and what they represent.
*/
export enum PixelFormat {
  /**
   * A pixel format containing a depth value.
   */
  DEPTH_COMPONENT = WebGLConstants.DEPTH_COMPONENT,
  /**
   * A pixel format containing a depth and stencil value, most often used with {@link PixelDatatype.UNSIGNED_INT_24_8}.
   */
  DEPTH_STENCIL = WebGLConstants.DEPTH_STENCIL,
  /**
   * A pixel format containing an alpha channel.
   */
  ALPHA = WebGLConstants.ALPHA,
  /**
   * A pixel format containing red, green, and blue channels.
   */
  RGB = WebGLConstants.RGB,
  /**
   * A pixel format containing red, green, blue, and alpha channels.
   */
  RGBA = WebGLConstants.RGBA,
  /**
   * A pixel format containing a luminance (intensity) channel.
   */
  LUMINANCE = WebGLConstants.LUMINANCE,
  /**
   * A pixel format containing luminance (intensity) and alpha channels.
   */
  LUMINANCE_ALPHA = WebGLConstants.LUMINANCE_ALPHA,
  /**
   * A pixel format containing red, green, and blue channels that is DXT1 compressed.
   */
  RGB_DXT1 = WebGLConstants.COMPRESSED_RGB_S3TC_DXT1_EXT,
  /**
   * A pixel format containing red, green, blue, and alpha channels that is DXT1 compressed.
   */
  RGBA_DXT1 = WebGLConstants.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  /**
   * A pixel format containing red, green, blue, and alpha channels that is DXT3 compressed.
   */
  RGBA_DXT3 = WebGLConstants.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  /**
   * A pixel format containing red, green, blue, and alpha channels that is DXT5 compressed.
   */
  RGBA_DXT5 = WebGLConstants.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  /**
   * A pixel format containing red, green, and blue channels that is PVR 4bpp compressed.
   */
  RGB_PVRTC_4BPPV1 = WebGLConstants.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
  /**
   * A pixel format containing red, green, and blue channels that is PVR 2bpp compressed.
   */
  RGB_PVRTC_2BPPV1 = WebGLConstants.COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
  /**
   * A pixel format containing red, green, blue, and alpha channels that is PVR 4bpp compressed.
   */
  RGBA_PVRTC_4BPPV1 = WebGLConstants.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
  /**
   * A pixel format containing red, green, blue, and alpha channels that is PVR 2bpp compressed.
   */
  RGBA_PVRTC_2BPPV1 = WebGLConstants.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
  /**
   * A pixel format containing red, green, blue, and alpha channels that is ASTC compressed.
   */
  RGBA_ASTC = WebGLConstants.COMPRESSED_RGBA_ASTC_4x4_WEBGL,
  /**
   * A pixel format containing red, green, and blue channels that is ETC1 compressed.
   */
  RGB_ETC1 = WebGLConstants.COMPRESSED_RGB_ETC1_WEBGL,
  /**
   * A pixel format containing red, green, and blue channels that is ETC2 compressed.
   */
  RGB8_ETC2 = WebGLConstants.COMPRESSED_RGB8_ETC2,
  /**
   * A pixel format containing red, green, blue, and alpha channels that is ETC2 compressed.
   */
  RGBA8_ETC2_EAC = WebGLConstants.COMPRESSED_RGBA8_ETC2_EAC,
  /**
   * A pixel format containing red, green, blue, and alpha channels that is BC7 compressed.
   */
  RGBA_BC7 = WebGLConstants.COMPRESSED_RGBA_BPTC_UNORM
}

/**
 * A plane in Hessian Normal Form defined by
 * <pre>
 * ax + by + cz + d = 0
 * </pre>
 * where (a, b, c) is the plane's <code>normal</code>, d is the signed
 * <code>distance</code> to the plane, and (x, y, z) is any point on
 * the plane.
 * @example
 * // The plane x=0
 * const plane = new SuperMap.Plane(SuperMap.Cartesian3.UNIT_X, 0.0);
 * @param normal - The plane's normal (normalized).
 * @param distance - The shortest distance from the origin to the plane.  The sign of
 * <code>distance</code> determines which side of the plane the origin
 * is on.  If <code>distance</code> is positive, the origin is in the half-space
 * in the direction of the normal; if negative, the origin is in the half-space
 * opposite to the normal; if zero, the plane passes through the origin.
 */
export class Plane {
  constructor(normal: Cartesian3, distance: number);
  /**
   * The plane's normal.
   */
  normal: Cartesian3;
  /**
   * The shortest distance from the origin to the plane.  The sign of
   * <code>distance</code> determines which side of the plane the origin
   * is on.  If <code>distance</code> is positive, the origin is in the half-space
   * in the direction of the normal; if negative, the origin is in the half-space
   * opposite to the normal; if zero, the plane passes through the origin.
   */
  distance: number;
  /**
   * Creates a plane from a normal and a point on the plane.
   * @example
   * const point = SuperMap.Cartesian3.fromDegrees(-72.0, 40.0);
   * const normal = ellipsoid.geodeticSurfaceNormal(point);
   * const tangentPlane = SuperMap.Plane.fromPointNormal(point, normal);
   * @param point - The point on the plane.
   * @param normal - The plane's normal (normalized).
   * @param [result] - The object onto which to store the result.
   * @returns A new plane instance or the modified result parameter.
   */
  fromPointNormal(point: Cartesian3, normal: Cartesian3, result?: Plane): Plane;
  /**
   * Creates a plane from the general equation
   * @param coefficients - The plane's normal (normalized).
   * @param [result] - The object onto which to store the result.
   * @returns A new plane instance or the modified result parameter.
   */
  fromCartesian4(coefficients: Cartesian4, result?: Plane): Plane;
  /**
   * Computes the signed shortest distance of a point to a plane.
   * The sign of the distance determines which side of the plane the point
   * is on.  If the distance is positive, the point is in the half-space
   * in the direction of the normal; if negative, the point is in the half-space
   * opposite to the normal; if zero, the plane passes through the point.
   * @param plane - The plane.
   * @param point - The point.
   * @returns The signed shortest distance of the point to the plane.
   */
  getPointDistance(plane: Plane, point: Cartesian3): number;
  /**
   * Projects a point onto the plane.
   * @param plane - The plane to project the point onto
   * @param point - The point to project onto the plane
   * @param [result] - The result point.  If undefined, a new Cartesian3 will be created.
   * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
   */
  projectPointOntoPlane(plane: Plane, point: Cartesian3, result?: Cartesian3): Cartesian3;
  /**
   * Transforms the plane by the given transformation matrix.
   * @param plane - The plane.
   * @param transform - The transformation matrix.
   * @param [result] - The object into which to store the result.
   * @returns The plane transformed by the given transformation matrix.
   */
  transform(plane: Plane, transform: Matrix4, result?: Plane): Plane;
  /**
   * Duplicates a Plane instance.
   * @param plane - The plane to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Plane instance if one was not provided.
   */
  clone(plane: Plane, result?: Plane): Plane;
  /**
   * Compares the provided Planes by normal and distance and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param left - The first plane.
   * @param right - The second plane.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left: Plane, right: Plane): boolean;
  /**
   * A constant initialized to the XY plane passing through the origin, with normal in positive Z.
   */
  readonly ORIGIN_XY_PLANE: Plane;
  /**
   * A constant initialized to the YZ plane passing through the origin, with normal in positive X.
   */
  readonly ORIGIN_YZ_PLANE: Plane;
  /**
   * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.
   */
  readonly ORIGIN_ZX_PLANE: Plane;
}

/**
* Describes geometry representing a plane centered at the origin, with a unit width and length.
* @example
* const planeGeometry = new SuperMap.PlaneGeometry({
*   vertexFormat : SuperMap.VertexFormat.POSITION_ONLY
* });
* @param [options] - Object with the following properties:
* @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
*/
export class PlaneGeometry {
  constructor(options?: {
    vertexFormat?: VertexFormat;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: PlaneGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new PlaneGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: PlaneGeometry): PlaneGeometry;
  /**
   * Computes the geometric representation of a plane, including its vertices, indices, and a bounding sphere.
   * @param planeGeometry - A description of the plane.
   * @returns The computed vertices and indices.
   */
  createGeometry(planeGeometry: PlaneGeometry): Geometry | undefined;
}

/**
* Describes geometry representing the outline of a plane centered at the origin, with a unit width and length.
*/
export class PlaneOutlineGeometry {
  constructor();
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @returns The array that was packed into
   */
  pack(value: PlaneOutlineGeometry, array: number[]): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new PlaneOutlineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: PlaneOutlineGeometry): PlaneOutlineGeometry;
  /**
   * Computes the geometric representation of an outline of a plane, including its vertices, indices, and a bounding sphere.
   * @returns The computed vertices and indices.
   */
  createGeometry(): Geometry | undefined;
}

/**
* A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
* @example
* // 1. create a polygon from points
* const polygon = new SuperMap.PolygonGeometry({
*   polygonHierarchy : new SuperMap.PolygonHierarchy(
*     SuperMap.Cartesian3.fromDegreesArray([
*       -72.0, 40.0,
*       -70.0, 35.0,
*       -75.0, 30.0,
*       -70.0, 30.0,
*       -68.0, 40.0
*     ])
*   )
* });
* const geometry = SuperMap.PolygonGeometry.createGeometry(polygon);
*
* // 2. create a nested polygon with holes
* const polygonWithHole = new SuperMap.PolygonGeometry({
*   polygonHierarchy : new SuperMap.PolygonHierarchy(
*     SuperMap.Cartesian3.fromDegreesArray([
*       -109.0, 30.0,
*       -95.0, 30.0,
*       -95.0, 40.0,
*       -109.0, 40.0
*     ]),
*     [new SuperMap.PolygonHierarchy(
*       SuperMap.Cartesian3.fromDegreesArray([
*         -107.0, 31.0,
*         -107.0, 39.0,
*         -97.0, 39.0,
*         -97.0, 31.0
*       ]),
*       [new SuperMap.PolygonHierarchy(
*         SuperMap.Cartesian3.fromDegreesArray([
*           -105.0, 33.0,
*           -99.0, 33.0,
*           -99.0, 37.0,
*           -105.0, 37.0
*         ]),
*         [new SuperMap.PolygonHierarchy(
*           SuperMap.Cartesian3.fromDegreesArray([
*             -103.0, 34.0,
*             -101.0, 34.0,
*             -101.0, 36.0,
*             -103.0, 36.0
*           ])
*         )]
*       )]
*     )]
*   )
* });
* const geometry = SuperMap.PolygonGeometry.createGeometry(polygonWithHole);
*
* // 3. create extruded polygon
* const extrudedPolygon = new SuperMap.PolygonGeometry({
*   polygonHierarchy : new SuperMap.PolygonHierarchy(
*     SuperMap.Cartesian3.fromDegreesArray([
*       -72.0, 40.0,
*       -70.0, 35.0,
*       -75.0, 30.0,
*       -70.0, 30.0,
*       -68.0, 40.0
*     ])
*   ),
*   extrudedHeight: 300000
* });
* const geometry = SuperMap.PolygonGeometry.createGeometry(extrudedPolygon);
* @param options - Object with the following properties:
* @param options.polygonHierarchy - A polygon hierarchy that can include holes.
* @param [options.height = 0.0] - The distance in meters between the polygon and the ellipsoid surface.
* @param [options.extrudedHeight] - The distance in meters between the polygon's extruded face and the ellipsoid surface.
* @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
* @param [options.stRotation = 0.0] - The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
* @param [options.perPositionHeight = false] - Use the height of options.positions for each position instead of using options.height to determine the height.
* @param [options.closeTop = true] - When false, leaves off the top of an extruded polygon open.
* @param [options.closeBottom = true] - When false, leaves off the bottom of an extruded polygon open.
* @param [options.arcType = ArcType.GEODESIC] - The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
* @param [options.textureCoordinates] - Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.
*/
export class PolygonGeometry {
  constructor(options: {
    polygonHierarchy: PolygonHierarchy;
    height?: number;
    extrudedHeight?: number;
    vertexFormat?: VertexFormat;
    stRotation?: number;
    ellipsoid?: Ellipsoid;
    granularity?: number;
    perPositionHeight?: boolean;
    closeTop?: boolean;
    closeBottom?: boolean;
    arcType?: ArcType;
    textureCoordinates?: PolygonHierarchy;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
   * @example
   * // create a polygon from points
   * const polygon = SuperMap.PolygonGeometry.fromPositions({
   *   positions : SuperMap.Cartesian3.fromDegreesArray([
   *     -72.0, 40.0,
   *     -70.0, 35.0,
   *     -75.0, 30.0,
   *     -70.0, 30.0,
   *     -68.0, 40.0
   *   ])
   * });
   * const geometry = SuperMap.PolygonGeometry.createGeometry(polygon);
   * @param options - Object with the following properties:
   * @param options.positions - An array of positions that defined the corner points of the polygon.
   * @param [options.height = 0.0] - The height of the polygon.
   * @param [options.extrudedHeight] - The height of the polygon extrusion.
   * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
   * @param [options.stRotation = 0.0] - The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
   * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
   * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
   * @param [options.perPositionHeight = false] - Use the height of options.positions for each position instead of using options.height to determine the height.
   * @param [options.closeTop = true] - When false, leaves off the top of an extruded polygon open.
   * @param [options.closeBottom = true] - When false, leaves off the bottom of an extruded polygon open.
   * @param [options.arcType = ArcType.GEODESIC] - The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
   * @param [options.textureCoordinates] - Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.
   */
  fromPositions(options: {
    positions: Cartesian3[];
    height?: number;
    extrudedHeight?: number;
    vertexFormat?: VertexFormat;
    stRotation?: number;
    ellipsoid?: Ellipsoid;
    granularity?: number;
    perPositionHeight?: boolean;
    closeTop?: boolean;
    closeBottom?: boolean;
    arcType?: ArcType;
    textureCoordinates?: PolygonHierarchy;
  }): PolygonGeometry;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: PolygonGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   */
  unpack(array: number[], startingIndex?: number, result?: PolygonGeometry): void;
  /**
   * Returns the bounding rectangle given the provided options
   * @param options - Object with the following properties:
   * @param options.polygonHierarchy - A polygon hierarchy that can include holes.
   * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.
   * @param [options.arcType = ArcType.GEODESIC] - The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
   * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
   * @param [result] - An object in which to store the result.
   * @returns The result rectangle
   */
  computeRectangle(options: {
    polygonHierarchy: PolygonHierarchy;
    granularity?: number;
    arcType?: ArcType;
    ellipsoid?: Ellipsoid;
  }, result?: Rectangle): Rectangle;
  /**
   * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.
   * @param polygonGeometry - A description of the polygon.
   * @returns The computed vertices and indices.
   */
  createGeometry(polygonGeometry: PolygonGeometry): Geometry | undefined;
}

/**
* An hierarchy of linear rings which define a polygon and its holes.
* The holes themselves may also have holes which nest inner polygons.
* @param [positions] - A linear ring defining the outer boundary of the polygon or hole.
* @param [holes] - An array of polygon hierarchies defining holes in the polygon.
*/
export class PolygonHierarchy {
  constructor(positions?: Cartesian3[], holes?: PolygonHierarchy[]);
  /**
   * A linear ring defining the outer boundary of the polygon or hole.
   */
  positions: Cartesian3[];
  /**
   * An array of polygon hierarchies defining holes in the polygon.
   */
  holes: PolygonHierarchy[];
}

/**
* A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.
* @example
* // 1. create a polygon outline from points
* const polygon = new SuperMap.PolygonOutlineGeometry({
*   polygonHierarchy : new SuperMap.PolygonHierarchy(
*     SuperMap.Cartesian3.fromDegreesArray([
*       -72.0, 40.0,
*       -70.0, 35.0,
*       -75.0, 30.0,
*       -70.0, 30.0,
*       -68.0, 40.0
*     ])
*   )
* });
* const geometry = SuperMap.PolygonOutlineGeometry.createGeometry(polygon);
*
* // 2. create a nested polygon with holes outline
* const polygonWithHole = new SuperMap.PolygonOutlineGeometry({
*   polygonHierarchy : new SuperMap.PolygonHierarchy(
*     SuperMap.Cartesian3.fromDegreesArray([
*       -109.0, 30.0,
*       -95.0, 30.0,
*       -95.0, 40.0,
*       -109.0, 40.0
*     ]),
*     [new SuperMap.PolygonHierarchy(
*       SuperMap.Cartesian3.fromDegreesArray([
*         -107.0, 31.0,
*         -107.0, 39.0,
*         -97.0, 39.0,
*         -97.0, 31.0
*       ]),
*       [new SuperMap.PolygonHierarchy(
*         SuperMap.Cartesian3.fromDegreesArray([
*           -105.0, 33.0,
*           -99.0, 33.0,
*           -99.0, 37.0,
*           -105.0, 37.0
*         ]),
*         [new SuperMap.PolygonHierarchy(
*           SuperMap.Cartesian3.fromDegreesArray([
*             -103.0, 34.0,
*             -101.0, 34.0,
*             -101.0, 36.0,
*             -103.0, 36.0
*           ])
*         )]
*       )]
*     )]
*   )
* });
* const geometry = SuperMap.PolygonOutlineGeometry.createGeometry(polygonWithHole);
*
* // 3. create extruded polygon outline
* const extrudedPolygon = new SuperMap.PolygonOutlineGeometry({
*   polygonHierarchy : new SuperMap.PolygonHierarchy(
*     SuperMap.Cartesian3.fromDegreesArray([
*       -72.0, 40.0,
*       -70.0, 35.0,
*       -75.0, 30.0,
*       -70.0, 30.0,
*       -68.0, 40.0
*     ])
*   ),
*   extrudedHeight: 300000
* });
* const geometry = SuperMap.PolygonOutlineGeometry.createGeometry(extrudedPolygon);
* @param options - Object with the following properties:
* @param options.polygonHierarchy - A polygon hierarchy that can include holes.
* @param [options.height = 0.0] - The distance in meters between the polygon and the ellipsoid surface.
* @param [options.extrudedHeight] - The distance in meters between the polygon's extruded face and the ellipsoid surface.
* @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
* @param [options.perPositionHeight = false] - Use the height of options.positions for each position instead of using options.height to determine the height.
* @param [options.arcType = ArcType.GEODESIC] - The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
*/
export class PolygonOutlineGeometry {
  constructor(options: {
    polygonHierarchy: PolygonHierarchy;
    height?: number;
    extrudedHeight?: number;
    vertexFormat?: VertexFormat;
    ellipsoid?: Ellipsoid;
    granularity?: number;
    perPositionHeight?: boolean;
    arcType?: ArcType;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: PolygonOutlineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: PolygonOutlineGeometry): PolygonOutlineGeometry;
  /**
   * A description of a polygon outline from an array of positions.
   * @example
   * // create a polygon from points
   * const polygon = SuperMap.PolygonOutlineGeometry.fromPositions({
   *   positions : SuperMap.Cartesian3.fromDegreesArray([
   *     -72.0, 40.0,
   *     -70.0, 35.0,
   *     -75.0, 30.0,
   *     -70.0, 30.0,
   *     -68.0, 40.0
   *   ])
   * });
   * const geometry = SuperMap.PolygonOutlineGeometry.createGeometry(polygon);
   * @param options - Object with the following properties:
   * @param options.positions - An array of positions that defined the corner points of the polygon.
   * @param [options.height = 0.0] - The height of the polygon.
   * @param [options.extrudedHeight] - The height of the polygon extrusion.
   * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
   * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
   * @param [options.perPositionHeight = false] - Use the height of options.positions for each position instead of using options.height to determine the height.
   * @param [options.arcType = ArcType.GEODESIC] - The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.
   */
  fromPositions(options: {
    positions: Cartesian3[];
    height?: number;
    extrudedHeight?: number;
    ellipsoid?: Ellipsoid;
    granularity?: number;
    perPositionHeight?: boolean;
    arcType?: ArcType;
  }): PolygonOutlineGeometry;
  /**
   * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.
   * @param polygonGeometry - A description of the polygon outline.
   * @returns The computed vertices and indices.
   */
  createGeometry(polygonGeometry: PolygonOutlineGeometry): Geometry | undefined;
}

/**
* A description of a polyline modeled as a line strip; the first two positions define a line segment,
* and each additional position defines a line segment from the previous position. The polyline is capable of
* displaying with a material.
* @example
* // A polyline with two connected line segments
* const polyline = new SuperMap.PolylineGeometry({
*   positions : SuperMap.Cartesian3.fromDegreesArray([
*     0.0, 0.0,
*     5.0, 0.0,
*     5.0, 5.0
*   ]),
*   width : 10.0
* });
* const geometry = SuperMap.PolylineGeometry.createGeometry(polyline);
* @param options - Object with the following properties:
* @param options.positions - An array of {@link Cartesian3} defining the positions in the polyline as a line strip.
* @param [options.width = 1.0] - The width in pixels.
* @param [options.colors] - An Array of {@link Color} defining the per vertex or per segment colors.
* @param [options.colorsPerVertex = false] - A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.
* @param [options.arcType = ArcType.GEODESIC] - The type of line the polyline segments must follow.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.
* @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
*/
export class PolylineGeometry {
  constructor(options: {
    positions: Cartesian3[];
    width?: number;
    colors?: Color[];
    colorsPerVertex?: boolean;
    arcType?: ArcType;
    granularity?: number;
    vertexFormat?: VertexFormat;
    ellipsoid?: Ellipsoid;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: PolylineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new PolylineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: PolylineGeometry): PolylineGeometry;
  /**
   * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.
   * @param polylineGeometry - A description of the polyline.
   * @returns The computed vertices and indices.
   */
  createGeometry(polylineGeometry: PolylineGeometry): Geometry | undefined;
}

/**
* A description of a polyline with a volume (a 2D shape extruded along a polyline).
* @example
* function computeCircle(radius) {
*   const positions = [];
*   for (let i = 0; i < 360; i++) {
*     const radians = SuperMap.Math.toRadians(i);
*     positions.push(new SuperMap.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
*   }
*   return positions;
* }
*
* const volume = new SuperMap.PolylineVolumeGeometry({
*   vertexFormat : SuperMap.VertexFormat.POSITION_ONLY,
*   polylinePositions : SuperMap.Cartesian3.fromDegreesArray([
*     -72.0, 40.0,
*     -70.0, 35.0
*   ]),
*   shapePositions : computeCircle(100000.0)
* });
* @param options - Object with the following properties:
* @param options.polylinePositions - An array of {@link Cartesian3} positions that define the center of the polyline volume.
* @param options.shapePositions - An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
* @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
* @param [options.cornerType = CornerType.ROUNDED] - Determines the style of the corners.
*/
export class PolylineVolumeGeometry {
  constructor(options: {
    polylinePositions: Cartesian3[];
    shapePositions: Cartesian2[];
    ellipsoid?: Ellipsoid;
    granularity?: number;
    vertexFormat?: VertexFormat;
    cornerType?: CornerType;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: PolylineVolumeGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: PolylineVolumeGeometry): PolylineVolumeGeometry;
  /**
   * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.
   * @param polylineVolumeGeometry - A description of the polyline volume.
   * @returns The computed vertices and indices.
   */
  createGeometry(polylineVolumeGeometry: PolylineVolumeGeometry): Geometry | undefined;
}

/**
* A description of a polyline with a volume (a 2D shape extruded along a polyline).
* @example
* function computeCircle(radius) {
*   const positions = [];
*   for (let i = 0; i < 360; i++) {
*     const radians = SuperMap.Math.toRadians(i);
*     positions.push(new SuperMap.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
*   }
*   return positions;
* }
*
* const volumeOutline = new SuperMap.PolylineVolumeOutlineGeometry({
*   polylinePositions : SuperMap.Cartesian3.fromDegreesArray([
*     -72.0, 40.0,
*     -70.0, 35.0
*   ]),
*   shapePositions : computeCircle(100000.0)
* });
* @param options - Object with the following properties:
* @param options.polylinePositions - An array of positions that define the center of the polyline volume.
* @param options.shapePositions - An array of positions that define the shape to be extruded along the polyline
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
* @param [options.cornerType = CornerType.ROUNDED] - Determines the style of the corners.
*/
export class PolylineVolumeOutlineGeometry {
  constructor(options: {
    polylinePositions: Cartesian3[];
    shapePositions: Cartesian2[];
    ellipsoid?: Ellipsoid;
    granularity?: number;
    cornerType?: CornerType;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: PolylineVolumeOutlineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new PolylineVolumeOutlineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: PolylineVolumeOutlineGeometry): PolylineVolumeOutlineGeometry;
  /**
   * Computes the geometric representation of the outline of a polyline with a volume, including its vertices, indices, and a bounding sphere.
   * @param polylineVolumeOutlineGeometry - A description of the polyline volume outline.
   * @returns The computed vertices and indices.
   */
  createGeometry(polylineVolumeOutlineGeometry: PolylineVolumeOutlineGeometry): Geometry | undefined;
}

/**
* The type of a geometric primitive, i.e., points, lines, and triangles.
*/
export enum PrimitiveType {
  /**
   * Points primitive where each vertex (or index) is a separate point.
   */
  POINTS = WebGLConstants.POINTS,
  /**
   * Lines primitive where each two vertices (or indices) is a line segment.  Line segments are not necessarily connected.
   */
  LINES = WebGLConstants.LINES,
  /**
   * Line loop primitive where each vertex (or index) after the first connects a line to
   * the previous vertex, and the last vertex implicitly connects to the first.
   */
  LINE_LOOP = WebGLConstants.LINE_LOOP,
  /**
   * Line strip primitive where each vertex (or index) after the first connects a line to the previous vertex.
   */
  LINE_STRIP = WebGLConstants.LINE_STRIP,
  /**
   * Triangles primitive where each three vertices (or indices) is a triangle.  Triangles do not necessarily share edges.
   */
  TRIANGLES = WebGLConstants.TRIANGLES,
  /**
   * Triangle strip primitive where each vertex (or index) after the first two connect to
   * the previous two vertices forming a triangle.  For example, this can be used to model a wall.
   */
  TRIANGLE_STRIP = WebGLConstants.TRIANGLE_STRIP,
  /**
   * Triangle fan primitive where each vertex (or index) after the first two connect to
   * the previous vertex and the first vertex forming a triangle.  For example, this can be used
   * to model a cone or circle.
   */
  TRIANGLE_FAN = WebGLConstants.TRIANGLE_FAN
}

/**
 * Defines functions for 2nd order polynomial functions of one variable with only real coefficients.
 */
export namespace QuadraticRealPolynomial {
  /**
   * Provides the discriminant of the quadratic equation from the supplied coefficients.
   * @param a - The coefficient of the 2nd order monomial.
   * @param b - The coefficient of the 1st order monomial.
   * @param c - The coefficient of the 0th order monomial.
   * @returns The value of the discriminant.
   */
  function computeDiscriminant(a: number, b: number, c: number): number;
  /**
   * Provides the real valued roots of the quadratic polynomial with the provided coefficients.
   * @param a - The coefficient of the 2nd order monomial.
   * @param b - The coefficient of the 1st order monomial.
   * @param c - The coefficient of the 0th order monomial.
   * @returns The real valued roots.
   */
  function computeRealRoots(a: number, b: number, c: number): number[];
}

/**
* Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized
* mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed
* as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner
* of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile
* and 32767 at the maximum height in the tile.
* @example
* const data = new SuperMap.QuantizedMeshTerrainData({
*     minimumHeight : -100,
*     maximumHeight : 2101,
*     quantizedVertices : new Uint16Array([// order is SW NW SE NE
*                                          // longitude
*                                          0, 0, 32767, 32767,
*                                          // latitude
*                                          0, 32767, 0, 32767,
*                                          // heights
*                                          16384, 0, 32767, 16384]),
*     indices : new Uint16Array([0, 3, 1,
*                                0, 2, 3]),
*     boundingSphere : new SuperMap.BoundingSphere(new SuperMap.Cartesian3(1.0, 2.0, 3.0), 10000),
*     orientedBoundingBox : new SuperMap.OrientedBoundingBox(new SuperMap.Cartesian3(1.0, 2.0, 3.0), SuperMap.Matrix3.fromRotationX(SuperMap.Math.PI, new SuperMap.Matrix3())),
*     horizonOcclusionPoint : new SuperMap.Cartesian3(3.0, 2.0, 1.0),
*     westIndices : [0, 1],
*     southIndices : [0, 1],
*     eastIndices : [2, 3],
*     northIndices : [1, 3],
*     westSkirtHeight : 1.0,
*     southSkirtHeight : 1.0,
*     eastSkirtHeight : 1.0,
*     northSkirtHeight : 1.0
* });
* @param options - Object with the following properties:
* @param options.quantizedVertices - The buffer containing the quantized mesh.
* @param options.indices - The indices specifying how the quantized vertices are linked
*                      together into triangles.  Each three indices specifies one triangle.
* @param options.minimumHeight - The minimum terrain height within the tile, in meters above the ellipsoid.
* @param options.maximumHeight - The maximum terrain height within the tile, in meters above the ellipsoid.
* @param options.boundingSphere - A sphere bounding all of the vertices in the mesh.
* @param [options.orientedBoundingBox] - An OrientedBoundingBox bounding all of the vertices in the mesh.
* @param options.horizonOcclusionPoint - The horizon occlusion point of the mesh.  If this point
*                      is below the horizon, the entire tile is assumed to be below the horizon as well.
*                      The point is expressed in ellipsoid-scaled coordinates.
* @param options.westIndices - The indices of the vertices on the western edge of the tile.
* @param options.southIndices - The indices of the vertices on the southern edge of the tile.
* @param options.eastIndices - The indices of the vertices on the eastern edge of the tile.
* @param options.northIndices - The indices of the vertices on the northern edge of the tile.
* @param options.westSkirtHeight - The height of the skirt to add on the western edge of the tile.
* @param options.southSkirtHeight - The height of the skirt to add on the southern edge of the tile.
* @param options.eastSkirtHeight - The height of the skirt to add on the eastern edge of the tile.
* @param options.northSkirtHeight - The height of the skirt to add on the northern edge of the tile.
* @param [options.childTileMask = 15] - A bit mask indicating which of this tile's four children exist.
*                 If a child's bit is set, geometry will be requested for that tile as well when it
*                 is needed.  If the bit is cleared, the child tile is not requested and geometry is
*                 instead upsampled from the parent.  The bit values are as follows:
*                 <table>
*                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
*                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>
*                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>
*                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>
*                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>
*                 </table>
* @param [options.createdByUpsampling = false] - True if this instance was created by upsampling another instance;
*                  otherwise, false.
* @param [options.encodedNormals] - The buffer containing per vertex normals, encoded using 'oct' encoding
* @param [options.waterMask] - The buffer containing the watermask.
* @param [options.credits] - Array of credits for this tile.
*/
export class QuantizedMeshTerrainData {
  constructor(options: {
    quantizedVertices: Uint16Array;
    indices: Uint16Array | Uint32Array;
    minimumHeight: number;
    maximumHeight: number;
    boundingSphere: BoundingSphere;
    orientedBoundingBox?: OrientedBoundingBox;
    horizonOcclusionPoint: Cartesian3;
    westIndices: number[];
    southIndices: number[];
    eastIndices: number[];
    northIndices: number[];
    westSkirtHeight: number;
    southSkirtHeight: number;
    eastSkirtHeight: number;
    northSkirtHeight: number;
    childTileMask?: number;
    createdByUpsampling?: boolean;
    encodedNormals?: Uint8Array;
    waterMask?: Uint8Array;
    credits?: Credit[];
  });
  /**
   * An array of credits for this tile.
   */
  credits: Credit[];
  /**
   * The water mask included in this terrain data, if any.  A water mask is a rectangular
   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
   */
  waterMask: Uint8Array | HTMLImageElement | HTMLCanvasElement;
  /**
   * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the
   * vertices in this instance, interpolated if necessary.
   * @param tilingScheme - The tiling scheme of this terrain data.
   * @param thisX - The X coordinate of this tile in the tiling scheme.
   * @param thisY - The Y coordinate of this tile in the tiling scheme.
   * @param thisLevel - The level of this tile in the tiling scheme.
   * @param descendantX - The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
   * @param descendantY - The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
   * @param descendantLevel - The level within the tiling scheme of the descendant tile for which we are upsampling.
   * @returns A promise for upsampled heightmap terrain data for the descendant tile,
   *          or undefined if too many asynchronous upsample operations are in progress and the request has been
   *          deferred.
   */
  upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): Promise<QuantizedMeshTerrainData> | undefined;
  /**
   * Computes the terrain height at a specified longitude and latitude.
   * @param rectangle - The rectangle covered by this terrain data.
   * @param longitude - The longitude in radians.
   * @param latitude - The latitude in radians.
   * @returns The terrain height at the specified position.  The position is clamped to
   *          the rectangle, so expect incorrect results for positions far outside the rectangle.
   */
  interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;
  /**
   * Determines if a given child tile is available, based on the
   * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed
   * to be one of the four children of this tile.  If non-child tile coordinates are
   * given, the availability of the southeast child tile is returned.
   * @param thisX - The tile X coordinate of this (the parent) tile.
   * @param thisY - The tile Y coordinate of this (the parent) tile.
   * @param childX - The tile X coordinate of the child tile to check for availability.
   * @param childY - The tile Y coordinate of the child tile to check for availability.
   * @returns True if the child tile is available; otherwise, false.
   */
  isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): boolean;
  /**
   * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
   * terrain data.  If this value is false, the data was obtained from some other source, such
   * as by downloading it from a remote server.  This method should return true for instances
   * returned from a call to {@link HeightmapTerrainData#upsample}.
   * @returns True if this instance was created by upsampling; otherwise, false.
   */
  wasCreatedByUpsampling(): boolean;
}

/**
* Defines functions for 4th order polynomial functions of one variable with only real coefficients.
*/
export namespace QuarticRealPolynomial {
  /**
   * Provides the discriminant of the quartic equation from the supplied coefficients.
   * @param a - The coefficient of the 4th order monomial.
   * @param b - The coefficient of the 3rd order monomial.
   * @param c - The coefficient of the 2nd order monomial.
   * @param d - The coefficient of the 1st order monomial.
   * @param e - The coefficient of the 0th order monomial.
   * @returns The value of the discriminant.
   */
  function computeDiscriminant(a: number, b: number, c: number, d: number, e: number): number;
  /**
   * Provides the real valued roots of the quartic polynomial with the provided coefficients.
   * @param a - The coefficient of the 4th order monomial.
   * @param b - The coefficient of the 3rd order monomial.
   * @param c - The coefficient of the 2nd order monomial.
   * @param d - The coefficient of the 1st order monomial.
   * @param e - The coefficient of the 0th order monomial.
   * @returns The real valued roots.
   */
  function computeRealRoots(a: number, b: number, c: number, d: number, e: number): number[];
}

/**
* A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.
* @param [x = 0.0] - The X component.
* @param [y = 0.0] - The Y component.
* @param [z = 0.0] - The Z component.
* @param [w = 0.0] - The W component.
*/
export class Quaternion {
  constructor(x?: number, y?: number, z?: number, w?: number);
  /**
   * The X component.
   */
  x: number;
  /**
   * The Y component.
   */
  y: number;
  /**
   * The Z component.
   */
  z: number;
  /**
   * The W component.
   */
  w: number;
  /**
   * Computes a quaternion representing a rotation around an axis.
   * @param axis - The axis of rotation.
   * @param angle - The angle in radians to rotate around the axis.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Quaternion instance if one was not provided.
   */
  fromAxisAngle(axis: Cartesian3, angle: number, result?: Quaternion): Quaternion;
  /**
   * Computes a Quaternion from the provided Matrix3 instance.
   * @param matrix - The rotation matrix.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Quaternion instance if one was not provided.
   */
  fromRotationMatrix(matrix: Matrix3, result?: Quaternion): Quaternion;
  /**
   * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the
   * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
   * the positive x axis.
   * @param headingPitchRoll - The rotation expressed as a heading, pitch and roll.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Quaternion instance if none was provided.
   */
  fromHeadingPitchRoll(headingPitchRoll: HeadingPitchRoll, result?: Quaternion): Quaternion;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: Quaternion, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Quaternion instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: Quaternion): Quaternion;
  /**
   * The number of elements used to store the object into an array in its interpolatable form.
   */
  packedInterpolationLength: number;
  /**
   * Converts a packed array into a form suitable for interpolation.
   * @param packedArray - The packed array.
   * @param [startingIndex = 0] - The index of the first element to be converted.
   * @param [lastIndex = packedArray.length] - The index of the last element to be converted.
   * @param [result] - The object into which to store the result.
   */
  convertPackedArrayForInterpolation(packedArray: number[], startingIndex?: number, lastIndex?: number, result?: number[]): void;
  /**
   * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.
   * @param array - The array previously packed for interpolation.
   * @param sourceArray - The original packed array.
   * @param [firstIndex = 0] - The firstIndex used to convert the array.
   * @param [lastIndex = packedArray.length] - The lastIndex used to convert the array.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Quaternion instance if one was not provided.
   */
  unpackInterpolationResult(array: number[], sourceArray: number[], firstIndex?: number, lastIndex?: number, result?: Quaternion): Quaternion;
  /**
   * Duplicates a Quaternion instance.
   * @param quaternion - The quaternion to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)
   */
  clone(quaternion: Quaternion, result?: Quaternion): Quaternion;
  /**
   * Computes the conjugate of the provided quaternion.
   * @param quaternion - The quaternion to conjugate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  conjugate(quaternion: Quaternion, result: Quaternion): Quaternion;
  /**
   * Computes magnitude squared for the provided quaternion.
   * @param quaternion - The quaternion to conjugate.
   * @returns The magnitude squared.
   */
  magnitudeSquared(quaternion: Quaternion): number;
  /**
   * Computes magnitude for the provided quaternion.
   * @param quaternion - The quaternion to conjugate.
   * @returns The magnitude.
   */
  magnitude(quaternion: Quaternion): number;
  /**
   * Computes the normalized form of the provided quaternion.
   * @param quaternion - The quaternion to normalize.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  normalize(quaternion: Quaternion, result: Quaternion): Quaternion;
  /**
   * Computes the inverse of the provided quaternion.
   * @param quaternion - The quaternion to normalize.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  inverse(quaternion: Quaternion, result: Quaternion): Quaternion;
  /**
   * Computes the componentwise sum of two quaternions.
   * @param left - The first quaternion.
   * @param right - The second quaternion.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  add(left: Quaternion, right: Quaternion, result: Quaternion): Quaternion;
  /**
   * Computes the componentwise difference of two quaternions.
   * @param left - The first quaternion.
   * @param right - The second quaternion.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  subtract(left: Quaternion, right: Quaternion, result: Quaternion): Quaternion;
  /**
   * Negates the provided quaternion.
   * @param quaternion - The quaternion to be negated.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  negate(quaternion: Quaternion, result: Quaternion): Quaternion;
  /**
   * Computes the dot (scalar) product of two quaternions.
   * @param left - The first quaternion.
   * @param right - The second quaternion.
   * @returns The dot product.
   */
  dot(left: Quaternion, right: Quaternion): number;
  /**
   * Computes the product of two quaternions.
   * @param left - The first quaternion.
   * @param right - The second quaternion.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiply(left: Quaternion, right: Quaternion, result: Quaternion): Quaternion;
  /**
   * Multiplies the provided quaternion componentwise by the provided scalar.
   * @param quaternion - The quaternion to be scaled.
   * @param scalar - The scalar to multiply with.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  multiplyByScalar(quaternion: Quaternion, scalar: number, result: Quaternion): Quaternion;
  /**
   * Divides the provided quaternion componentwise by the provided scalar.
   * @param quaternion - The quaternion to be divided.
   * @param scalar - The scalar to divide by.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  divideByScalar(quaternion: Quaternion, scalar: number, result: Quaternion): Quaternion;
  /**
   * Computes the axis of rotation of the provided quaternion.
   * @param quaternion - The quaternion to use.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  computeAxis(quaternion: Quaternion, result: Cartesian3): Cartesian3;
  /**
   * Computes the angle of rotation of the provided quaternion.
   * @param quaternion - The quaternion to use.
   * @returns The angle of rotation.
   */
  computeAngle(quaternion: Quaternion): number;
  /**
   * Computes the linear interpolation or extrapolation at t using the provided quaternions.
   * @param start - The value corresponding to t at 0.0.
   * @param end - The value corresponding to t at 1.0.
   * @param t - The point along t at which to interpolate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  lerp(start: Quaternion, end: Quaternion, t: number, result: Quaternion): Quaternion;
  /**
   * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
   * @param start - The value corresponding to t at 0.0.
   * @param end - The value corresponding to t at 1.0.
   * @param t - The point along t at which to interpolate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  slerp(start: Quaternion, end: Quaternion, t: number, result: Quaternion): Quaternion;
  /**
   * The logarithmic quaternion function.
   * @param quaternion - The unit quaternion.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  log(quaternion: Quaternion, result: Cartesian3): Cartesian3;
  /**
   * The exponential quaternion function.
   * @param cartesian - The cartesian.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  exp(cartesian: Cartesian3, result: Quaternion): Quaternion;
  /**
   * Computes an inner quadrangle point.
   * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>
   * @param q0 - The first quaternion.
   * @param q1 - The second quaternion.
   * @param q2 - The third quaternion.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  computeInnerQuadrangle(q0: Quaternion, q1: Quaternion, q2: Quaternion, result: Quaternion): Quaternion;
  /**
   * Computes the spherical quadrangle interpolation between quaternions.
   * @example
   * // 1. compute the squad interpolation between two quaternions on a curve
   * const s0 = SuperMap.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new SuperMap.Quaternion());
   * const s1 = SuperMap.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new SuperMap.Quaternion());
   * const q = SuperMap.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new SuperMap.Quaternion());
   *
   * // 2. compute the squad interpolation as above but where the first quaternion is a end point.
   * const s1 = SuperMap.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new SuperMap.Quaternion());
   * const q = SuperMap.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new SuperMap.Quaternion());
   * @param q0 - The first quaternion.
   * @param q1 - The second quaternion.
   * @param s0 - The first inner quadrangle.
   * @param s1 - The second inner quadrangle.
   * @param t - The time in [0,1] used to interpolate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  squad(q0: Quaternion, q1: Quaternion, s0: Quaternion, s1: Quaternion, t: number, result: Quaternion): Quaternion;
  /**
   * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
   * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.
   * @param start - The value corresponding to t at 0.0.
   * @param end - The value corresponding to t at 1.0.
   * @param t - The point along t at which to interpolate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter.
   */
  fastSlerp(start: Quaternion, end: Quaternion, t: number, result: Quaternion): Quaternion;
  /**
   * Computes the spherical quadrangle interpolation between quaternions.
   * An implementation that is faster than {@link Quaternion#squad}, but less accurate.
   * @param q0 - The first quaternion.
   * @param q1 - The second quaternion.
   * @param s0 - The first inner quadrangle.
   * @param s1 - The second inner quadrangle.
   * @param t - The time in [0,1] used to interpolate.
   * @param result - The object onto which to store the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  fastSquad(q0: Quaternion, q1: Quaternion, s0: Quaternion, s1: Quaternion, t: number, result: Quaternion): Quaternion;
  /**
   * Compares the provided quaternions componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [left] - The first quaternion.
   * @param [right] - The second quaternion.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(left?: Quaternion, right?: Quaternion): boolean;
  /**
   * Compares the provided quaternions componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   * @param [left] - The first quaternion.
   * @param [right] - The second quaternion.
   * @param [epsilon = 0] - The epsilon to use for equality testing.
   * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(left?: Quaternion, right?: Quaternion, epsilon?: number): boolean;
  /**
   * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).
   */
  readonly ZERO: Quaternion;
  /**
   * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).
   */
  readonly IDENTITY: Quaternion;
  /**
   * Duplicates this Quaternion instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Quaternion instance if one was not provided.
   */
  clone(result?: Quaternion): Quaternion;
  /**
   * Compares this and the provided quaternion componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The right hand side quaternion.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(right?: Quaternion): boolean;
  /**
   * Compares this and the provided quaternion componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   * @param [right] - The right hand side quaternion.
   * @param [epsilon = 0] - The epsilon to use for equality testing.
   * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(right?: Quaternion, epsilon?: number): boolean;
  /**
   * Returns a string representing this quaternion in the format (x, y, z, w).
   * @returns A string representing this Quaternion.
   */
  toString(): string;
}

/**
* A spline that uses spherical linear (slerp) interpolation to create a quaternion curve.
* The generated curve is in the class C<sup>1</sup>.
* @param options - Object with the following properties:
* @param options.times - An array of strictly increasing, unit-less, floating-point times at each point.
*                The values are in no way connected to the clock time. They are the parameterization for the curve.
* @param options.points - The array of {@link Quaternion} control points.
*/
export class QuaternionSpline {
  constructor(options: {
    times: number[];
    points: Quaternion[];
  });
  /**
   * An array of times for the control points.
   */
  readonly times: number[];
  /**
   * An array of {@link Quaternion} control points.
   */
  readonly points: Quaternion[];
  /**
   * Finds an index <code>i</code> in <code>times</code> such that the parameter
   * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
   * @param time - The time.
   * @returns The index for the element at the start of the interval.
   */
  findTimeInterval(time: number): number;
  /**
   * Wraps the given time to the period covered by the spline.
   * @param time - The time.
   * @returns The time, wrapped around to the updated animation.
   */
  wrapTime(time: number): number;
  /**
   * Clamps the given time to the period covered by the spline.
   * @param time - The time.
   * @returns The time, clamped to the animation period.
   */
  clampTime(time: number): number;
  /**
   * Evaluates the curve at a given time.
   * @param time - The time at which to evaluate the curve.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new instance of the point on the curve at the given time.
   */
  evaluate(time: number, result?: Quaternion): Quaternion;
}

/**
* A queue that can enqueue items at the end, and dequeue items from the front.
*/
export class Queue {
  constructor();
  /**
   * The length of the queue.
   */
  readonly length: number;
  /**
   * Enqueues the specified item.
   * @param item - The item to enqueue.
   */
  enqueue(item: any): void;
  /**
   * Dequeues an item.  Returns undefined if the queue is empty.
   * @returns The the dequeued item.
   */
  dequeue(): any;
  /**
   * Returns the item at the front of the queue.  Returns undefined if the queue is empty.
   * @returns The item at the front of the queue.
   */
  peek(): any;
  /**
   * Check whether this queue contains the specified item.
   * @param item - The item to search for.
   */
  contains(item: any): void;
  /**
   * Remove all items from the queue.
   */
  clear(): void;
  /**
   * Sort the items in the queue in-place.
   * @param compareFunction - A function that defines the sort order.
   */
  sort(compareFunction: Queue.Comparator): void;
}

export namespace Queue {
  /**
   * A function used to compare two items while sorting a queue.
   * @example
   * function compareNumbers(a, b) {
   *     return a - b;
   * }
   * @param a - An item in the array.
   * @param b - An item in the array.
   */
  type Comparator = (a: any, b: any) => number;
}

/**
* Represents a ray that extends infinitely from the provided origin in the provided direction.
* @param [origin = Cartesian3.ZERO] - The origin of the ray.
* @param [direction = Cartesian3.ZERO] - The direction of the ray.
*/
export class Ray {
  constructor(origin?: Cartesian3, direction?: Cartesian3);
  /**
   * The origin of the ray.
   */
  origin: Cartesian3;
  /**
   * The direction of the ray.
   */
  direction: Cartesian3;
  /**
   * Duplicates a Ray instance.
   * @param ray - The ray to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)
   */
  clone(ray: Ray, result?: Ray): Ray;
  /**
   * Computes the point along the ray given by r(t) = o + t*d,
   * where o is the origin of the ray and d is the direction.
   * @example
   * //Get the first intersection point of a ray and an ellipsoid.
   * const intersection = SuperMap.IntersectionTests.rayEllipsoid(ray, ellipsoid);
   * const point = SuperMap.Ray.getPoint(ray, intersection.start);
   * @param ray - The ray.
   * @param t - A scalar value.
   * @param [result] - The object in which the result will be stored.
   * @returns The modified result parameter, or a new instance if none was provided.
   */
  getPoint(ray: Ray, t: number, result?: Cartesian3): Cartesian3;
}

/**
* A two dimensional region specified as longitude and latitude coordinates.
* @param [west = 0.0] - The westernmost longitude, in radians, in the range [-Pi, Pi].
* @param [south = 0.0] - The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].
* @param [east = 0.0] - The easternmost longitude, in radians, in the range [-Pi, Pi].
* @param [north = 0.0] - The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].
*/
export class Rectangle {
  constructor(west?: number, south?: number, east?: number, north?: number);
  /**
   * The westernmost longitude in radians in the range [-Pi, Pi].
   */
  west: number;
  /**
   * The southernmost latitude in radians in the range [-Pi/2, Pi/2].
   */
  south: number;
  /**
   * The easternmost longitude in radians in the range [-Pi, Pi].
   */
  east: number;
  /**
   * The northernmost latitude in radians in the range [-Pi/2, Pi/2].
   */
  north: number;
  /**
   * Gets the width of the rectangle in radians.
   */
  readonly width: number;
  /**
   * Gets the height of the rectangle in radians.
   */
  readonly height: number;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: Rectangle, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Rectangle instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: Rectangle): Rectangle;
  /**
   * Computes the width of a rectangle in radians.
   * @param rectangle - The rectangle to compute the width of.
   * @returns The width.
   */
  computeWidth(rectangle: Rectangle): number;
  /**
   * Computes the height of a rectangle in radians.
   * @param rectangle - The rectangle to compute the height of.
   * @returns The height.
   */
  computeHeight(rectangle: Rectangle): number;
  /**
   * Creates a rectangle given the boundary longitude and latitude in degrees.
   * @example
   * const rectangle = SuperMap.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);
   * @param [west = 0.0] - The westernmost longitude in degrees in the range [-180.0, 180.0].
   * @param [south = 0.0] - The southernmost latitude in degrees in the range [-90.0, 90.0].
   * @param [east = 0.0] - The easternmost longitude in degrees in the range [-180.0, 180.0].
   * @param [north = 0.0] - The northernmost latitude in degrees in the range [-90.0, 90.0].
   * @param [result] - The object onto which to store the result, or undefined if a new instance should be created.
   * @returns The modified result parameter or a new Rectangle instance if none was provided.
   */
  fromDegrees(west?: number, south?: number, east?: number, north?: number, result?: Rectangle): Rectangle;
  /**
   * Creates a rectangle given the boundary longitude and latitude in radians.
   * @example
   * const rectangle = SuperMap.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);
   * @param [west = 0.0] - The westernmost longitude in radians in the range [-Math.PI, Math.PI].
   * @param [south = 0.0] - The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].
   * @param [east = 0.0] - The easternmost longitude in radians in the range [-Math.PI, Math.PI].
   * @param [north = 0.0] - The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].
   * @param [result] - The object onto which to store the result, or undefined if a new instance should be created.
   * @returns The modified result parameter or a new Rectangle instance if none was provided.
   */
  fromRadians(west?: number, south?: number, east?: number, north?: number, result?: Rectangle): Rectangle;
  /**
   * Creates the smallest possible Rectangle that encloses all positions in the provided array.
   * @param cartographics - The list of Cartographic instances.
   * @param [result] - The object onto which to store the result, or undefined if a new instance should be created.
   * @returns The modified result parameter or a new Rectangle instance if none was provided.
   */
  fromCartographicArray(cartographics: Cartographic[], result?: Rectangle): Rectangle;
  /**
   * Creates the smallest possible Rectangle that encloses all positions in the provided array.
   * @param cartesians - The list of Cartesian instances.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid the cartesians are on.
   * @param [result] - The object onto which to store the result, or undefined if a new instance should be created.
   * @returns The modified result parameter or a new Rectangle instance if none was provided.
   */
  fromCartesianArray(cartesians: Cartesian3[], ellipsoid?: Ellipsoid, result?: Rectangle): Rectangle;
  /**
   * Duplicates a Rectangle.
   * @param rectangle - The rectangle to clone.
   * @param [result] - The object onto which to store the result, or undefined if a new instance should be created.
   * @returns The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)
   */
  clone(rectangle: Rectangle, result?: Rectangle): Rectangle;
  /**
   * Compares the provided Rectangles componentwise and returns
   * <code>true</code> if they pass an absolute or relative tolerance test,
   * <code>false</code> otherwise.
   * @param [left] - The first Rectangle.
   * @param [right] - The second Rectangle.
   * @param [absoluteEpsilon = 0] - The absolute epsilon tolerance to use for equality testing.
   * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(left?: Rectangle, right?: Rectangle, absoluteEpsilon?: number): boolean;
  /**
   * Duplicates this Rectangle.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Rectangle instance if none was provided.
   */
  clone(result?: Rectangle): Rectangle;
  /**
   * Compares the provided Rectangle with this Rectangle componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The Rectangle to compare.
   * @returns <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.
   */
  equals(other?: Rectangle): boolean;
  /**
   * Compares the provided rectangles and returns <code>true</code> if they are equal,
   * <code>false</code> otherwise.
   * @param [left] - The first Rectangle.
   * @param [right] - The second Rectangle.
   * @returns <code>true</code> if left and right are equal; otherwise <code>false</code>.
   */
  equals(left?: Rectangle, right?: Rectangle): boolean;
  /**
   * Compares the provided Rectangle with this Rectangle componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   * @param [other] - The Rectangle to compare.
   * @param [epsilon = 0] - The epsilon to use for equality testing.
   * @returns <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(other?: Rectangle, epsilon?: number): boolean;
  /**
   * Checks a Rectangle's properties and throws if they are not in valid ranges.
   * @param rectangle - The rectangle to validate
   */
  validate(rectangle: Rectangle): void;
  /**
   * Computes the southwest corner of a rectangle.
   * @param rectangle - The rectangle for which to find the corner
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartographic instance if none was provided.
   */
  southwest(rectangle: Rectangle, result?: Cartographic): Cartographic;
  /**
   * Computes the northwest corner of a rectangle.
   * @param rectangle - The rectangle for which to find the corner
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartographic instance if none was provided.
   */
  northwest(rectangle: Rectangle, result?: Cartographic): Cartographic;
  /**
   * Computes the northeast corner of a rectangle.
   * @param rectangle - The rectangle for which to find the corner
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartographic instance if none was provided.
   */
  northeast(rectangle: Rectangle, result?: Cartographic): Cartographic;
  /**
   * Computes the southeast corner of a rectangle.
   * @param rectangle - The rectangle for which to find the corner
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartographic instance if none was provided.
   */
  southeast(rectangle: Rectangle, result?: Cartographic): Cartographic;
  /**
   * Computes the center of a rectangle.
   * @param rectangle - The rectangle for which to find the center
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartographic instance if none was provided.
   */
  center(rectangle: Rectangle, result?: Cartographic): Cartographic;
  /**
   * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are
   * latitude and longitude in radians and produces a correct intersection, taking into account the fact that
   * the same angle can be represented with multiple values as well as the wrapping of longitude at the
   * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected
   * coordinates, see {@link Rectangle.simpleIntersection}.
   * @param rectangle - On rectangle to find an intersection
   * @param otherRectangle - Another rectangle to find an intersection
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.
   */
  intersection(rectangle: Rectangle, otherRectangle: Rectangle, result?: Rectangle): Rectangle | undefined;
  /**
   * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function
   * does not attempt to put the angular coordinates into a consistent range or to account for crossing the
   * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude
   * and longitude (i.e. projected coordinates).
   * @param rectangle - On rectangle to find an intersection
   * @param otherRectangle - Another rectangle to find an intersection
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.
   */
  simpleIntersection(rectangle: Rectangle, otherRectangle: Rectangle, result?: Rectangle): Rectangle | undefined;
  /**
   * Computes a rectangle that is the union of two rectangles.
   * @param rectangle - A rectangle to enclose in rectangle.
   * @param otherRectangle - A rectangle to enclose in a rectangle.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Rectangle instance if none was provided.
   */
  union(rectangle: Rectangle, otherRectangle: Rectangle, result?: Rectangle): Rectangle;
  /**
   * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.
   * @param rectangle - A rectangle to expand.
   * @param cartographic - A cartographic to enclose in a rectangle.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Rectangle instance if one was not provided.
   */
  expand(rectangle: Rectangle, cartographic: Cartographic, result?: Rectangle): Rectangle;
  /**
   * Returns true if the cartographic is on or inside the rectangle, false otherwise.
   * @param rectangle - The rectangle
   * @param cartographic - The cartographic to test.
   * @returns true if the provided cartographic is inside the rectangle, false otherwise.
   */
  contains(rectangle: Rectangle, cartographic: Cartographic): boolean;
  /**
   * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to
   * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account
   * for rectangles that cover the poles or cross the equator.
   * @param rectangle - The rectangle to subsample.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid to use.
   * @param [surfaceHeight = 0.0] - The height of the rectangle above the ellipsoid.
   * @param [result] - The array of Cartesians onto which to store the result.
   * @returns The modified result parameter or a new Array of Cartesians instances if none was provided.
   */
  subsample(rectangle: Rectangle, ellipsoid?: Ellipsoid, surfaceHeight?: number, result?: Cartesian3[]): Cartesian3[];
  /**
   * Computes a subsection of a rectangle from normalized coordinates in the range [0.0, 1.0].
   * @param rectangle - The rectangle to subsection.
   * @param westLerp - The west interpolation factor in the range [0.0, 1.0]. Must be less than or equal to eastLerp.
   * @param southLerp - The south interpolation factor in the range [0.0, 1.0]. Must be less than or equal to northLerp.
   * @param eastLerp - The east interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to westLerp.
   * @param northLerp - The north interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to southLerp.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Rectangle instance if none was provided.
   */
  subsection(rectangle: Rectangle, westLerp: number, southLerp: number, eastLerp: number, northLerp: number, result?: Rectangle): Rectangle;
  /**
   * The largest possible rectangle.
   */
  readonly MAX_VALUE: Rectangle;
}

/**
* A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
* @example
* // 1. create a rectangle
* const rectangle = new SuperMap.RectangleGeometry({
*   ellipsoid : SuperMap.Ellipsoid.WGS84,
*   rectangle : SuperMap.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),
*   height : 10000.0
* });
* const geometry = SuperMap.RectangleGeometry.createGeometry(rectangle);
*
* // 2. create an extruded rectangle without a top
* const rectangle = new SuperMap.RectangleGeometry({
*   ellipsoid : SuperMap.Ellipsoid.WGS84,
*   rectangle : SuperMap.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),
*   height : 10000.0,
*   extrudedHeight: 300000
* });
* const geometry = SuperMap.RectangleGeometry.createGeometry(rectangle);
* @param options - Object with the following properties:
* @param options.rectangle - A cartographic rectangle with north, south, east and west properties in radians.
* @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the rectangle lies.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
* @param [options.height = 0.0] - The distance in meters between the rectangle and the ellipsoid surface.
* @param [options.rotation = 0.0] - The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.
* @param [options.stRotation = 0.0] - The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
* @param [options.extrudedHeight] - The distance in meters between the rectangle's extruded face and the ellipsoid surface.
*/
export class RectangleGeometry {
  constructor(options: {
    rectangle: Rectangle;
    vertexFormat?: VertexFormat;
    ellipsoid?: Ellipsoid;
    granularity?: number;
    height?: number;
    rotation?: number;
    stRotation?: number;
    extrudedHeight?: number;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: RectangleGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new RectangleGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: RectangleGeometry): RectangleGeometry;
  /**
   * Computes the bounding rectangle based on the provided options
   * @param options - Object with the following properties:
   * @param options.rectangle - A cartographic rectangle with north, south, east and west properties in radians.
   * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the rectangle lies.
   * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
   * @param [options.rotation = 0.0] - The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.
   * @param [result] - An object in which to store the result.
   * @returns The result rectangle
   */
  computeRectangle(options: {
    rectangle: Rectangle;
    ellipsoid?: Ellipsoid;
    granularity?: number;
    rotation?: number;
  }, result?: Rectangle): Rectangle;
  /**
   * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.
   * @param rectangleGeometry - A description of the rectangle.
   * @returns The computed vertices and indices.
   */
  createGeometry(rectangleGeometry: RectangleGeometry): Geometry | undefined;
}

/**
* A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.
* @example
* const rectangle = new SuperMap.RectangleOutlineGeometry({
*   ellipsoid : SuperMap.Ellipsoid.WGS84,
*   rectangle : SuperMap.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),
*   height : 10000.0
* });
* const geometry = SuperMap.RectangleOutlineGeometry.createGeometry(rectangle);
* @param options - Object with the following properties:
* @param options.rectangle - A cartographic rectangle with north, south, east and west properties in radians.
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the rectangle lies.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
* @param [options.height = 0.0] - The distance in meters between the rectangle and the ellipsoid surface.
* @param [options.rotation = 0.0] - The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.
* @param [options.extrudedHeight] - The distance in meters between the rectangle's extruded face and the ellipsoid surface.
*/
export class RectangleOutlineGeometry {
  constructor(options: {
    rectangle: Rectangle;
    ellipsoid?: Ellipsoid;
    granularity?: number;
    height?: number;
    rotation?: number;
    extrudedHeight?: number;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: RectangleOutlineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new Quaternion instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: RectangleOutlineGeometry): RectangleOutlineGeometry;
  /**
   * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.
   * @param rectangleGeometry - A description of the rectangle outline.
   * @returns The computed vertices and indices.
   */
  createGeometry(rectangleGeometry: RectangleOutlineGeometry): Geometry | undefined;
}

/**
* Constants for identifying well-known reference frames.
*/
export enum ReferenceFrame {
  /**
   * The fixed frame.
   */
  FIXED = 0,
  /**
   * The inertial frame.
   */
  INERTIAL = 1
}

/**
* Stores information for making a request. In general this does not need to be constructed directly.
* @param [options] - An object with the following properties:
* @param [options.url] - The url to request.
* @param [options.requestFunction] - The function that makes the actual data request.
* @param [options.cancelFunction] - The function that is called when the request is cancelled.
* @param [options.priorityFunction] - The function that is called to update the request's priority, which occurs once per frame.
* @param [options.priority = 0.0] - The initial priority of the request.
* @param [options.throttle = false] - Whether to throttle and prioritize the request. If false, the request will be sent immediately. If true, the request will be throttled and sent based on priority.
* @param [options.throttleByServer = false] - Whether to throttle the request by server.
* @param [options.type = RequestType.OTHER] - The type of request.
*/
export class Request {
  constructor(options?: {
    url?: string;
    requestFunction?: Request.RequestCallback;
    cancelFunction?: Request.CancelCallback;
    priorityFunction?: Request.PriorityCallback;
    priority?: number;
    throttle?: boolean;
    throttleByServer?: boolean;
    type?: RequestType;
  });
  /**
   * The URL to request.
   */
  url: string;
  /**
   * The function that makes the actual data request.
   */
  requestFunction: Request.RequestCallback;
  /**
   * The function that is called when the request is cancelled.
   */
  cancelFunction: Request.CancelCallback;
  /**
   * The function that is called to update the request's priority, which occurs once per frame.
   */
  priorityFunction: Request.PriorityCallback;
  /**
   * Priority is a unit-less value where lower values represent higher priority.
   * For world-based objects, this is usually the distance from the camera.
   * A request that does not have a priority function defaults to a priority of 0.
   *
   * If priorityFunction is defined, this value is updated every frame with the result of that call.
   */
  priority: number;
  /**
   * Whether to throttle and prioritize the request. If false, the request will be sent immediately. If true, the
   * request will be throttled and sent based on priority.
   */
  readonly throttle: boolean;
  /**
   * Whether to throttle the request by server. Browsers typically support about 6-8 parallel connections
   * for HTTP/1 servers, and an unlimited amount of connections for HTTP/2 servers. Setting this value
   * to <code>true</code> is preferable for requests going through HTTP/1 servers.
   */
  readonly throttleByServer: boolean;
  /**
   * Type of request.
   */
  readonly type: RequestType;
  /**
   * The current state of the request.
   */
  readonly state: RequestState;
  /**
   * Duplicates a Request instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Resource instance if one was not provided.
   */
  clone(result?: Request): Request;
}

export namespace Request {
  /**
   * The function that makes the actual data request.
   */
  type RequestCallback = () => Promise<void>;
  /**
   * The function that is called when the request is cancelled.
   */
  type CancelCallback = () => void;
  /**
   * The function that is called to update the request's priority, which occurs once per frame.
   */
  type PriorityCallback = () => number;
}

/**
* An event that is raised when a request encounters an error.
* @param [statusCode] - The HTTP error status code, such as 404.
* @param [response] - The response included along with the error.
* @param [responseHeaders] - The response headers, represented either as an object literal or as a
*                        string in the format returned by XMLHttpRequest's getAllResponseHeaders() function.
*/
export class RequestErrorEvent {
  constructor(statusCode?: number, response?: any, responseHeaders?: string | any);
  /**
   * The HTTP error status code, such as 404.  If the error does not have a particular
   * HTTP code, this property will be undefined.
   */
  statusCode: number;
  /**
   * The response included along with the error.  If the error does not include a response,
   * this property will be undefined.
   */
  response: any;
  /**
   * The headers included in the response, represented as an object literal of key/value pairs.
   * If the error does not include any headers, this property will be undefined.
   */
  responseHeaders: any;
  /**
   * Creates a string representing this RequestErrorEvent.
   * @returns A string representing the provided RequestErrorEvent.
   */
  toString(): string;
}

/**
* The request scheduler is used to track and constrain the number of active requests in order to prioritize incoming requests. The ability
* to retain control over the number of requests in CesiumJS is important because due to events such as changes in the camera position,
* a lot of new requests may be generated and a lot of in-flight requests may become redundant. The request scheduler manually constrains the
* number of requests so that newer requests wait in a shorter queue and don't have to compete for bandwidth with requests that have expired.
*/
export namespace RequestScheduler {
  /**
   * The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.
   */
  var maximumRequests: number;
  /**
   * The maximum number of simultaneous active requests per server. Un-throttled requests or servers specifically
   * listed in {@link requestsByServer} do not observe this limit.
   */
  var maximumRequestsPerServer: number;
  /**
   * A per server key list of overrides to use for throttling instead of <code>maximumRequestsPerServer</code>
   */
  var requestsByServer: any;
  /**
   * Specifies if the request scheduler should throttle incoming requests, or let the browser queue requests under its control.
   */
  var throttleRequests: boolean;
}

/**
* State of the request.
*/
export enum RequestState {
  /**
   * Initial unissued state.
   */
  UNISSUED = 0,
  /**
   * Issued but not yet active. Will become active when open slots are available.
   */
  ISSUED = 1,
  /**
   * Actual http request has been sent.
   */
  ACTIVE = 2,
  /**
   * Request completed successfully.
   */
  RECEIVED = 3,
  /**
   * Request was cancelled, either explicitly or automatically because of low priority.
   */
  CANCELLED = 4,
  /**
   * Request failed.
   */
  FAILED = 5
}

/**
* An enum identifying the type of request. Used for finer grained logging and priority sorting.
*/
export enum RequestType {
  /**
   * Terrain request.
   */
  TERRAIN = 0,
  /**
   * Imagery request.
   */
  IMAGERY = 1,
  /**
   * 3D Tiles request.
   */
  TILES3D = 2,
  /**
   * Other request.
   */
  OTHER = 3
}

export namespace Resource {
  /**
   * Initialization options for the Resource constructor
   * @property url - The url of the resource.
   * @property [queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @property [templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @property [headers = {}] - Additional HTTP headers that will be sent.
   * @property [proxy] - A proxy to be used when loading the resource.
   * @property [retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @property [retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @property [request] - A Request object that will be used. Intended for internal use only.
   */
  type ConstructorOptions = {
    url: string;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
  };
  /**
   * A function that returns the value of the property.
   * @param [resource] - The resource that failed to load.
   * @param [error] - The error that occurred during the loading of the resource.
   */
  type RetryCallback = (resource?: Resource, error?: Error) => boolean | Promise<boolean>;
}

/**
* A resource that includes the location and any other parameters we need to retrieve it or create derived resources. It also provides the ability to retry requests.
* @example
* function refreshTokenRetryCallback(resource, error) {
*   if (error.statusCode === 403) {
*     // 403 status code means a new token should be generated
*     return getNewAccessToken()
*       .then(function(token) {
*         resource.queryParameters.access_token = token;
*         return true;
*       })
*       .catch(function() {
*         return false;
*       });
*   }
*
*   return false;
* }
*
* const resource = new Resource({
*    url: 'http://server.com/path/to/resource.json',
*    proxy: new DefaultProxy('/proxy/'),
*    headers: {
*      'X-My-Header': 'valueOfHeader'
*    },
*    queryParameters: {
*      'access_token': '123-435-456-000'
*    },
*    retryCallback: refreshTokenRetryCallback,
*    retryAttempts: 1
* });
* @param options - A url or an object describing initialization options
*/
export class Resource {
  constructor(options: string | Resource.ConstructorOptions);
  /**
   * Additional HTTP headers that will be sent with the request.
   */
  headers: any;
  /**
   * A Request object that will be used. Intended for internal use only.
   */
  request: Request;
  /**
   * A proxy to be used when loading the resource.
   */
  proxy: Proxy;
  /**
   * Function to call when a request for this resource fails. If it returns true or a Promise that resolves to true, the request will be retried.
   */
  retryCallback: (...params: any[]) => any;
  /**
   * The number of times the retryCallback should be called before giving up.
   */
  retryAttempts: number;
  /**
   * Returns true if blobs are supported.
   */
  readonly isBlobSupported: boolean;
  /**
   * Query parameters appended to the url.
   */
  readonly queryParameters: any;
  /**
   * The key/value pairs used to replace template parameters in the url.
   */
  readonly templateValues: any;
  /**
   * The url to the resource with template values replaced, query string appended and encoded by proxy if one was set.
   */
  url: string;
  /**
   * The file extension of the resource.
   */
  readonly extension: string;
  /**
   * True if the Resource refers to a data URI.
   */
  isDataUri: boolean;
  /**
   * True if the Resource refers to a blob URI.
   */
  isBlobUri: boolean;
  /**
   * True if the Resource refers to a cross origin URL.
   */
  isCrossOriginUrl: boolean;
  /**
   * True if the Resource has request headers. This is equivalent to checking if the headers property has any keys.
   */
  hasHeaders: boolean;
  /**
   * Override Object#toString so that implicit string conversion gives the
   * complete URL represented by this Resource.
   * @returns The URL represented by this Resource
   */
  toString(): string;
  /**
   * Returns the url, optional with the query string and processed by a proxy.
   * @param [query = false] - If true, the query string is included.
   * @param [proxy = false] - If true, the url is processed by the proxy object, if defined.
   * @returns The url with all the requested components.
   */
  getUrlComponent(query?: boolean, proxy?: boolean): string;
  /**
   * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,
   *  as opposed to adding them one at a time to the queryParameters property. If a value is already set, it will be replaced with the new value.
   * @param params - The query parameters
   * @param [useAsDefault = false] - If true the params will be used as the default values, so they will only be set if they are undefined.
   */
  setQueryParameters(params: any, useAsDefault?: boolean): void;
  /**
   * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,
   *  as opposed to adding them one at a time to the queryParameters property.
   * @param params - The query parameters
   */
  appendQueryParameters(params: any): void;
  /**
   * Combines the specified object and the existing template values. This allows you to add many values at once,
   *  as opposed to adding them one at a time to the templateValues property. If a value is already set, it will become an array and the new value will be appended.
   * @param template - The template values
   * @param [useAsDefault = false] - If true the values will be used as the default values, so they will only be set if they are undefined.
   */
  setTemplateValues(template: any, useAsDefault?: boolean): void;
  /**
   * Returns a resource relative to the current instance. All properties remain the same as the current instance unless overridden in options.
   * @param options - An object with the following properties
   * @param [options.url] - The url that will be resolved relative to the url of the current instance.
   * @param [options.queryParameters] - An object containing query parameters that will be combined with those of the current instance.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}). These will be combined with those of the current instance.
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The function to call when loading the resource fails.
   * @param [options.retryAttempts] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @param [options.preserveQueryParameters = false] - If true, this will keep all query parameters from the current resource and derived resource. If false, derived parameters will replace those of the current resource.
   * @returns The resource derived from the current one.
   */
  getDerivedResource(options: {
    url?: string;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
    preserveQueryParameters?: boolean;
  }): Resource;
  /**
   * Duplicates a Resource instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Resource instance if one was not provided.
   */
  clone(result?: Resource): Resource;
  /**
   * Returns the base path of the Resource.
   * @param [includeQuery = false] - Whether or not to include the query string and fragment form the uri
   * @returns The base URI of the resource
   */
  getBaseUri(includeQuery?: boolean): string;
  /**
   * Appends a forward slash to the URL.
   */
  appendForwardSlash(): void;
  /**
   * Asynchronously loads the resource as raw binary data.  Returns a promise that will resolve to
   * an ArrayBuffer once loaded, or reject if the resource failed to load.  The data is loaded
   * using XMLHttpRequest, which means that in order to make requests to another origin,
   * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
   * @example
   * // load a single URL asynchronously
   * resource.fetchArrayBuffer().then(function(arrayBuffer) {
   *     // use the data
   * }).catch(function(error) {
   *     // an error occurred
   * });
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchArrayBuffer(): Promise<ArrayBuffer> | undefined;
  /**
   * Creates a Resource and calls fetchArrayBuffer() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchArrayBuffer(options: {
    url: string;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
  }): Promise<ArrayBuffer> | undefined;
  /**
   * Asynchronously loads the given resource as a blob.  Returns a promise that will resolve to
   * a Blob once loaded, or reject if the resource failed to load.  The data is loaded
   * using XMLHttpRequest, which means that in order to make requests to another origin,
   * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
   * @example
   * // load a single URL asynchronously
   * resource.fetchBlob().then(function(blob) {
   *     // use the data
   * }).catch(function(error) {
   *     // an error occurred
   * });
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchBlob(): Promise<Blob> | undefined;
  /**
   * Creates a Resource and calls fetchBlob() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchBlob(options: {
    url: string;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
  }): Promise<Blob> | undefined;
  /**
   * Asynchronously loads the given image resource.  Returns a promise that will resolve to
   * an {@link https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap|ImageBitmap} if <code>preferImageBitmap</code> is true and the browser supports <code>createImageBitmap</code> or otherwise an
   * {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement|Image} once loaded, or reject if the image failed to load.
   * @example
   * // load a single image asynchronously
   * resource.fetchImage().then(function(image) {
   *     // use the loaded image
   * }).catch(function(error) {
   *     // an error occurred
   * });
   *
   * // load several images in parallel
   * Promise.all([resource1.fetchImage(), resource2.fetchImage()]).then(function(images) {
   *     // images is an array containing all the loaded images
   * });
   * @param [options] - An object with the following properties.
   * @param [options.preferBlob = false] - If true, we will load the image via a blob.
   * @param [options.preferImageBitmap = false] - If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.
   * @param [options.flipY = false] - If true, image will be vertically flipped during decode. Only applies if the browser supports <code>createImageBitmap</code>.
   * @param [options.skipColorSpaceConversion = false] - If true, any custom gamma or color profiles in the image will be ignored. Only applies if the browser supports <code>createImageBitmap</code>.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchImage(options?: {
    preferBlob?: boolean;
    preferImageBitmap?: boolean;
    flipY?: boolean;
    skipColorSpaceConversion?: boolean;
  }): Promise<ImageBitmap | HTMLImageElement> | undefined;
  /**
   * Creates a Resource and calls fetchImage() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.flipY = false] - Whether to vertically flip the image during fetch and decode. Only applies when requesting an image and the browser supports <code>createImageBitmap</code>.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @param [options.preferBlob = false] - If true, we will load the image via a blob.
   * @param [options.preferImageBitmap = false] - If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.
   * @param [options.skipColorSpaceConversion = false] - If true, any custom gamma or color profiles in the image will be ignored. Only applies when requesting an image and the browser supports <code>createImageBitmap</code>.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchImage(options: {
    url: string;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    flipY?: boolean;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
    preferBlob?: boolean;
    preferImageBitmap?: boolean;
    skipColorSpaceConversion?: boolean;
  }): Promise<ImageBitmap | HTMLImageElement> | undefined;
  /**
   * Asynchronously loads the given resource as text.  Returns a promise that will resolve to
   * a String once loaded, or reject if the resource failed to load.  The data is loaded
   * using XMLHttpRequest, which means that in order to make requests to another origin,
   * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
   * @example
   * // load text from a URL, setting a custom header
   * const resource = new Resource({
   *   url: 'http://someUrl.com/someJson.txt',
   *   headers: {
   *     'X-Custom-Header' : 'some value'
   *   }
   * });
   * resource.fetchText().then(function(text) {
   *     // Do something with the text
   * }).catch(function(error) {
   *     // an error occurred
   * });
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchText(): Promise<string> | undefined;
  /**
   * Creates a Resource and calls fetchText() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchText(options: {
    url: string;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
  }): Promise<string> | undefined;
  /**
   * Asynchronously loads the given resource as JSON.  Returns a promise that will resolve to
   * a JSON object once loaded, or reject if the resource failed to load.  The data is loaded
   * using XMLHttpRequest, which means that in order to make requests to another origin,
   * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. This function
   * adds 'Accept: application/json,&#42;&#47;&#42;;q=0.01' to the request headers, if not
   * already specified.
   * @example
   * resource.fetchJson().then(function(jsonData) {
   *     // Do something with the JSON object
   * }).catch(function(error) {
   *     // an error occurred
   * });
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchJson(): Promise<any> | undefined;
  /**
   * Creates a Resource and calls fetchJson() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchJson(options: {
    url: string;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
  }): Promise<any> | undefined;
  /**
   * Asynchronously loads the given resource as XML.  Returns a promise that will resolve to
   * an XML Document once loaded, or reject if the resource failed to load.  The data is loaded
   * using XMLHttpRequest, which means that in order to make requests to another origin,
   * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
   * @example
   * // load XML from a URL, setting a custom header
   * SuperMap.loadXML('http://someUrl.com/someXML.xml', {
   *   'X-Custom-Header' : 'some value'
   * }).then(function(document) {
   *     // Do something with the document
   * }).catch(function(error) {
   *     // an error occurred
   * });
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchXML(): Promise<XMLDocument> | undefined;
  /**
   * Creates a Resource and calls fetchXML() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchXML(options: {
    url: string;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
  }): Promise<XMLDocument> | undefined;
  /**
   * Requests a resource using JSONP.
   * @example
   * // load a data asynchronously
   * resource.fetchJsonp().then(function(data) {
   *     // use the loaded data
   * }).catch(function(error) {
   *     // an error occurred
   * });
   * @param [callbackParameterName = 'callback'] - The callback parameter name that the server expects.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchJsonp(callbackParameterName?: string): Promise<any> | undefined;
  /**
   * Creates a Resource from a URL and calls fetchJsonp() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @param [options.callbackParameterName = 'callback'] - The callback parameter name that the server expects.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetchJsonp(options: {
    url: string;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
    callbackParameterName?: string;
  }): Promise<any> | undefined;
  /**
   * Asynchronously loads the given resource.  Returns a promise that will resolve to
   * the result once loaded, or reject if the resource failed to load.  The data is loaded
   * using XMLHttpRequest, which means that in order to make requests to another origin,
   * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. It's recommended that you use
   * the more specific functions eg. fetchJson, fetchBlob, etc.
   * @example
   * resource.fetch()
   *   .then(function(body) {
   *       // use the data
   *   }).catch(function(error) {
   *       // an error occurred
   *   });
   * @param [options] - Object with the following properties:
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.headers] - Additional HTTP headers to send with the request, if any.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetch(options?: {
    responseType?: string;
    headers?: any;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Creates a Resource from a URL and calls fetch() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  fetch(options: {
    url: string;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
    responseType?: string;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Asynchronously deletes the given resource.  Returns a promise that will resolve to
   * the result once loaded, or reject if the resource failed to load.  The data is loaded
   * using XMLHttpRequest, which means that in order to make requests to another origin,
   * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
   * @example
   * resource.delete()
   *   .then(function(body) {
   *       // use the data
   *   }).catch(function(error) {
   *       // an error occurred
   *   });
   * @param [options] - Object with the following properties:
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.headers] - Additional HTTP headers to send with the request, if any.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  delete(options?: {
    responseType?: string;
    headers?: any;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Creates a Resource from a URL and calls delete() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param [options.data] - Data that is posted with the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  delete(options: {
    url: string;
    data?: any;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
    responseType?: string;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Asynchronously gets headers the given resource.  Returns a promise that will resolve to
   * the result once loaded, or reject if the resource failed to load.  The data is loaded
   * using XMLHttpRequest, which means that in order to make requests to another origin,
   * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
   * @example
   * resource.head()
   *   .then(function(headers) {
   *       // use the data
   *   }).catch(function(error) {
   *       // an error occurred
   *   });
   * @param [options] - Object with the following properties:
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.headers] - Additional HTTP headers to send with the request, if any.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  head(options?: {
    responseType?: string;
    headers?: any;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Creates a Resource from a URL and calls head() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  head(options: {
    url: string;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
    responseType?: string;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Asynchronously gets options the given resource.  Returns a promise that will resolve to
   * the result once loaded, or reject if the resource failed to load.  The data is loaded
   * using XMLHttpRequest, which means that in order to make requests to another origin,
   * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
   * @example
   * resource.options()
   *   .then(function(headers) {
   *       // use the data
   *   }).catch(function(error) {
   *       // an error occurred
   *   });
   * @param [options] - Object with the following properties:
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.headers] - Additional HTTP headers to send with the request, if any.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  options(options?: {
    responseType?: string;
    headers?: any;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Creates a Resource from a URL and calls options() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  options(options: {
    url: string;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
    responseType?: string;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Asynchronously posts data to the given resource.  Returns a promise that will resolve to
   * the result once loaded, or reject if the resource failed to load.  The data is loaded
   * using XMLHttpRequest, which means that in order to make requests to another origin,
   * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
   * @example
   * resource.post(data)
   *   .then(function(result) {
   *       // use the result
   *   }).catch(function(error) {
   *       // an error occurred
   *   });
   * @param data - Data that is posted with the resource.
   * @param [options] - Object with the following properties:
   * @param [options.data] - Data that is posted with the resource.
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.headers] - Additional HTTP headers to send with the request, if any.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  post(data: any, options?: {
    data?: any;
    responseType?: string;
    headers?: any;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Creates a Resource from a URL and calls post() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param options.data - Data that is posted with the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  post(options: {
    url: string;
    data: any;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
    responseType?: string;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Asynchronously puts data to the given resource.  Returns a promise that will resolve to
   * the result once loaded, or reject if the resource failed to load.  The data is loaded
   * using XMLHttpRequest, which means that in order to make requests to another origin,
   * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
   * @example
   * resource.put(data)
   *   .then(function(result) {
   *       // use the result
   *   }).catch(function(error) {
   *       // an error occurred
   *   });
   * @param data - Data that is posted with the resource.
   * @param [options] - Object with the following properties:
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.headers] - Additional HTTP headers to send with the request, if any.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  put(data: any, options?: {
    responseType?: string;
    headers?: any;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Creates a Resource from a URL and calls put() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param options.data - Data that is posted with the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  put(options: {
    url: string;
    data: any;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
    responseType?: string;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Asynchronously patches data to the given resource.  Returns a promise that will resolve to
   * the result once loaded, or reject if the resource failed to load.  The data is loaded
   * using XMLHttpRequest, which means that in order to make requests to another origin,
   * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
   * @example
   * resource.patch(data)
   *   .then(function(result) {
   *       // use the result
   *   }).catch(function(error) {
   *       // an error occurred
   *   });
   * @param data - Data that is posted with the resource.
   * @param [options] - Object with the following properties:
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.headers] - Additional HTTP headers to send with the request, if any.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  patch(data: any, options?: {
    responseType?: string;
    headers?: any;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * Creates a Resource from a URL and calls patch() on it.
   * @param options - A url or an object with the following properties
   * @param options.url - The url of the resource.
   * @param options.data - Data that is posted with the resource.
   * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
   * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
   * @param [options.headers = {}] - Additional HTTP headers that will be sent.
   * @param [options.proxy] - A proxy to be used when loading the resource.
   * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
   * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
   * @param [options.request] - A Request object that will be used. Intended for internal use only.
   * @param [options.responseType] - The type of response.  This controls the type of item returned.
   * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
   * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
   */
  patch(options: {
    url: string;
    data: any;
    queryParameters?: any;
    templateValues?: any;
    headers?: any;
    proxy?: Proxy;
    retryCallback?: Resource.RetryCallback;
    retryAttempts?: number;
    request?: Request;
    responseType?: string;
    overrideMimeType?: string;
  }): Promise<any> | undefined;
  /**
   * A resource instance initialized to the current browser location
   */
  readonly DEFAULT: Resource;
}

/**
* Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,
* out of memory, could not compile shader, etc.  If a function may throw this
* exception, the calling code should be prepared to catch it.
* <br /><br />
* On the other hand, a {@link DeveloperError} indicates an exception due
* to a developer error, e.g., invalid argument, that usually indicates a bug in the
* calling code.
* @param [message] - The error message for this exception.
*/
export class RuntimeError extends Error {
  constructor(message?: string);
  /**
   * 'RuntimeError' indicating that this exception was thrown due to a runtime error.
   */
  readonly name: string;
  /**
   * The explanation for why this exception was thrown.
   */
  readonly message: string;
  /**
   * The stack trace of this exception, if available.
   */
  readonly stack: string;
}

export namespace ScreenSpaceEventHandler {
  /**
   * An Event that occurs at a single position on screen.
   */
  type PositionedEvent = {
    position: Cartesian2;
  };
  /**
   * @param event - The event which triggered the listener
   */
  type PositionedEventCallback = (event: ScreenSpaceEventHandler.PositionedEvent) => void;
  /**
   * An Event that starts at one position and ends at another.
   */
  type MotionEvent = {
    startPosition: Cartesian2;
    endPosition: Cartesian2;
  };
  /**
   * @param event - The event which triggered the listener
   */
  type MotionEventCallback = (event: ScreenSpaceEventHandler.MotionEvent) => void;
  /**
   * An Event that occurs at a two positions on screen.
   */
  type TwoPointEvent = {
    position1: Cartesian2;
    position2: Cartesian2;
  };
  /**
   * @param event - The event which triggered the listener
   */
  type TwoPointEventCallback = (event: ScreenSpaceEventHandler.TwoPointEvent) => void;
  /**
   * An Event that starts at a two positions on screen and moves to two other positions.
   */
  type TwoPointMotionEvent = {
    position1: Cartesian2;
    position2: Cartesian2;
    previousPosition1: Cartesian2;
    previousPosition2: Cartesian2;
  };
  /**
   * @param event - The event which triggered the listener
   */
  type TwoPointMotionEventCallback = (event: ScreenSpaceEventHandler.TwoPointMotionEvent) => void;
  /**
   * @param delta - The amount that the mouse wheel moved
   */
  type WheelEventCallback = (delta: number) => void;
}

/**
* Handles user input events. Custom functions can be added to be executed on
* when the user enters input.
* @param [element = document] - The element to add events to.
*/
export class ScreenSpaceEventHandler {
  constructor(element?: HTMLCanvasElement);
  /**
   * Set a function to be executed on an input event.
   * @param action - Function to be executed when the input event occurs.
   * @param type - The ScreenSpaceEventType of input event.
   * @param [modifier] - A KeyboardEventModifier key that is held when a <code>type</code>
   * event occurs.
   */
  setInputAction(action: ScreenSpaceEventHandler.PositionedEventCallback | ScreenSpaceEventHandler.MotionEventCallback | ScreenSpaceEventHandler.WheelEventCallback | ScreenSpaceEventHandler.TwoPointEventCallback | ScreenSpaceEventHandler.TwoPointMotionEventCallback, type: ScreenSpaceEventType, modifier?: KeyboardEventModifier): void;
  /**
   * Returns the function to be executed on an input event.
   * @param type - The ScreenSpaceEventType of input event.
   * @param [modifier] - A KeyboardEventModifier key that is held when a <code>type</code>
   * event occurs.
   * @returns The function to be executed on an input event.
   */
  getInputAction(type: ScreenSpaceEventType, modifier?: KeyboardEventModifier): ScreenSpaceEventHandler.PositionedEventCallback | ScreenSpaceEventHandler.MotionEventCallback | ScreenSpaceEventHandler.WheelEventCallback | ScreenSpaceEventHandler.TwoPointEventCallback | ScreenSpaceEventHandler.TwoPointMotionEventCallback;
  /**
   * Removes the function to be executed on an input event.
   * @param type - The ScreenSpaceEventType of input event.
   * @param [modifier] - A KeyboardEventModifier key that is held when a <code>type</code>
   * event occurs.
   */
  removeInputAction(type: ScreenSpaceEventType, modifier?: KeyboardEventModifier): void;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Removes listeners held by this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * handler = handler && handler.destroy();
   */
  destroy(): void;
  /**
   * The amount of time, in milliseconds, that mouse events will be disabled after
   * receiving any touch events, such that any emulated mouse events will be ignored.
   */
  mouseEmulationIgnoreMilliseconds: number;
  /**
   * The amount of time, in milliseconds, before a touch on the screen becomes a
   * touch and hold.
   */
  touchHoldDelayMilliseconds: number;
}

/**
* This enumerated type is for classifying mouse events: down, up, click, double click, move and move while a button is held down.
*/
export enum ScreenSpaceEventType {
  /**
   * Represents a mouse left button down event.
   */
  LEFT_DOWN = 0,
  /**
   * Represents a mouse left button up event.
   */
  LEFT_UP = 1,
  /**
   * Represents a mouse left click event.
   */
  LEFT_CLICK = 2,
  /**
   * Represents a mouse left double click event.
   */
  LEFT_DOUBLE_CLICK = 3,
  /**
   * Represents a mouse left button down event.
   */
  RIGHT_DOWN = 5,
  /**
   * Represents a mouse right button up event.
   */
  RIGHT_UP = 6,
  /**
   * Represents a mouse right click event.
   */
  RIGHT_CLICK = 7,
  /**
   * Represents a mouse middle button down event.
   */
  MIDDLE_DOWN = 10,
  /**
   * Represents a mouse middle button up event.
   */
  MIDDLE_UP = 11,
  /**
   * Represents a mouse middle click event.
   */
  MIDDLE_CLICK = 12,
  /**
   * Represents a mouse move event.
   */
  MOUSE_MOVE = 15,
  /**
   * Represents a mouse wheel event.
   */
  WHEEL = 16,
  /**
   * Represents the start of a two-finger event on a touch surface.
   */
  PINCH_START = 17,
  /**
   * Represents the end of a two-finger event on a touch surface.
   */
  PINCH_END = 18,
  /**
   * Represents a change of a two-finger event on a touch surface.
   */
  PINCH_MOVE = 19
}

/**
* Value and type information for per-instance geometry attribute that determines if the geometry instance will be shown.
* @example
* const instance = new SuperMap.GeometryInstance({
*   geometry : new SuperMap.BoxGeometry({
*     vertexFormat : SuperMap.VertexFormat.POSITION_AND_NORMAL,
*     minimum : new SuperMap.Cartesian3(-250000.0, -250000.0, -250000.0),
*     maximum : new SuperMap.Cartesian3(250000.0, 250000.0, 250000.0)
*   }),
*   modelMatrix : SuperMap.Matrix4.multiplyByTranslation(SuperMap.Transforms.eastNorthUpToFixedFrame(
*     SuperMap.Cartesian3.fromDegrees(-75.59777, 40.03883)), new SuperMap.Cartesian3(0.0, 0.0, 1000000.0), new SuperMap.Matrix4()),
*   id : 'box',
*   attributes : {
*     show : new SuperMap.ShowGeometryInstanceAttribute(false)
*   }
* });
* @param [show = true] - Determines if the geometry instance will be shown.
*/
export class ShowGeometryInstanceAttribute {
  constructor(show?: boolean);
  /**
   * The values for the attributes stored in a typed array.
   */
  value: Uint8Array;
  /**
   * The datatype of each component in the attribute, e.g., individual elements in
   * {@link ColorGeometryInstanceAttribute#value}.
   */
  readonly componentDatatype: ComponentDatatype;
  /**
   * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.
   */
  readonly componentsPerAttribute: number;
  /**
   * When <code>true</code> and <code>componentDatatype</code> is an integer format,
   * indicate that the components should be mapped to the range [0, 1] (unsigned)
   * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
   */
  readonly normalize: boolean;
  /**
   * Converts a boolean show to a typed array that can be used to assign a show attribute.
   * @example
   * const attributes = primitive.getGeometryInstanceAttributes('an id');
   * attributes.show = SuperMap.ShowGeometryInstanceAttribute.toValue(true, attributes.show);
   * @param show - The show value.
   * @param [result] - The array to store the result in, if undefined a new instance will be created.
   * @returns The modified result parameter or a new instance if result was undefined.
   */
  toValue(show: boolean, result?: Uint8Array): Uint8Array;
}

/**
* Contains functions for finding the Cartesian coordinates of the sun and the moon in the
* Earth-centered inertial frame.
*/
export namespace Simon1994PlanetaryPositions {
  /**
   * Computes the position of the Sun in the Earth-centered inertial frame
   * @param [julianDate] - The time at which to compute the Sun's position, if not provided the current system time is used.
   * @param [result] - The object onto which to store the result.
   * @returns Calculated sun position
   */
  function computeSunPositionInEarthInertialFrame(julianDate?: JulianDate, result?: Cartesian3): Cartesian3;
  /**
   * Computes the position of the Moon in the Earth-centered inertial frame
   * @param [julianDate] - The time at which to compute the Sun's position, if not provided the current system time is used.
   * @param [result] - The object onto which to store the result.
   * @returns Calculated moon position
   */
  function computeMoonPositionInEarthInertialFrame(julianDate?: JulianDate, result?: Cartesian3): Cartesian3;
}

/**
* A description of a polyline modeled as a line strip; the first two positions define a line segment,
* and each additional position defines a line segment from the previous position.
* @example
* // A polyline with two connected line segments
* const polyline = new SuperMap.SimplePolylineGeometry({
*   positions : SuperMap.Cartesian3.fromDegreesArray([
*     0.0, 0.0,
*     5.0, 0.0,
*     5.0, 5.0
*   ])
* });
* const geometry = SuperMap.SimplePolylineGeometry.createGeometry(polyline);
* @param options - Object with the following properties:
* @param options.positions - An array of {@link Cartesian3} defining the positions in the polyline as a line strip.
* @param [options.colors] - An Array of {@link Color} defining the per vertex or per segment colors.
* @param [options.colorsPerVertex = false] - A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.
* @param [options.arcType = ArcType.GEODESIC] - The type of line the polyline segments must follow.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
*/
export class SimplePolylineGeometry {
  constructor(options: {
    positions: Cartesian3[];
    colors?: Color[];
    colorsPerVertex?: boolean;
    arcType?: ArcType;
    granularity?: number;
    ellipsoid?: Ellipsoid;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: SimplePolylineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new SimplePolylineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: SimplePolylineGeometry): SimplePolylineGeometry;
  /**
   * Computes the geometric representation of a simple polyline, including its vertices, indices, and a bounding sphere.
   * @param simplePolylineGeometry - A description of the polyline.
   * @returns The computed vertices and indices.
   */
  createGeometry(simplePolylineGeometry: SimplePolylineGeometry): Geometry | undefined;
}

/**
* A description of a sphere centered at the origin.
* @example
* const sphere = new SuperMap.SphereGeometry({
*   radius : 100.0,
*   vertexFormat : SuperMap.VertexFormat.POSITION_ONLY
* });
* const geometry = SuperMap.SphereGeometry.createGeometry(sphere);
* @param [options] - Object with the following properties:
* @param [options.radius = 1.0] - The radius of the sphere.
* @param [options.stackPartitions = 64] - The number of times to partition the ellipsoid into stacks.
* @param [options.slicePartitions = 64] - The number of times to partition the ellipsoid into radial slices.
* @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
*/
export class SphereGeometry {
  constructor(options?: {
    radius?: number;
    stackPartitions?: number;
    slicePartitions?: number;
    vertexFormat?: VertexFormat;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: SphereGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new SphereGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: SphereGeometry): SphereGeometry;
  /**
   * Computes the geometric representation of a sphere, including its vertices, indices, and a bounding sphere.
   * @param sphereGeometry - A description of the sphere.
   * @returns The computed vertices and indices.
   */
  createGeometry(sphereGeometry: SphereGeometry): Geometry | undefined;
}

/**
* A description of the outline of a sphere.
* @example
* const sphere = new SuperMap.SphereOutlineGeometry({
*   radius : 100.0,
*   stackPartitions : 6,
*   slicePartitions: 5
* });
* const geometry = SuperMap.SphereOutlineGeometry.createGeometry(sphere);
* @param [options] - Object with the following properties:
* @param [options.radius = 1.0] - The radius of the sphere.
* @param [options.stackPartitions = 10] - The count of stacks for the sphere (1 greater than the number of parallel lines).
* @param [options.slicePartitions = 8] - The count of slices for the sphere (Equal to the number of radial lines).
* @param [options.subdivisions = 200] - The number of points per line, determining the granularity of the curvature .
*/
export class SphereOutlineGeometry {
  constructor(options?: {
    radius?: number;
    stackPartitions?: number;
    slicePartitions?: number;
    subdivisions?: number;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: SphereOutlineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new SphereOutlineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: SphereOutlineGeometry): SphereOutlineGeometry;
  /**
   * Computes the geometric representation of an outline of a sphere, including its vertices, indices, and a bounding sphere.
   * @param sphereGeometry - A description of the sphere outline.
   * @returns The computed vertices and indices.
   */
  createGeometry(sphereGeometry: SphereOutlineGeometry): Geometry | undefined;
}

/**
* A set of curvilinear 3-dimensional coordinates.
* @param [clock = 0.0] - The angular coordinate lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
* @param [cone = 0.0] - The angular coordinate measured from the positive z-axis and toward the negative z-axis.
* @param [magnitude = 1.0] - The linear coordinate measured from the origin.
*/
export class Spherical {
  constructor(clock?: number, cone?: number, magnitude?: number);
  /**
   * The clock component.
   */
  clock: number;
  /**
   * The cone component.
   */
  cone: number;
  /**
   * The magnitude component.
   */
  magnitude: number;
  /**
   * Converts the provided Cartesian3 into Spherical coordinates.
   * @param cartesian3 - The Cartesian3 to be converted to Spherical.
   * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
   * @returns The modified result parameter, or a new instance if one was not provided.
   */
  fromCartesian3(cartesian3: Cartesian3, result?: Spherical): Spherical;
  /**
   * Creates a duplicate of a Spherical.
   * @param spherical - The spherical to clone.
   * @param [result] - The object to store the result into, if undefined a new instance will be created.
   * @returns The modified result parameter or a new instance if result was undefined. (Returns undefined if spherical is undefined)
   */
  clone(spherical: Spherical, result?: Spherical): Spherical;
  /**
   * Computes the normalized version of the provided spherical.
   * @param spherical - The spherical to be normalized.
   * @param [result] - The object to store the result into, if undefined a new instance will be created.
   * @returns The modified result parameter or a new instance if result was undefined.
   */
  normalize(spherical: Spherical, result?: Spherical): Spherical;
  /**
   * Returns true if the first spherical is equal to the second spherical, false otherwise.
   * @param left - The first Spherical to be compared.
   * @param right - The second Spherical to be compared.
   * @returns true if the first spherical is equal to the second spherical, false otherwise.
   */
  equals(left: Spherical, right: Spherical): boolean;
  /**
   * Returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
   * @param left - The first Spherical to be compared.
   * @param right - The second Spherical to be compared.
   * @param [epsilon = 0.0] - The epsilon to compare against.
   * @returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
   */
  equalsEpsilon(left: Spherical, right: Spherical, epsilon?: number): boolean;
  /**
   * Returns true if this spherical is equal to the provided spherical, false otherwise.
   * @param other - The Spherical to be compared.
   * @returns true if this spherical is equal to the provided spherical, false otherwise.
   */
  equals(other: Spherical): boolean;
  /**
   * Creates a duplicate of this Spherical.
   * @param [result] - The object to store the result into, if undefined a new instance will be created.
   * @returns The modified result parameter or a new instance if result was undefined.
   */
  clone(result?: Spherical): Spherical;
  /**
   * Returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
   * @param other - The Spherical to be compared.
   * @param epsilon - The epsilon to compare against.
   * @returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
   */
  equalsEpsilon(other: Spherical, epsilon: number): boolean;
  /**
   * Returns a string representing this instance in the format (clock, cone, magnitude).
   * @returns A string representing this instance.
   */
  toString(): string;
}

/**
 * Creates a curve parameterized and evaluated by time. This type describes an interface
 * and is not intended to be instantiated directly.
 */
export class Spline {
  constructor();
  /**
   * An array of times for the control points.
   */
  times: number[];
  /**
   * An array of control points.
   */
  points: Cartesian3[] | Quaternion[];
  /**
   * Evaluates the curve at a given time.
   * @param time - The time at which to evaluate the curve.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new instance of the point on the curve at the given time.
   */
  evaluate(time: number, result?: Cartesian3 | Quaternion | number[]): Cartesian3 | Quaternion | number[];
  /**
   * Finds an index <code>i</code> in <code>times</code> such that the parameter
   * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
   * @param time - The time.
   * @param startIndex - The index from which to start the search.
   * @returns The index for the element at the start of the interval.
   */
  findTimeInterval(time: number, startIndex: number): number;
  /**
   * Wraps the given time to the period covered by the spline.
   * @param time - The time.
   * @returns The time, wrapped around the animation period.
   */
  wrapTime(time: number): number;
  /**
   * Clamps the given time to the period covered by the spline.
   * @param time - The time.
   * @returns The time, clamped to the animation period.
   */
  clampTime(time: number): number;
}

/**
 * A wrapper around a web worker that allows scheduling tasks for a given worker,
 * returning results asynchronously via a promise.
 *
 * The Worker is not constructed until a task is scheduled.
 * @param workerPath - The Url to the worker. This can either be an absolute path or relative to the SuperMap Workers folder.
 * @param [maximumActiveTasks = Number.POSITIVE_INFINITY] - The maximum number of active tasks.  Once exceeded,
 *                                        scheduleTask will not queue any more tasks, allowing
 *                                        work to be rescheduled in future frames.
 */
export class TaskProcessor {
  constructor(workerPath: string, maximumActiveTasks?: number);
  /**
   * Schedule a task to be processed by the web worker asynchronously.  If there are currently more
   * tasks active than the maximum set by the constructor, will immediately return undefined.
   * Otherwise, returns a promise that will resolve to the result posted back by the worker when
   * finished.
   * @example
   * const taskProcessor = new SuperMap.TaskProcessor('myWorkerPath');
   * const promise = taskProcessor.scheduleTask({
   *     someParameter : true,
   *     another : 'hello'
   * });
   * if (!SuperMap.defined(promise)) {
   *     // too many active tasks - try again later
   * } else {
   *     promise.then(function(result) {
   *         // use the result of the task
   *     });
   * }
   * @param parameters - Any input data that will be posted to the worker.
   * @param [transferableObjects] - An array of objects contained in parameters that should be
   *                                      transferred to the worker instead of copied.
   * @returns Either a promise that will resolve to the result when available, or undefined
   *                    if there are too many active tasks,
   */
  scheduleTask(parameters: any, transferableObjects?: object[]): Promise<object> | undefined;
  /**
   * Posts a message to a web worker with configuration to initialize loading
   * and compiling a web assembly module asychronously, as well as an optional
   * fallback JavaScript module to use if Web Assembly is not supported.
   * @param [webAssemblyOptions] - An object with the following properties:
   * @param [webAssemblyOptions.modulePath] - The path of the web assembly JavaScript wrapper module.
   * @param [webAssemblyOptions.wasmBinaryFile] - The path of the web assembly binary file.
   * @param [webAssemblyOptions.fallbackModulePath] - The path of the fallback JavaScript module to use if web assembly is not supported.
   * @returns A promise that resolves to the result when the web worker has loaded and compiled the web assembly module and is ready to process tasks.
   */
  initWebAssemblyModule(webAssemblyOptions?: {
    modulePath?: string;
    wasmBinaryFile?: string;
    fallbackModulePath?: string;
  }): Promise<object>;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Destroys this object.  This will immediately terminate the Worker.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   */
  destroy(): void;
}

/**
* Terrain data for a single tile.  This type describes an
* interface and is not intended to be instantiated directly.
*/
export class TerrainData {
  constructor();
  /**
   * An array of credits for this tile.
   */
  credits: Credit[];
  /**
   * The water mask included in this terrain data, if any.  A water mask is a rectangular
   * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
   * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
   */
  waterMask: Uint8Array | HTMLImageElement | HTMLCanvasElement;
  /**
   * Computes the terrain height at a specified longitude and latitude.
   * @param rectangle - The rectangle covered by this terrain data.
   * @param longitude - The longitude in radians.
   * @param latitude - The latitude in radians.
   * @returns The terrain height at the specified position.  If the position
   *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly
   *          incorrect for positions far outside the rectangle.
   */
  interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;
  /**
   * Determines if a given child tile is available, based on the
   * {@link TerrainData#childTileMask}.  The given child tile coordinates are assumed
   * to be one of the four children of this tile.  If non-child tile coordinates are
   * given, the availability of the southeast child tile is returned.
   * @param thisX - The tile X coordinate of this (the parent) tile.
   * @param thisY - The tile Y coordinate of this (the parent) tile.
   * @param childX - The tile X coordinate of the child tile to check for availability.
   * @param childY - The tile Y coordinate of the child tile to check for availability.
   * @returns True if the child tile is available; otherwise, false.
   */
  isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): boolean;
  /**
   * Upsamples this terrain data for use by a descendant tile.
   * @param tilingScheme - The tiling scheme of this terrain data.
   * @param thisX - The X coordinate of this tile in the tiling scheme.
   * @param thisY - The Y coordinate of this tile in the tiling scheme.
   * @param thisLevel - The level of this tile in the tiling scheme.
   * @param descendantX - The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
   * @param descendantY - The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
   * @param descendantLevel - The level within the tiling scheme of the descendant tile for which we are upsampling.
   * @returns A promise for upsampled terrain data for the descendant tile,
   *          or undefined if too many asynchronous upsample operations are in progress and the request has been
   *          deferred.
   */
  upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): Promise<TerrainData> | undefined;
  /**
   * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
   * terrain data.  If this value is false, the data was obtained from some other source, such
   * as by downloading it from a remote server.  This method should return true for instances
   * returned from a call to {@link TerrainData#upsample}.
   * @returns True if this instance was created by upsampling; otherwise, false.
   */
  wasCreatedByUpsampling(): boolean;
}

export namespace TerrainProvider {
  /**
   * A function that is called when an error occurs.
   * @param err - An object holding details about the error that occurred.
   */
  type ErrorEvent = (this: TerrainProvider, err: TileProviderError) => void;
}

/**
* Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is
* organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an
* interface and is not intended to be instantiated directly.
*/
export class TerrainProvider {
  constructor();
  /**
   * Gets an event that is raised when the terrain provider encounters an asynchronous error..  By subscribing
   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
   * are passed an instance of {@link TileProviderError}.
   */
  readonly errorEvent: Event<TerrainProvider.ErrorEvent>;
  /**
   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
   * the source of the terrain. This function should
   * not be called before {@link TerrainProvider#ready} returns true.
   */
  readonly credit: Credit;
  /**
   * Gets the tiling scheme used by the provider.  This function should
   * not be called before {@link TerrainProvider#ready} returns true.
   */
  readonly tilingScheme: TilingScheme;
  /**
   * Gets a value indicating whether or not the provider is ready for use.
   */
  readonly ready: boolean;
  /**
   * Gets a promise that resolves to true when the provider is ready for use.
   */
  readonly readyPromise: Promise<boolean>;
  /**
   * Gets a value indicating whether or not the provider includes a water mask.  The water mask
   * indicates which areas of the globe are water rather than land, so they can be rendered
   * as a reflective surface with animated waves.  This function should not be
   * called before {@link TerrainProvider#ready} returns true.
   */
  readonly hasWaterMask: boolean;
  /**
   * Gets a value indicating whether or not the requested tiles include vertex normals.
   * This function should not be called before {@link TerrainProvider#ready} returns true.
   */
  readonly hasVertexNormals: boolean;
  /**
   * Gets an object that can be used to determine availability of terrain from this provider, such as
   * at points and in rectangles.  This function should not be called before
   * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability
   * information is not available.
   */
  readonly availability: TileAvailability;
  /**
   * Gets a list of indices for a triangle mesh representing a regular grid.  Calling
   * this function multiple times with the same grid width and height returns the
   * same list of indices.  The total number of vertices must be less than or equal
   * to 65536.
   * @param width - The number of vertices in the regular grid in the horizontal direction.
   * @param height - The number of vertices in the regular grid in the vertical direction.
   * @returns The list of indices. Uint16Array gets returned for 64KB or less and Uint32Array for 4GB or less.
   */
  getRegularGridIndices(width: number, height: number): Uint16Array | Uint32Array;
  /**
   * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will
   * ensure that adjacent heightmap vertices are separated by no more than
   * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.
   * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the
   * screen pixels between adjacent heightmap vertices and thus rendering more quickly.
   */
  heightmapTerrainQuality: number;
  /**
   * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.
   * @param ellipsoid - The ellipsoid to which the terrain is attached.
   * @param tileImageWidth - The width, in pixels, of the heightmap associated with a single tile.
   * @param numberOfTilesAtLevelZero - The number of tiles in the horizontal direction at tile level zero.
   * @returns An estimated geometric error.
   */
  getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid: Ellipsoid, tileImageWidth: number, numberOfTilesAtLevelZero: number): number;
  /**
   * Requests the geometry for a given tile.  This function should not be called before
   * {@link TerrainProvider#ready} returns true.  The result must include terrain data and
   * may optionally include a water mask and an indication of which child tiles are available.
   * @param x - The X coordinate of the tile for which to request geometry.
   * @param y - The Y coordinate of the tile for which to request geometry.
   * @param level - The level of the tile for which to request geometry.
   * @param [request] - The request object. Intended for internal use only.
   * @returns A promise for the requested geometry.  If this method
   *          returns undefined instead of a promise, it is an indication that too many requests are already
   *          pending and the request will be retried later.
   */
  requestTileGeometry(x: number, y: number, level: number, request?: Request): Promise<TerrainData> | undefined;
  /**
   * Gets the maximum geometric error allowed in a tile at a given level.  This function should not be
   * called before {@link TerrainProvider#ready} returns true.
   * @param level - The tile level for which to get the maximum geometric error.
   * @returns The maximum geometric error.
   */
  getLevelMaximumGeometricError(level: number): number;
  /**
   * Determines whether data for a tile is available to be loaded.
   * @param x - The X coordinate of the tile for which to request geometry.
   * @param y - The Y coordinate of the tile for which to request geometry.
   * @param level - The level of the tile for which to request geometry.
   * @returns Undefined if not supported by the terrain provider, otherwise true or false.
   */
  getTileDataAvailable(x: number, y: number, level: number): boolean | undefined;
  /**
   * Makes sure we load availability data for a tile
   * @param x - The X coordinate of the tile for which to request geometry.
   * @param y - The Y coordinate of the tile for which to request geometry.
   * @param level - The level of the tile for which to request geometry.
   * @returns Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded
   */
  loadTileDataAvailability(x: number, y: number, level: number): undefined | Promise<void>;
}

/**
* Reports the availability of tiles in a {@link TilingScheme}.
* @param tilingScheme - The tiling scheme in which to report availability.
* @param maximumLevel - The maximum tile level that is potentially available.
*/
export class TileAvailability {
  constructor(tilingScheme: TilingScheme, maximumLevel: number);
  /**
   * Marks a rectangular range of tiles in a particular level as being available.  For best performance,
   * add your ranges in order of increasing level.
   * @param level - The level.
   * @param startX - The X coordinate of the first available tiles at the level.
   * @param startY - The Y coordinate of the first available tiles at the level.
   * @param endX - The X coordinate of the last available tiles at the level.
   * @param endY - The Y coordinate of the last available tiles at the level.
   */
  addAvailableTileRange(level: number, startX: number, startY: number, endX: number, endY: number): void;
  /**
   * Determines the level of the most detailed tile covering the position.  This function
   * usually completes in time logarithmic to the number of rectangles added with
   * {@link TileAvailability#addAvailableTileRange}.
   * @param position - The position for which to determine the maximum available level.  The height component is ignored.
   * @returns The level of the most detailed tile covering the position.
   */
  computeMaximumLevelAtPosition(position: Cartographic): number;
  /**
   * Finds the most detailed level that is available _everywhere_ within a given rectangle.  More detailed
   * tiles may be available in parts of the rectangle, but not the whole thing.  The return value of this
   * function may be safely passed to {@link sampleTerrain} for any position within the rectangle.  This function
   * usually completes in time logarithmic to the number of rectangles added with
   * {@link TileAvailability#addAvailableTileRange}.
   * @param rectangle - The rectangle.
   * @returns The best available level for the entire rectangle.
   */
  computeBestAvailableLevelOverRectangle(rectangle: Rectangle): number;
  /**
   * Determines if a particular tile is available.
   * @param level - The tile level to check.
   * @param x - The X coordinate of the tile to check.
   * @param y - The Y coordinate of the tile to check.
   * @returns True if the tile is available; otherwise, false.
   */
  isTileAvailable(level: number, x: number, y: number): boolean;
  /**
   * Computes a bit mask indicating which of a tile's four children exist.
   * If a child's bit is set, a tile is available for that child.  If it is cleared,
   * the tile is not available.  The bit values are as follows:
   * <table>
   *     <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
   *     <tr><td>0</td><td>1</td><td>Southwest</td></tr>
   *     <tr><td>1</td><td>2</td><td>Southeast</td></tr>
   *     <tr><td>2</td><td>4</td><td>Northwest</td></tr>
   *     <tr><td>3</td><td>8</td><td>Northeast</td></tr>
   * </table>
   * @param level - The level of the parent tile.
   * @param x - The X coordinate of the parent tile.
   * @param y - The Y coordinate of the parent tile.
   * @returns The bit mask indicating child availability.
   */
  computeChildMaskForTile(level: number, x: number, y: number): number;
}

/**
* Provides details about an error that occurred in an {@link ImageryProvider} or a {@link TerrainProvider}.
* @param provider - The imagery or terrain provider that experienced the error.
* @param message - A message describing the error.
* @param [x] - The X coordinate of the tile that experienced the error, or undefined if the error
*        is not specific to a particular tile.
* @param [y] - The Y coordinate of the tile that experienced the error, or undefined if the error
*        is not specific to a particular tile.
* @param [level] - The level of the tile that experienced the error, or undefined if the error
*        is not specific to a particular tile.
* @param [timesRetried = 0] - The number of times this operation has been retried.
* @param [error] - The error or exception that occurred, if any.
*/
export class TileProviderError {
  constructor(provider: ImageryProvider | TerrainProvider, message: string, x?: number, y?: number, level?: number, timesRetried?: number, error?: Error);
  /**
   * The {@link ImageryProvider} or {@link TerrainProvider} that experienced the error.
   */
  provider: ImageryProvider | TerrainProvider;
  /**
   * The message describing the error.
   */
  message: string;
  /**
   * The X coordinate of the tile that experienced the error.  If the error is not specific
   * to a particular tile, this property will be undefined.
   */
  x: number;
  /**
   * The Y coordinate of the tile that experienced the error.  If the error is not specific
   * to a particular tile, this property will be undefined.
   */
  y: number;
  /**
   * The level-of-detail of the tile that experienced the error.  If the error is not specific
   * to a particular tile, this property will be undefined.
   */
  level: number;
  /**
   * The number of times this operation has been retried.
   */
  timesRetried: number;
  /**
   * True if the failed operation should be retried; otherwise, false.  The imagery or terrain provider
   * will set the initial value of this property before raising the event, but any listeners
   * can change it.  The value after the last listener is invoked will be acted upon.
   */
  retry: boolean;
  /**
   * The error or exception that occurred, if any.
   */
  error: Error;
  /**
   * Handles an error in an {@link ImageryProvider} or {@link TerrainProvider} by raising an event if it has any listeners, or by
   * logging the error to the console if the event has no listeners.  This method also tracks the number
   * of times the operation has been retried and will automatically retry if requested to do so by the
   * event listeners.
   * @param previousError - The error instance returned by this function the last
   *        time it was called for this error, or undefined if this is the first time this error has
   *        occurred.
   * @param provider - The imagery or terrain provider that encountered the error.
   * @param event - The event to raise to inform listeners of the error.
   * @param message - The message describing the error.
   * @param x - The X coordinate of the tile that experienced the error, or undefined if the
   *        error is not specific to a particular tile.
   * @param y - The Y coordinate of the tile that experienced the error, or undefined if the
   *        error is not specific to a particular tile.
   * @param level - The level-of-detail of the tile that experienced the error, or undefined if the
   *        error is not specific to a particular tile.
   * @param retryFunction - The function to call to retry the operation.  If undefined, the
   *        operation will not be retried.
   * @param [errorDetails] - The error or exception that occurred, if any.
   * @returns The error instance that was passed to the event listeners and that
   *          should be passed to this function the next time it is called for the same error in order
   *          to track retry counts.
   */
  handleError(previousError: TileProviderError, provider: ImageryProvider | TerrainProvider, event: Event, message: string, x: number, y: number, level: number, retryFunction: TileProviderError.RetryFunction, errorDetails?: Error): TileProviderError;
  /**
   * Handles success of an operation by resetting the retry count of a previous error, if any.  This way,
   * if the error occurs again in the future, the listeners will be informed that it has not yet been retried.
   * @param previousError - The previous error, or undefined if this operation has
   *        not previously resulted in an error.
   */
  handleSuccess(previousError: TileProviderError): void;
}

export namespace TileProviderError {
  /**
   * A function that will be called to retry the operation.
   */
  type RetryFunction = () => void;
}

/**
* A tiling scheme for geometry or imagery on the surface of an ellipsoid.  At level-of-detail zero,
* the coarsest, least-detailed level, the number of tiles is configurable.
* At level of detail one, each of the level zero tiles has four children, two in each direction.
* At level of detail two, each of the level one tiles has four children, two in each direction.
* This continues for as many levels as are present in the geometry or imagery source.
*/
export class TilingScheme {
  constructor();
  /**
   * Gets the ellipsoid that is tiled by the tiling scheme.
   */
  ellipsoid: Ellipsoid;
  /**
   * Gets the rectangle, in radians, covered by this tiling scheme.
   */
  rectangle: Rectangle;
  /**
   * Gets the map projection used by the tiling scheme.
   */
  projection: MapProjection;
  /**
   * Gets the total number of tiles in the X direction at a specified level-of-detail.
   * @param level - The level-of-detail.
   * @returns The number of tiles in the X direction at the given level.
   */
  getNumberOfXTilesAtLevel(level: number): number;
  /**
   * Gets the total number of tiles in the Y direction at a specified level-of-detail.
   * @param level - The level-of-detail.
   * @returns The number of tiles in the Y direction at the given level.
   */
  getNumberOfYTilesAtLevel(level: number): number;
  /**
   * Transforms a rectangle specified in geodetic radians to the native coordinate system
   * of this tiling scheme.
   * @param rectangle - The rectangle to transform.
   * @param [result] - The instance to which to copy the result, or undefined if a new instance
   *        should be created.
   * @returns The specified 'result', or a new object containing the native rectangle if 'result'
   *          is undefined.
   */
  rectangleToNativeRectangle(rectangle: Rectangle, result?: Rectangle): Rectangle;
  /**
   * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates
   * of the tiling scheme.
   * @param x - The integer x coordinate of the tile.
   * @param y - The integer y coordinate of the tile.
   * @param level - The tile level-of-detail.  Zero is the least detailed.
   * @param [result] - The instance to which to copy the result, or undefined if a new instance
   *        should be created.
   * @returns The specified 'result', or a new object containing the rectangle
   *          if 'result' is undefined.
   */
  tileXYToNativeRectangle(x: number, y: number, level: number, result?: any): Rectangle;
  /**
   * Converts tile x, y coordinates and level to a cartographic rectangle in radians.
   * @param x - The integer x coordinate of the tile.
   * @param y - The integer y coordinate of the tile.
   * @param level - The tile level-of-detail.  Zero is the least detailed.
   * @param [result] - The instance to which to copy the result, or undefined if a new instance
   *        should be created.
   * @returns The specified 'result', or a new object containing the rectangle
   *          if 'result' is undefined.
   */
  tileXYToRectangle(x: number, y: number, level: number, result?: any): Rectangle;
  /**
   * Calculates the tile x, y coordinates of the tile containing
   * a given cartographic position.
   * @param position - The position.
   * @param level - The tile level-of-detail.  Zero is the least detailed.
   * @param [result] - The instance to which to copy the result, or undefined if a new instance
   *        should be created.
   * @returns The specified 'result', or a new object containing the tile x, y coordinates
   *          if 'result' is undefined.
   */
  positionToTileXY(position: Cartographic, level: number, result?: Cartesian2): Cartesian2;
}

/**
* An interval defined by a start and a stop time; optionally including those times as part of the interval.
* Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.
* @example
* // Create an instance that spans August 1st, 1980 and is associated
* // with a Cartesian position.
* const timeInterval = new SuperMap.TimeInterval({
*     start : SuperMap.JulianDate.fromIso8601('1980-08-01T00:00:00Z'),
*     stop : SuperMap.JulianDate.fromIso8601('1980-08-02T00:00:00Z'),
*     isStartIncluded : true,
*     isStopIncluded : false,
*     data : SuperMap.Cartesian3.fromDegrees(39.921037, -75.170082)
* });
* @example
* // Create two instances from ISO 8601 intervals with associated numeric data
* // then compute their intersection, summing the data they contain.
* const left = SuperMap.TimeInterval.fromIso8601({
*     iso8601 : '2000/2010',
*     data : 2
* });
*
* const right = SuperMap.TimeInterval.fromIso8601({
*     iso8601 : '1995/2005',
*     data : 3
* });
*
* //The result of the below intersection will be an interval equivalent to
* //const intersection = SuperMap.TimeInterval.fromIso8601({
* //  iso8601 : '2000/2005',
* //  data : 5
* //});
* const intersection = new SuperMap.TimeInterval();
* SuperMap.TimeInterval.intersect(left, right, intersection, function(leftData, rightData) {
*     return leftData + rightData;
* });
* @example
* // Check if an interval contains a specific time.
* const dateToCheck = SuperMap.JulianDate.fromIso8601('1982-09-08T11:30:00Z');
* const containsDate = SuperMap.TimeInterval.contains(timeInterval, dateToCheck);
* @param [options] - Object with the following properties:
* @param [options.start = new JulianDate()] - The start time of the interval.
* @param [options.stop = new JulianDate()] - The stop time of the interval.
* @param [options.isStartIncluded = true] - <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
* @param [options.isStopIncluded = true] - <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
* @param [options.data] - Arbitrary data associated with this interval.
*/
export class TimeInterval {
  constructor(options?: {
    start?: JulianDate;
    stop?: JulianDate;
    isStartIncluded?: boolean;
    isStopIncluded?: boolean;
    data?: any;
  });
  /**
   * Gets or sets the start time of this interval.
   */
  start: JulianDate;
  /**
   * Gets or sets the stop time of this interval.
   */
  stop: JulianDate;
  /**
   * Gets or sets the data associated with this interval.
   */
  data: any;
  /**
   * Gets or sets whether or not the start time is included in this interval.
   */
  isStartIncluded: boolean;
  /**
   * Gets or sets whether or not the stop time is included in this interval.
   */
  isStopIncluded: boolean;
  /**
   * Gets whether or not this interval is empty.
   */
  readonly isEmpty: boolean;
  /**
   * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} interval.
   * @param options - Object with the following properties:
   * @param options.iso8601 - An ISO 8601 interval.
   * @param [options.isStartIncluded = true] - <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
   * @param [options.isStopIncluded = true] - <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
   * @param [options.data] - Arbitrary data associated with this interval.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  fromIso8601(options: {
    iso8601: string;
    isStartIncluded?: boolean;
    isStopIncluded?: boolean;
    data?: any;
  }, result?: TimeInterval): TimeInterval;
  /**
   * Creates an ISO8601 representation of the provided interval.
   * @param timeInterval - The interval to be converted.
   * @param [precision] - The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
   * @returns The ISO8601 representation of the provided interval.
   */
  toIso8601(timeInterval: TimeInterval, precision?: number): string;
  /**
   * Duplicates the provided instance.
   * @param [timeInterval] - The instance to clone.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  clone(timeInterval?: TimeInterval, result?: TimeInterval): TimeInterval;
  /**
   * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [left] - The first instance.
   * @param [right] - The second instance.
   * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
   * @returns <code>true</code> if the dates are equal; otherwise, <code>false</code>.
   */
  equals(left?: TimeInterval, right?: TimeInterval, dataComparer?: TimeInterval.DataComparer): boolean;
  /**
   * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
   * each other.  That is, in order for the dates to be considered equal (and for
   * this function to return <code>true</code>), the absolute value of the difference between them, in
   * seconds, must be less than <code>epsilon</code>.
   * @param [left] - The first instance.
   * @param [right] - The second instance.
   * @param [epsilon = 0] - The maximum number of seconds that should separate the two instances.
   * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
   * @returns <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
   */
  equalsEpsilon(left?: TimeInterval, right?: TimeInterval, epsilon?: number, dataComparer?: TimeInterval.DataComparer): boolean;
  /**
   * Computes the intersection of two intervals, optionally merging their data.
   * @param left - The first interval.
   * @param [right] - The second interval.
   * @param [result] - An existing instance to use for the result.
   * @param [mergeCallback] - A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.
   * @returns The modified result parameter.
   */
  intersect(left: TimeInterval, right?: TimeInterval, result?: TimeInterval, mergeCallback?: TimeInterval.MergeCallback): TimeInterval;
  /**
   * Checks if the specified date is inside the provided interval.
   * @param timeInterval - The interval.
   * @param julianDate - The date to check.
   * @returns <code>true</code> if the interval contains the specified date, <code>false</code> otherwise.
   */
  contains(timeInterval: TimeInterval, julianDate: JulianDate): boolean;
  /**
   * Duplicates this instance.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  clone(result?: TimeInterval): TimeInterval;
  /**
   * Compares this instance against the provided instance componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The right hand side interval.
   * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(right?: TimeInterval, dataComparer?: TimeInterval.DataComparer): boolean;
  /**
   * Compares this instance against the provided instance componentwise and returns
   * <code>true</code> if they are within the provided epsilon,
   * <code>false</code> otherwise.
   * @param [right] - The right hand side interval.
   * @param [epsilon = 0] - The epsilon to use for equality testing.
   * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
   * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
   */
  equalsEpsilon(right?: TimeInterval, epsilon?: number, dataComparer?: TimeInterval.DataComparer): boolean;
  /**
   * Creates a string representing this TimeInterval in ISO8601 format.
   * @returns A string representing this TimeInterval in ISO8601 format.
   */
  toString(): string;
  /**
   * An immutable empty interval.
   */
  readonly EMPTY: TimeInterval;
}

export namespace TimeInterval {
  /**
   * Function interface for merging interval data.
   * @param leftData - The first data instance.
   * @param rightData - The second data instance.
   */
  type MergeCallback = (leftData: any, rightData: any) => any;
  /**
   * Function interface for comparing interval data.
   * @param leftData - The first data instance.
   * @param rightData - The second data instance.
   */
  type DataComparer = (leftData: any, rightData: any) => boolean;
}

/**
* A non-overlapping collection of {@link TimeInterval} instances sorted by start time.
* @param [intervals] - An array of intervals to add to the collection.
*/
export class TimeIntervalCollection {
  constructor(intervals?: TimeInterval[]);
  /**
   * Gets an event that is raised whenever the collection of intervals change.
   */
  readonly changedEvent: Event;
  /**
   * Gets the start time of the collection.
   */
  readonly start: JulianDate;
  /**
   * Gets whether or not the start time is included in the collection.
   */
  readonly isStartIncluded: boolean;
  /**
   * Gets the stop time of the collection.
   */
  readonly stop: JulianDate;
  /**
   * Gets whether or not the stop time is included in the collection.
   */
  readonly isStopIncluded: boolean;
  /**
   * Gets the number of intervals in the collection.
   */
  readonly length: number;
  /**
   * Gets whether or not the collection is empty.
   */
  readonly isEmpty: boolean;
  /**
   * Compares this instance against the provided instance componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The right hand side collection.
   * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(right?: TimeIntervalCollection, dataComparer?: TimeInterval.DataComparer): boolean;
  /**
   * Gets the interval at the specified index.
   * @param index - The index of the interval to retrieve.
   * @returns The interval at the specified index, or <code>undefined</code> if no interval exists as that index.
   */
  get(index: number): TimeInterval | undefined;
  /**
   * Removes all intervals from the collection.
   */
  removeAll(): void;
  /**
   * Finds and returns the interval that contains the specified date.
   * @param date - The date to search for.
   * @returns The interval containing the specified date, <code>undefined</code> if no such interval exists.
   */
  findIntervalContainingDate(date: JulianDate): TimeInterval | undefined;
  /**
   * Finds and returns the data for the interval that contains the specified date.
   * @param date - The date to search for.
   * @returns The data for the interval containing the specified date, or <code>undefined</code> if no such interval exists.
   */
  findDataForIntervalContainingDate(date: JulianDate): any;
  /**
   * Checks if the specified date is inside this collection.
   * @param julianDate - The date to check.
   * @returns <code>true</code> if the collection contains the specified date, <code>false</code> otherwise.
   */
  contains(julianDate: JulianDate): boolean;
  /**
   * Finds and returns the index of the interval in the collection that contains the specified date.
   * @param date - The date to search for.
   * @returns The index of the interval that contains the specified date, if no such interval exists,
   * it returns a negative number which is the bitwise complement of the index of the next interval that
   * starts after the date, or if no interval starts after the specified date, the bitwise complement of
   * the length of the collection.
   */
  indexOf(date: JulianDate): number;
  /**
   * Returns the first interval in the collection that matches the specified parameters.
   * All parameters are optional and <code>undefined</code> parameters are treated as a don't care condition.
   * @param [options] - Object with the following properties:
   * @param [options.start] - The start time of the interval.
   * @param [options.stop] - The stop time of the interval.
   * @param [options.isStartIncluded] - <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
   * @param [options.isStopIncluded] - <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
   * @returns The first interval in the collection that matches the specified parameters.
   */
  findInterval(options?: {
    start?: JulianDate;
    stop?: JulianDate;
    isStartIncluded?: boolean;
    isStopIncluded?: boolean;
  }): TimeInterval | undefined;
  /**
   * Adds an interval to the collection, merging intervals that contain the same data and
   * splitting intervals of different data as needed in order to maintain a non-overlapping collection.
   * The data in the new interval takes precedence over any existing intervals in the collection.
   * @param interval - The interval to add.
   * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
   */
  addInterval(interval: TimeInterval, dataComparer?: TimeInterval.DataComparer): void;
  /**
   * Removes the specified interval from this interval collection, creating a hole over the specified interval.
   * The data property of the input interval is ignored.
   * @param interval - The interval to remove.
   * @returns <code>true</code> if the interval was removed, <code>false</code> if no part of the interval was in the collection.
   */
  removeInterval(interval: TimeInterval): boolean;
  /**
   * Creates a new instance that is the intersection of this collection and the provided collection.
   * @param other - The collection to intersect with.
   * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
   * @param [mergeCallback] - A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.
   * @returns A new TimeIntervalCollection which is the intersection of this collection and the provided collection.
   */
  intersect(other: TimeIntervalCollection, dataComparer?: TimeInterval.DataComparer, mergeCallback?: TimeInterval.MergeCallback): TimeIntervalCollection;
  /**
   * Creates a new instance from a JulianDate array.
   * @param options - Object with the following properties:
   * @param options.julianDates - An array of ISO 8601 dates.
   * @param [options.isStartIncluded = true] - <code>true</code> if start time is included in the interval, <code>false</code> otherwise.
   * @param [options.isStopIncluded = true] - <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.
   * @param [options.leadingInterval = false] - <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.
   * @param [options.trailingInterval = false] - <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.
   * @param [options.dataCallback] - A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  fromJulianDateArray(options: {
    julianDates: JulianDate[];
    isStartIncluded?: boolean;
    isStopIncluded?: boolean;
    leadingInterval?: boolean;
    trailingInterval?: boolean;
    dataCallback?: (...params: any[]) => any;
  }, result?: TimeIntervalCollection): TimeIntervalCollection;
  /**
   * Creates a new instance from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} time interval (start/end/duration).
   * @param options - Object with the following properties:
   * @param options.iso8601 - An ISO 8601 interval.
   * @param [options.isStartIncluded = true] - <code>true</code> if start time is included in the interval, <code>false</code> otherwise.
   * @param [options.isStopIncluded = true] - <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.
   * @param [options.leadingInterval = false] - <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.
   * @param [options.trailingInterval = false] - <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.
   * @param [options.dataCallback] - A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  fromIso8601(options: {
    iso8601: string;
    isStartIncluded?: boolean;
    isStopIncluded?: boolean;
    leadingInterval?: boolean;
    trailingInterval?: boolean;
    dataCallback?: (...params: any[]) => any;
  }, result?: TimeIntervalCollection): TimeIntervalCollection;
  /**
   * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date array.
   * @param options - Object with the following properties:
   * @param options.iso8601Dates - An array of ISO 8601 dates.
   * @param [options.isStartIncluded = true] - <code>true</code> if start time is included in the interval, <code>false</code> otherwise.
   * @param [options.isStopIncluded = true] - <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.
   * @param [options.leadingInterval = false] - <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.
   * @param [options.trailingInterval = false] - <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.
   * @param [options.dataCallback] - A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  fromIso8601DateArray(options: {
    iso8601Dates: string[];
    isStartIncluded?: boolean;
    isStopIncluded?: boolean;
    leadingInterval?: boolean;
    trailingInterval?: boolean;
    dataCallback?: (...params: any[]) => any;
  }, result?: TimeIntervalCollection): TimeIntervalCollection;
  /**
   * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} duration array.
   * @param options - Object with the following properties:
   * @param options.epoch - An date that the durations are relative to.
   * @param options.iso8601Durations - An array of ISO 8601 durations.
   * @param [options.relativeToPrevious = false] - <code>true</code> if durations are relative to previous date, <code>false</code> if always relative to the epoch.
   * @param [options.isStartIncluded = true] - <code>true</code> if start time is included in the interval, <code>false</code> otherwise.
   * @param [options.isStopIncluded = true] - <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.
   * @param [options.leadingInterval = false] - <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.
   * @param [options.trailingInterval = false] - <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.
   * @param [options.dataCallback] - A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.
   * @param [result] - An existing instance to use for the result.
   * @returns The modified result parameter or a new instance if none was provided.
   */
  fromIso8601DurationArray(options: {
    epoch: JulianDate;
    iso8601Durations: string;
    relativeToPrevious?: boolean;
    isStartIncluded?: boolean;
    isStopIncluded?: boolean;
    leadingInterval?: boolean;
    trailingInterval?: boolean;
    dataCallback?: (...params: any[]) => any;
  }, result?: TimeIntervalCollection): TimeIntervalCollection;
}

/**
* Provides the type of time standards which JulianDate can take as input.
*/
export enum TimeStandard {
  /**
   * Represents the coordinated Universal Time (UTC) time standard.
   *
   * UTC is related to TAI according to the relationship
   * <code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap
   * seconds which have been introduced as of the time in TAI.
   */
  UTC = 0,
  /**
   * Represents the International Atomic Time (TAI) time standard.
   * TAI is the principal time standard to which the other time standards are related.
   */
  TAI = 1
}

/**
* Contains functions for transforming positions to various reference frames.
*/
export namespace Transforms {
  /**
   * Generates a function that computes a 4x4 transformation matrix from a reference frame
   * centered at the provided origin to the provided ellipsoid's fixed reference frame.
   * @param firstAxis - name of the first axis of the local reference frame. Must be
   *  'east', 'north', 'up', 'west', 'south' or 'down'.
   * @param secondAxis - name of the second axis of the local reference frame. Must be
   *  'east', 'north', 'up', 'west', 'south' or 'down'.
   * @returns The function that will computes a
   * 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters,
   */
  function localFrameToFixedFrameGenerator(firstAxis: string, secondAxis: string): Transforms.LocalFrameToFixedFrame;
  /**
   * Computes a 4x4 transformation matrix from a reference frame
   * centered at the provided origin to the provided ellipsoid's fixed reference frame.
   * @param origin - The center point of the local reference frame.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
   * @param [result] - The object onto which to store the result.
   */
  type LocalFrameToFixedFrame = (origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4) => Matrix4;
  /**
   * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes
   * centered at the provided origin to the provided ellipsoid's fixed reference frame.
   * The local axes are defined as:
   * <ul>
   * <li>The <code>x</code> axis points in the local east direction.</li>
   * <li>The <code>y</code> axis points in the local north direction.</li>
   * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
   * </ul>
   * @example
   * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.
   * const center = SuperMap.Cartesian3.fromDegrees(0.0, 0.0);
   * const transform = SuperMap.Transforms.eastNorthUpToFixedFrame(center);
   * @param origin - The center point of the local reference frame.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix4 instance if none was provided.
   */
  function eastNorthUpToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
  /**
   * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes
   * centered at the provided origin to the provided ellipsoid's fixed reference frame.
   * The local axes are defined as:
   * <ul>
   * <li>The <code>x</code> axis points in the local north direction.</li>
   * <li>The <code>y</code> axis points in the local east direction.</li>
   * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>
   * </ul>
   * @example
   * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.
   * const center = SuperMap.Cartesian3.fromDegrees(0.0, 0.0);
   * const transform = SuperMap.Transforms.northEastDownToFixedFrame(center);
   * @param origin - The center point of the local reference frame.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix4 instance if none was provided.
   */
  function northEastDownToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
  /**
   * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes
   * centered at the provided origin to the provided ellipsoid's fixed reference frame.
   * The local axes are defined as:
   * <ul>
   * <li>The <code>x</code> axis points in the local north direction.</li>
   * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
   * <li>The <code>z</code> axis points in the local east direction.</li>
   * </ul>
   * @example
   * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.
   * const center = SuperMap.Cartesian3.fromDegrees(0.0, 0.0);
   * const transform = SuperMap.Transforms.northUpEastToFixedFrame(center);
   * @param origin - The center point of the local reference frame.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix4 instance if none was provided.
   */
  function northUpEastToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
  /**
   * Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes
   * centered at the provided origin to the provided ellipsoid's fixed reference frame.
   * The local axes are defined as:
   * <ul>
   * <li>The <code>x</code> axis points in the local north direction.</li>
   * <li>The <code>y</code> axis points in the local west direction.</li>
   * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
   * </ul>
   * @example
   * // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth's fixed frame.
   * const center = SuperMap.Cartesian3.fromDegrees(0.0, 0.0);
   * const transform = SuperMap.Transforms.northWestUpToFixedFrame(center);
   * @param origin - The center point of the local reference frame.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix4 instance if none was provided.
   */
  function northWestUpToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
  /**
   * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles
   * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local north
   * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
   * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
   * @example
   * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
   * const center = SuperMap.Cartesian3.fromDegrees(0.0, 0.0);
   * const heading = -SuperMap.Math.PI_OVER_TWO;
   * const pitch = SuperMap.Math.PI_OVER_FOUR;
   * const roll = 0.0;
   * const hpr = new SuperMap.HeadingPitchRoll(heading, pitch, roll);
   * const transform = SuperMap.Transforms.headingPitchRollToFixedFrame(center, hpr);
   * @param origin - The center point of the local reference frame.
   * @param headingPitchRoll - The heading, pitch, and roll.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
   * @param [fixedFrameTransform = Transforms.eastNorthUpToFixedFrame] - A 4x4 transformation
   *  matrix from a reference frame to the provided ellipsoid's fixed reference frame
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix4 instance if none was provided.
   */
  function headingPitchRollToFixedFrame(origin: Cartesian3, headingPitchRoll: HeadingPitchRoll, ellipsoid?: Ellipsoid, fixedFrameTransform?: Transforms.LocalFrameToFixedFrame, result?: Matrix4): Matrix4;
  /**
   * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles
   * centered at the provided origin. Heading is the rotation from the local north
   * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
   * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
   * @example
   * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
   * const center = SuperMap.Cartesian3.fromDegrees(0.0, 0.0);
   * const heading = -SuperMap.Math.PI_OVER_TWO;
   * const pitch = SuperMap.Math.PI_OVER_FOUR;
   * const roll = 0.0;
   * const hpr = new HeadingPitchRoll(heading, pitch, roll);
   * const quaternion = SuperMap.Transforms.headingPitchRollQuaternion(center, hpr);
   * @param origin - The center point of the local reference frame.
   * @param headingPitchRoll - The heading, pitch, and roll.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
   * @param [fixedFrameTransform = Transforms.eastNorthUpToFixedFrame] - A 4x4 transformation
   *  matrix from a reference frame to the provided ellipsoid's fixed reference frame
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Quaternion instance if none was provided.
   */
  function headingPitchRollQuaternion(origin: Cartesian3, headingPitchRoll: HeadingPitchRoll, ellipsoid?: Ellipsoid, fixedFrameTransform?: Transforms.LocalFrameToFixedFrame, result?: Quaternion): Quaternion;
  /**
   * Computes heading-pitch-roll angles from a transform in a particular reference frame. Heading is the rotation from the local north
   * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
   * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
   * @param transform - The transform
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
   * @param [fixedFrameTransform = Transforms.eastNorthUpToFixedFrame] - A 4x4 transformation
   *  matrix from a reference frame to the provided ellipsoid's fixed reference frame
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new HeadingPitchRoll instance if none was provided.
   */
  function fixedFrameToHeadingPitchRoll(transform: Matrix4, ellipsoid?: Ellipsoid, fixedFrameTransform?: Transforms.LocalFrameToFixedFrame, result?: HeadingPitchRoll): HeadingPitchRoll;
  /**
   * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the
   * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.
   * @example
   * //Set the view to the inertial frame.
   * scene.postUpdate.addEventListener(function(scene, time) {
   *    const now = SuperMap.JulianDate.now();
   *    const offset = SuperMap.Matrix4.multiplyByPoint(camera.transform, camera.position, new SuperMap.Cartesian3());
   *    const transform = SuperMap.Matrix4.fromRotationTranslation(SuperMap.Transforms.computeTemeToPseudoFixedMatrix(now));
   *    const inverseTransform = SuperMap.Matrix4.inverseTransformation(transform, new SuperMap.Matrix4());
   *    SuperMap.Matrix4.multiplyByPoint(inverseTransform, offset, offset);
   *    camera.lookAtTransform(transform, offset);
   * });
   * @param date - The time at which to compute the rotation matrix.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix3 instance if none was provided.
   */
  function computeTemeToPseudoFixedMatrix(date: JulianDate, result?: Matrix3): Matrix3;
  /**
   * Preloads the data necessary to transform between the ICRF and Fixed axes, in either
   * direction, over a given interval.  This function returns a promise that, when resolved,
   * indicates that the preload has completed.
   * @example
   * const interval = new SuperMap.TimeInterval(...);
   * Promise.resolve(SuperMap.Transforms.preloadIcrfFixed(interval)).then(function() {
   *     // the data is now loaded
   * });
   * @param timeInterval - The interval to preload.
   * @returns A promise that, when resolved, indicates that the preload has completed
   *          and evaluation of the transformation between the fixed and ICRF axes will
   *          no longer return undefined for a time inside the interval.
   */
  function preloadIcrfFixed(timeInterval: TimeInterval): Promise<void>;
  /**
   * Computes a rotation matrix to transform a point or vector from the International Celestial
   * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)
   * at a given time.  This function may return undefined if the data necessary to
   * do the transformation is not yet loaded.
   * @example
   * scene.postUpdate.addEventListener(function(scene, time) {
   *   // View in ICRF.
   *   const icrfToFixed = SuperMap.Transforms.computeIcrfToFixedMatrix(time);
   *   if (SuperMap.defined(icrfToFixed)) {
   *     const offset = SuperMap.Cartesian3.clone(camera.position);
   *     const transform = SuperMap.Matrix4.fromRotationTranslation(icrfToFixed);
   *     camera.lookAtTransform(transform, offset);
   *   }
   * });
   * @param date - The time at which to compute the rotation matrix.
   * @param [result] - The object onto which to store the result.  If this parameter is
   *                  not specified, a new instance is created and returned.
   * @returns The rotation matrix, or undefined if the data necessary to do the
   *                   transformation is not yet loaded.
   */
  function computeIcrfToFixedMatrix(date: JulianDate, result?: Matrix3): Matrix3;
  /**
   * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)
   * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes
   * at a given time.  This function may return undefined if the data necessary to
   * do the transformation is not yet loaded.
   * @example
   * // Transform a point from the ICRF axes to the Fixed axes.
   * const now = SuperMap.JulianDate.now();
   * const pointInFixed = SuperMap.Cartesian3.fromDegrees(0.0, 0.0);
   * const fixedToIcrf = SuperMap.Transforms.computeIcrfToFixedMatrix(now);
   * let pointInInertial = new SuperMap.Cartesian3();
   * if (SuperMap.defined(fixedToIcrf)) {
   *     pointInInertial = SuperMap.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);
   * }
   * @param date - The time at which to compute the rotation matrix.
   * @param [result] - The object onto which to store the result.  If this parameter is
   *                  not specified, a new instance is created and returned.
   * @returns The rotation matrix, or undefined if the data necessary to do the
   *                   transformation is not yet loaded.
   */
  function computeFixedToIcrfMatrix(date: JulianDate, result?: Matrix3): Matrix3;
  /**
   * Transform a point from model coordinates to window coordinates.
   * @param modelViewProjectionMatrix - The 4x4 model-view-projection matrix.
   * @param viewportTransformation - The 4x4 viewport transformation.
   * @param point - The point to transform.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Cartesian2 instance if none was provided.
   */
  function pointToWindowCoordinates(modelViewProjectionMatrix: Matrix4, viewportTransformation: Matrix4, point: Cartesian3, result?: Cartesian2): Cartesian2;
  /**
   * Transform a position and velocity to a rotation matrix.
   * @param position - The position to transform.
   * @param velocity - The velocity vector to transform.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new Matrix3 instance if none was provided.
   */
  function rotationMatrixFromPositionVelocity(position: Cartesian3, velocity: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix3): Matrix3;
}

/**
* An affine transformation defined by a translation, rotation, and scale.
* @param [translation = Cartesian3.ZERO] - A {@link Cartesian3} specifying the (x, y, z) translation to apply to the node.
* @param [rotation = Quaternion.IDENTITY] - A {@link Quaternion} specifying the (x, y, z, w) rotation to apply to the node.
* @param [scale = new Cartesian3(1.0, 1.0, 1.0)] - A {@link Cartesian3} specifying the (x, y, z) scaling to apply to the node.
*/
export class TranslationRotationScale {
  constructor(translation?: Cartesian3, rotation?: Quaternion, scale?: Cartesian3);
  /**
   * Gets or sets the (x, y, z) translation to apply to the node.
   */
  translation: Cartesian3;
  /**
   * Gets or sets the (x, y, z, w) rotation to apply to the node.
   */
  rotation: Quaternion;
  /**
   * Gets or sets the (x, y, z) scaling to apply to the node.
   */
  scale: Cartesian3;
  /**
   * Compares this instance against the provided instance and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [right] - The right hand side TranslationRotationScale.
   * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
   */
  equals(right?: TranslationRotationScale): boolean;
}

/**
 * Uses the Tridiagonal Matrix Algorithm, also known as the Thomas Algorithm, to solve
 * a system of linear equations where the coefficient matrix is a tridiagonal matrix.
 */
export namespace TridiagonalSystemSolver {
  /**
   * Solves a tridiagonal system of linear equations.
   * @example
   * const lowerDiagonal = [1.0, 1.0, 1.0, 1.0];
   * const diagonal = [2.0, 4.0, 4.0, 4.0, 2.0];
   * const upperDiagonal = [1.0, 1.0, 1.0, 1.0];
   * const rightHandSide = [
   *     new SuperMap.Cartesian3(410757.0, -1595711.0, 1375302.0),
   *     new SuperMap.Cartesian3(-5986705.0, -2190640.0, 1099600.0),
   *     new SuperMap.Cartesian3(-12593180.0, 288588.0, -1755549.0),
   *     new SuperMap.Cartesian3(-5349898.0, 2457005.0, -2685438.0),
   *     new SuperMap.Cartesian3(845820.0, 1573488.0, -1205591.0)
   * ];
   *
   * const solution = SuperMap.TridiagonalSystemSolver.solve(lowerDiagonal, diagonal, upperDiagonal, rightHandSide);
   * @param diagonal - An array with length <code>n</code> that contains the diagonal of the coefficient matrix.
   * @param lower - An array with length <code>n - 1</code> that contains the lower diagonal of the coefficient matrix.
   * @param upper - An array with length <code>n - 1</code> that contains the upper diagonal of the coefficient matrix.
   * @param right - An array of Cartesians with length <code>n</code> that is the right side of the system of equations.
   * @returns An array of Cartesians with length <code>n</code> that is the solution to the tridiagonal system of equations.
   */
  function solve(diagonal: number[], lower: number[], upper: number[], right: Cartesian3[]): Cartesian3[];
}

/**
* A singleton that contains all of the servers that are trusted. Credentials will be sent with
* any requests to these servers.
*/
export namespace TrustedServers {
  /**
   * Adds a trusted server to the registry
   * @example
   * // Add a trusted server
   * TrustedServers.add('my.server.com', 80);
   * @param host - The host to be added.
   * @param port - The port used to access the host.
   */
  function add(host: string, port: number): void;
  /**
   * Removes a trusted server from the registry
   * @example
   * // Remove a trusted server
   * TrustedServers.remove('my.server.com', 80);
   * @param host - The host to be removed.
   * @param port - The port used to access the host.
   */
  function remove(host: string, port: number): void;
  /**
   * Tests whether a server is trusted or not. The server must have been added with the port if it is included in the url.
   * @example
   * // Add server
   * TrustedServers.add('my.server.com', 81);
   *
   * // Check if server is trusted
   * if (TrustedServers.contains('https://my.server.com:81/path/to/file.png')) {
   *     // my.server.com:81 is trusted
   * }
   * if (TrustedServers.contains('https://my.server.com/path/to/file.png')) {
   *     // my.server.com isn't trusted
   * }
   * @param url - The url to be tested against the trusted list
   * @returns Returns true if url is trusted, false otherwise.
   */
  function contains(url: string): boolean;
  /**
   * Clears the registry
   * @example
   * // Remove a trusted server
   * TrustedServers.clear();
   */
  function clear(): void;
}

/**
 * A vertex format defines what attributes make up a vertex.  A VertexFormat can be provided
 * to a {@link Geometry} to request that certain properties be computed, e.g., just position,
 * position and normal, etc.
 * @example
 * // Create a vertex format with position and 2D texture coordinate attributes.
 * const format = new SuperMap.VertexFormat({
 *   position : true,
 *   st : true
 * });
 * @param [options] - An object with boolean properties corresponding to VertexFormat properties as shown in the code example.
 */
export class VertexFormat {
  constructor(options?: any);
  /**
   * When <code>true</code>, the vertex has a 3D position attribute.
   * <p>
   * 64-bit floating-point (for precision).  3 components per attribute.
   * </p>
   */
  position: boolean;
  /**
   * When <code>true</code>, the vertex has a normal attribute (normalized), which is commonly used for lighting.
   * <p>
   * 32-bit floating-point.  3 components per attribute.
   * </p>
   */
  normal: boolean;
  /**
   * When <code>true</code>, the vertex has a 2D texture coordinate attribute.
   * <p>
   * 32-bit floating-point.  2 components per attribute
   * </p>
   */
  st: boolean;
  /**
   * When <code>true</code>, the vertex has a bitangent attribute (normalized), which is used for tangent-space effects like bump mapping.
   * <p>
   * 32-bit floating-point.  3 components per attribute.
   * </p>
   */
  bitangent: boolean;
  /**
   * When <code>true</code>, the vertex has a tangent attribute (normalized), which is used for tangent-space effects like bump mapping.
   * <p>
   * 32-bit floating-point.  3 components per attribute.
   * </p>
   */
  tangent: boolean;
  /**
   * When <code>true</code>, the vertex has an RGB color attribute.
   * <p>
   * 8-bit unsigned byte.  3 components per attribute.
   * </p>
   */
  color: boolean;
  /**
   * An immutable vertex format with only a position attribute.
   */
  readonly POSITION_ONLY: VertexFormat;
  /**
   * An immutable vertex format with position and normal attributes.
   * This is compatible with per-instance color appearances like {@link PerInstanceColorAppearance}.
   */
  readonly POSITION_AND_NORMAL: VertexFormat;
  /**
   * An immutable vertex format with position, normal, and st attributes.
   * This is compatible with {@link MaterialAppearance} when {@link MaterialAppearance#materialSupport}
   * is <code>TEXTURED/code>.
   */
  readonly POSITION_NORMAL_AND_ST: VertexFormat;
  /**
   * An immutable vertex format with position and st attributes.
   * This is compatible with {@link EllipsoidSurfaceAppearance}.
   */
  readonly POSITION_AND_ST: VertexFormat;
  /**
   * An immutable vertex format with position and color attributes.
   */
  readonly POSITION_AND_COLOR: VertexFormat;
  /**
   * An immutable vertex format with well-known attributes: position, normal, st, tangent, and bitangent.
   */
  readonly ALL: VertexFormat;
  /**
   * An immutable vertex format with position, normal, and st attributes.
   * This is compatible with most appearances and materials; however
   * normal and st attributes are not always required.  When this is
   * known in advance, another <code>VertexFormat</code> should be used.
   */
  readonly DEFAULT: VertexFormat;
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: VertexFormat, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new VertexFormat instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: VertexFormat): VertexFormat;
  /**
   * Duplicates a VertexFormat instance.
   * @param vertexFormat - The vertex format to duplicate.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new VertexFormat instance if one was not provided. (Returns undefined if vertexFormat is undefined)
   */
  clone(vertexFormat: VertexFormat, result?: VertexFormat): VertexFormat;
}

/**
* Synchronizes a video element with a simulation clock.
* @param [options] - Object with the following properties:
* @param [options.clock] - The clock instance used to drive the video.
* @param [options.element] - The video element to be synchronized.
* @param [options.epoch = Iso8601.MINIMUM_VALUE] - The simulation time that marks the start of the video.
* @param [options.tolerance = 1.0] - The maximum amount of time, in seconds, that the clock and video can diverge.
*/
export class VideoSynchronizer {
  constructor(options?: {
    clock?: Clock;
    element?: HTMLVideoElement;
    epoch?: JulianDate;
    tolerance?: number;
  });
  /**
   * Gets or sets the simulation time that marks the start of the video.
   */
  epoch: JulianDate;
  /**
   * Gets or sets the amount of time in seconds the video's currentTime
   * and the clock's currentTime can diverge before a video seek is performed.
   * Lower values make the synchronization more accurate but video
   * performance might suffer.  Higher values provide better performance
   * but at the cost of accuracy.
   */
  tolerance: number;
  /**
   * Gets or sets the clock used to drive the video element.
   */
  clock: Clock;
  /**
   * Gets or sets the video element to synchronize.
   */
  element: HTMLVideoElement;
  /**
   * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
   */
  destroy(): void;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
}

/**
* This enumerated type is used in determining to what extent an object, the occludee,
* is visible during horizon culling. An occluder may fully block an occludee, in which case
* it has no visibility, may partially block an occludee from view, or may not block it at all,
* leading to full visibility.
*/
export enum Visibility {
  /**
   * Represents that no part of an object is visible.
   */
  NONE = -1,
  /**
   * Represents that part, but not all, of an object is visible
   */
  PARTIAL = 0,
  /**
   * Represents that an object is visible in its entirety.
   */
  FULL = 1
}

/**
* A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,
* which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
* @example
* // create a wall that spans from ground level to 10000 meters
* const wall = new SuperMap.WallGeometry({
*   positions : SuperMap.Cartesian3.fromDegreesArrayHeights([
*     19.0, 47.0, 10000.0,
*     19.0, 48.0, 10000.0,
*     20.0, 48.0, 10000.0,
*     20.0, 47.0, 10000.0,
*     19.0, 47.0, 10000.0
*   ])
* });
* const geometry = SuperMap.WallGeometry.createGeometry(wall);
* @param options - Object with the following properties:
* @param options.positions - An array of Cartesian objects, which are the points of the wall.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
* @param [options.maximumHeights] - An array parallel to <code>positions</code> that give the maximum height of the
*        wall at <code>positions</code>. If undefined, the height of each position in used.
* @param [options.minimumHeights] - An array parallel to <code>positions</code> that give the minimum height of the
*        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid for coordinate manipulation
* @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
*/
export class WallGeometry {
  constructor(options: {
    positions: Cartesian3[];
    granularity?: number;
    maximumHeights?: number[];
    minimumHeights?: number[];
    ellipsoid?: Ellipsoid;
    vertexFormat?: VertexFormat;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: WallGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new WallGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: WallGeometry): WallGeometry;
  /**
   * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,
   * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
   * @example
   * // create a wall that spans from 10000 meters to 20000 meters
   * const wall = SuperMap.WallGeometry.fromConstantHeights({
   *   positions : SuperMap.Cartesian3.fromDegreesArray([
   *     19.0, 47.0,
   *     19.0, 48.0,
   *     20.0, 48.0,
   *     20.0, 47.0,
   *     19.0, 47.0,
   *   ]),
   *   minimumHeight : 20000.0,
   *   maximumHeight : 10000.0
   * });
   * const geometry = SuperMap.WallGeometry.createGeometry(wall);
   * @param options - Object with the following properties:
   * @param options.positions - An array of Cartesian objects, which are the points of the wall.
   * @param [options.maximumHeight] - A constant that defines the maximum height of the
   *        wall at <code>positions</code>. If undefined, the height of each position in used.
   * @param [options.minimumHeight] - A constant that defines the minimum height of the
   *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
   * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid for coordinate manipulation
   * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
   */
  fromConstantHeights(options: {
    positions: Cartesian3[];
    maximumHeight?: number;
    minimumHeight?: number;
    ellipsoid?: Ellipsoid;
    vertexFormat?: VertexFormat;
  }): WallGeometry;
  /**
   * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.
   * @param wallGeometry - A description of the wall.
   * @returns The computed vertices and indices.
   */
  createGeometry(wallGeometry: WallGeometry): Geometry | undefined;
}

/**
* A description of a wall outline. A wall is defined by a series of points,
* which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
* @example
* // create a wall outline that spans from ground level to 10000 meters
* const wall = new SuperMap.WallOutlineGeometry({
*   positions : SuperMap.Cartesian3.fromDegreesArrayHeights([
*     19.0, 47.0, 10000.0,
*     19.0, 48.0, 10000.0,
*     20.0, 48.0, 10000.0,
*     20.0, 47.0, 10000.0,
*     19.0, 47.0, 10000.0
*   ])
* });
* const geometry = SuperMap.WallOutlineGeometry.createGeometry(wall);
* @param options - Object with the following properties:
* @param options.positions - An array of Cartesian objects, which are the points of the wall.
* @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
* @param [options.maximumHeights] - An array parallel to <code>positions</code> that give the maximum height of the
*        wall at <code>positions</code>. If undefined, the height of each position in used.
* @param [options.minimumHeights] - An array parallel to <code>positions</code> that give the minimum height of the
*        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid for coordinate manipulation
*/
export class WallOutlineGeometry {
  constructor(options: {
    positions: Cartesian3[];
    granularity?: number;
    maximumHeights?: number[];
    minimumHeights?: number[];
    ellipsoid?: Ellipsoid;
  });
  /**
   * The number of elements used to pack the object into an array.
   */
  packedLength: number;
  /**
   * Stores the provided instance into the provided array.
   * @param value - The value to pack.
   * @param array - The array to pack into.
   * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
   * @returns The array that was packed into
   */
  pack(value: WallOutlineGeometry, array: number[], startingIndex?: number): number[];
  /**
   * Retrieves an instance from a packed array.
   * @param array - The packed array.
   * @param [startingIndex = 0] - The starting index of the element to be unpacked.
   * @param [result] - The object into which to store the result.
   * @returns The modified result parameter or a new WallOutlineGeometry instance if one was not provided.
   */
  unpack(array: number[], startingIndex?: number, result?: WallOutlineGeometry): WallOutlineGeometry;
  /**
   * A description of a walloutline. A wall is defined by a series of points,
   * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
   * @example
   * // create a wall that spans from 10000 meters to 20000 meters
   * const wall = SuperMap.WallOutlineGeometry.fromConstantHeights({
   *   positions : SuperMap.Cartesian3.fromDegreesArray([
   *     19.0, 47.0,
   *     19.0, 48.0,
   *     20.0, 48.0,
   *     20.0, 47.0,
   *     19.0, 47.0,
   *   ]),
   *   minimumHeight : 20000.0,
   *   maximumHeight : 10000.0
   * });
   * const geometry = SuperMap.WallOutlineGeometry.createGeometry(wall);
   * @param options - Object with the following properties:
   * @param options.positions - An array of Cartesian objects, which are the points of the wall.
   * @param [options.maximumHeight] - A constant that defines the maximum height of the
   *        wall at <code>positions</code>. If undefined, the height of each position in used.
   * @param [options.minimumHeight] - A constant that defines the minimum height of the
   *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
   * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid for coordinate manipulation
   */
  fromConstantHeights(options: {
    positions: Cartesian3[];
    maximumHeight?: number;
    minimumHeight?: number;
    ellipsoid?: Ellipsoid;
  }): WallOutlineGeometry;
  /**
   * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.
   * @param wallGeometry - A description of the wall outline.
   * @returns The computed vertices and indices.
   */
  createGeometry(wallGeometry: WallOutlineGeometry): Geometry | undefined;
}

/**
* The map projection used by Google Maps, Bing Maps, and most of ArcGIS Online, EPSG:3857.  This
* projection use longitude and latitude expressed with the WGS84 and transforms them to Mercator using
* the spherical (rather than ellipsoidal) equations.
* @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid.
*/
export class WebMercatorProjection {
  constructor(ellipsoid?: Ellipsoid);
  /**
   * Gets the {@link Ellipsoid}.
   */
  readonly ellipsoid: Ellipsoid;
  /**
   * Converts a Mercator angle, in the range -PI to PI, to a geodetic latitude
   * in the range -PI/2 to PI/2.
   * @param mercatorAngle - The angle to convert.
   * @returns The geodetic latitude in radians.
   */
  mercatorAngleToGeodeticLatitude(mercatorAngle: number): number;
  /**
   * Converts a geodetic latitude in radians, in the range -PI/2 to PI/2, to a Mercator
   * angle in the range -PI to PI.
   * @param latitude - The geodetic latitude in radians.
   * @returns The Mercator angle.
   */
  geodeticLatitudeToMercatorAngle(latitude: number): number;
  /**
   * The maximum latitude (both North and South) supported by a Web Mercator
   * (EPSG:3857) projection.  Technically, the Mercator projection is defined
   * for any latitude up to (but not including) 90 degrees, but it makes sense
   * to cut it off sooner because it grows exponentially with increasing latitude.
   * The logic behind this particular cutoff value, which is the one used by
   * Google Maps, Bing Maps, and Esri, is that it makes the projection
   * square.  That is, the rectangle is equal in the X and Y directions.
   *
   * The constant value is computed by calling:
   *    WebMercatorProjection.mercatorAngleToGeodeticLatitude(Math.PI)
   */
  MaximumLatitude: number;
  /**
   * Converts geodetic ellipsoid coordinates, in radians, to the equivalent Web Mercator
   * X, Y, Z coordinates expressed in meters and returned in a {@link Cartesian3}.  The height
   * is copied unmodified to the Z coordinate.
   * @param cartographic - The cartographic coordinates in radians.
   * @param [result] - The instance to which to copy the result, or undefined if a
   *        new instance should be created.
   * @returns The equivalent web mercator X, Y, Z coordinates, in meters.
   */
  project(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
  /**
   * Converts Web Mercator X, Y coordinates, expressed in meters, to a {@link Cartographic}
   * containing geodetic ellipsoid coordinates.  The Z coordinate is copied unmodified to the
   * height.
   * @param cartesian - The web mercator Cartesian position to unrproject with height (z) in meters.
   * @param [result] - The instance to which to copy the result, or undefined if a
   *        new instance should be created.
   * @returns The equivalent cartographic coordinates.
   */
  unproject(cartesian: Cartesian3, result?: Cartographic): Cartographic;
}

/**
* A tiling scheme for geometry referenced to a {@link WebMercatorProjection}, EPSG:3857.  This is
* the tiling scheme used by Google Maps, Microsoft Bing Maps, and most of ESRI ArcGIS Online.
* @param [options] - Object with the following properties:
* @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose surface is being tiled. Defaults to
* the WGS84 ellipsoid.
* @param [options.numberOfLevelZeroTilesX = 1] - The number of tiles in the X direction at level zero of
*        the tile tree.
* @param [options.numberOfLevelZeroTilesY = 1] - The number of tiles in the Y direction at level zero of
*        the tile tree.
* @param [options.rectangleSouthwestInMeters] - The southwest corner of the rectangle covered by the
*        tiling scheme, in meters.  If this parameter or rectangleNortheastInMeters is not specified, the entire
*        globe is covered in the longitude direction and an equal distance is covered in the latitude
*        direction, resulting in a square projection.
* @param [options.rectangleNortheastInMeters] - The northeast corner of the rectangle covered by the
*        tiling scheme, in meters.  If this parameter or rectangleSouthwestInMeters is not specified, the entire
*        globe is covered in the longitude direction and an equal distance is covered in the latitude
*        direction, resulting in a square projection.
*/
export class WebMercatorTilingScheme {
  constructor(options?: {
    ellipsoid?: Ellipsoid;
    numberOfLevelZeroTilesX?: number;
    numberOfLevelZeroTilesY?: number;
    rectangleSouthwestInMeters?: Cartesian2;
    rectangleNortheastInMeters?: Cartesian2;
  });
  /**
   * Gets the ellipsoid that is tiled by this tiling scheme.
   */
  ellipsoid: Ellipsoid;
  /**
   * Gets the rectangle, in radians, covered by this tiling scheme.
   */
  rectangle: Rectangle;
  /**
   * Gets the map projection used by this tiling scheme.
   */
  projection: MapProjection;
  /**
   * Gets the total number of tiles in the X direction at a specified level-of-detail.
   * @param level - The level-of-detail.
   * @returns The number of tiles in the X direction at the given level.
   */
  getNumberOfXTilesAtLevel(level: number): number;
  /**
   * Gets the total number of tiles in the Y direction at a specified level-of-detail.
   * @param level - The level-of-detail.
   * @returns The number of tiles in the Y direction at the given level.
   */
  getNumberOfYTilesAtLevel(level: number): number;
  /**
   * Transforms a rectangle specified in geodetic radians to the native coordinate system
   * of this tiling scheme.
   * @param rectangle - The rectangle to transform.
   * @param [result] - The instance to which to copy the result, or undefined if a new instance
   *        should be created.
   * @returns The specified 'result', or a new object containing the native rectangle if 'result'
   *          is undefined.
   */
  rectangleToNativeRectangle(rectangle: Rectangle, result?: Rectangle): Rectangle;
  /**
   * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates
   * of the tiling scheme.
   * @param x - The integer x coordinate of the tile.
   * @param y - The integer y coordinate of the tile.
   * @param level - The tile level-of-detail.  Zero is the least detailed.
   * @param [result] - The instance to which to copy the result, or undefined if a new instance
   *        should be created.
   * @returns The specified 'result', or a new object containing the rectangle
   *          if 'result' is undefined.
   */
  tileXYToNativeRectangle(x: number, y: number, level: number, result?: any): Rectangle;
  /**
   * Converts tile x, y coordinates and level to a cartographic rectangle in radians.
   * @param x - The integer x coordinate of the tile.
   * @param y - The integer y coordinate of the tile.
   * @param level - The tile level-of-detail.  Zero is the least detailed.
   * @param [result] - The instance to which to copy the result, or undefined if a new instance
   *        should be created.
   * @returns The specified 'result', or a new object containing the rectangle
   *          if 'result' is undefined.
   */
  tileXYToRectangle(x: number, y: number, level: number, result?: any): Rectangle;
  /**
   * Calculates the tile x, y coordinates of the tile containing
   * a given cartographic position.
   * @param position - The position.
   * @param level - The tile level-of-detail.  Zero is the least detailed.
   * @param [result] - The instance to which to copy the result, or undefined if a new instance
   *        should be created.
   * @returns The specified 'result', or a new object containing the tile x, y coordinates
   *          if 'result' is undefined.
   */
  positionToTileXY(position: Cartographic, level: number, result?: Cartesian2): Cartesian2;
}

/**
* Winding order defines the order of vertices for a triangle to be considered front-facing.
*/
export enum WindingOrder {
  /**
   * Vertices are in clockwise order.
   */
  CLOCKWISE = WebGLConstants.CW,
  /**
   * Vertices are in counter-clockwise order.
   */
  COUNTER_CLOCKWISE = WebGLConstants.CCW
}

/**
* Computes the barycentric coordinates for a point with respect to a triangle.
* @example
* // Returns Cartesian3.UNIT_X
* const p = new SuperMap.Cartesian3(-1.0, 0.0, 0.0);
* const b = SuperMap.barycentricCoordinates(p,
*   new SuperMap.Cartesian3(-1.0, 0.0, 0.0),
*   new SuperMap.Cartesian3( 1.0, 0.0, 0.0),
*   new SuperMap.Cartesian3( 0.0, 1.0, 1.0));
* @param point - The point to test.
* @param p0 - The first point of the triangle, corresponding to the barycentric x-axis.
* @param p1 - The second point of the triangle, corresponding to the barycentric y-axis.
* @param p2 - The third point of the triangle, corresponding to the barycentric z-axis.
* @param [result] - The object onto which to store the result.
* @returns The modified result parameter or a new Cartesian3 instance if one was not provided. If the triangle is degenerate the function will return undefined.
*/
export function barycentricCoordinates(point: Cartesian2 | Cartesian3, p0: Cartesian2 | Cartesian3, p1: Cartesian2 | Cartesian3, p2: Cartesian2 | Cartesian3, result?: Cartesian3): Cartesian3 | undefined;

/**
* Finds an item in a sorted array.
* @example
* // Create a comparator function to search through an array of numbers.
* function comparator(a, b) {
*     return a - b;
* };
* const numbers = [0, 2, 4, 6, 8];
* const index = SuperMap.binarySearch(numbers, 6, comparator); // 3
* @param array - The sorted array to search.
* @param itemToFind - The item to find in the array.
* @param comparator - The function to use to compare the item to
*        elements in the array.
* @returns The index of <code>itemToFind</code> in the array, if it exists.  If <code>itemToFind</code>
*        does not exist, the return value is a negative number which is the bitwise complement (~)
*        of the index before which the itemToFind should be inserted in order to maintain the
*        sorted order of the array.
*/
export function binarySearch(array: any[], itemToFind: any, comparator: binarySearchComparator): number;

/**
* A function used to compare two items while performing a binary search.
* @example
* function compareNumbers(a, b) {
*     return a - b;
* }
* @param a - An item in the array.
* @param b - The item being searched for.
*/
export type binarySearchComparator = (a: any, b: any) => number;

/**
* Given a relative URL under the SuperMap base URL, returns an absolute URL.
* @example
* const viewer = new SuperMap.Viewer("CesiumContainer", {
*   imageryProvider: new SuperMap.TileMapServiceImageryProvider({
*   url: SuperMap.buildModuleUrl("Assets/Textures/NaturalEarthII"),
*   }),
*   baseLayerPicker: false,
* });
* @param relativeUrl - The relative path.
* @returns The absolutely URL representation of the provided path.
*/
export function buildModuleUrl(relativeUrl: string): string;

/**
* A browser-independent function to cancel an animation frame requested using {@link requestAnimationFrame}.
* @param requestID - The value returned by {@link requestAnimationFrame}.
*/
export function cancelAnimationFrame(requestID: number): void;

/**
* Clones an object, returning a new object containing the same properties.
* @param object - The object to clone.
* @param [deep = false] - If true, all properties will be deep cloned recursively.
* @returns The cloned object.
*/
export function clone(object: any, deep?: boolean): any;

/**
* Merges two objects, copying their properties onto a new combined object. When two objects have the same
* property, the value of the property on the first object is used.  If either object is undefined,
* it will be treated as an empty object.
* @example
* const object1 = {
*     propOne : 1,
*     propTwo : {
*         value1 : 10
*     }
* }
* const object2 = {
*     propTwo : 2
* }
* const final = SuperMap.combine(object1, object2);
*
* // final === {
* //     propOne : 1,
* //     propTwo : {
* //         value1 : 10
* //     }
* // }
* @param [object1] - The first object to merge.
* @param [object2] - The second object to merge.
* @param [deep = false] - Perform a recursive merge.
* @returns The combined object containing all properties from both objects.
*/
export function combine(object1?: any, object2?: any, deep?: boolean): any;

/**
* Creates a Globally unique identifier (GUID) string.  A GUID is 128 bits long, and can guarantee uniqueness across space and time.
* @example
* this.guid = SuperMap.createGuid();
*/
export function createGuid(): string;

/**
 * Returns the first parameter if not undefined, otherwise the second parameter.
 * Useful for setting a default value for a parameter.
 * @example
 * param = SuperMap.defaultValue(param, 'default');
 * @returns Returns the first parameter if not undefined, otherwise the second parameter.
 */
export function defaultValue(a: any, b: any): any;

/**
 * @example
 * if (SuperMap.defined(positions)) {
 *      doSomething();
 * } else {
 *      doSomethingElse();
 * }
 * @param value - The object.
 * @returns Returns true if the object is defined, returns false otherwise.
 */
export function defined(value: any): boolean;

/**
 * Destroys an object.  Each of the object's functions, including functions in its prototype,
 * is replaced with a function that throws a {@link DeveloperError}, except for the object's
 * <code>isDestroyed</code> function, which is set to a function that returns <code>true</code>.
 * The object's properties are removed with <code>delete</code>.
 * <br /><br />
 * This function is used by objects that hold native resources, e.g., WebGL resources, which
 * need to be explicitly released.  Client code calls an object's <code>destroy</code> function,
 * which then releases the native resource and calls <code>destroyObject</code> to put itself
 * in a destroyed state.
 * @example
 * // How a texture would destroy itself.
 * this.destroy = function () {
 *     _gl.deleteTexture(_texture);
 *     return SuperMap.destroyObject(this);
 * };
 * @param object - The object to destroy.
 * @param [message] - The message to include in the exception that is thrown if
 *                           a destroyed object's function is called.
 */
export function destroyObject(object: any, message?: string): void;

/**
 * Formats an error object into a String.  If available, uses name, message, and stack
 * properties, otherwise, falls back on toString().
 * @param object - The item to find in the array.
 * @returns A string containing the formatted error.
 */
export function formatError(object: any): string;

/**
 * Given a relative Uri and a base Uri, returns the absolute Uri of the relative Uri.
 * @example
 * //absolute Uri will be "https://test.com/awesome.png";
 * const absoluteUri = SuperMap.getAbsoluteUri('awesome.png', 'https://test.com');
 * @param relative - The relative Uri.
 * @param [base] - The base Uri.
 * @returns The absolute Uri of the given relative Uri.
 */
export function getAbsoluteUri(relative: string, base?: string): string;

/**
 * Given a URI, returns the base path of the URI.
 * @example
 * // basePath will be "/Gallery/";
 * const basePath = SuperMap.getBaseUri('/Gallery/simple.czml?value=true&example=false');
 *
 * // basePath will be "/Gallery/?value=true&example=false";
 * const basePath = SuperMap.getBaseUri('/Gallery/simple.czml?value=true&example=false', true);
 * @param uri - The Uri.
 * @param [includeQuery = false] - Whether or not to include the query string and fragment form the uri
 * @returns The base path of the Uri.
 */
export function getBaseUri(uri: string, includeQuery?: boolean): string;

/**
 * Given a URI, returns the extension of the URI.
 * @example
 * //extension will be "czml";
 * const extension = SuperMap.getExtensionFromUri('/Gallery/simple.czml?value=true&example=false');
 * @param uri - The Uri.
 * @returns The extension of the Uri.
 */
export function getExtensionFromUri(uri: string): string;

/**
 * Given a URI, returns the last segment of the URI, removing any path or query information.
 * @example
 * //fileName will be"simple.czml";
 * const fileName = SuperMap.getFilenameFromUri('/Gallery/simple.czml?value=true&example=false');
 * @param uri - The Uri.
 * @returns The last segment of the Uri.
 */
export function getFilenameFromUri(uri: string): string;

/**
 * Extract a pixel array from a loaded image.  Draws the image
 * into a canvas so it can read the pixels back.
 * @param image - The image to extract pixels from.
 * @param width - The width of the image. If not defined, then image.width is assigned.
 * @param height - The height of the image. If not defined, then image.height is assigned.
 * @returns The pixels of the image.
 */
export function getImagePixels(image: HTMLImageElement | ImageBitmap, width: number, height: number): ImageData;

/**
 * Gets a timestamp that can be used in measuring the time between events.  Timestamps
 * are expressed in milliseconds, but it is not specified what the milliseconds are
 * measured from.  This function uses performance.now() if it is available, or Date.now()
 * otherwise.
 * @returns The timestamp in milliseconds since some unspecified reference time.
 */
export function getTimestamp(): number;

/**
 * Determines if a given date is a leap year.
 * @example
 * const leapYear = SuperMap.isLeapYear(2000); // true
 * @param year - The year to be tested.
 * @returns True if <code>year</code> is a leap year.
 */
export function isLeapYear(year: number): boolean;

/**
 * A stable merge sort.
 * @example
 * // Assume array contains BoundingSpheres in world coordinates.
 * // Sort them in ascending order of distance from the camera.
 * const position = camera.positionWC;
 * SuperMap.mergeSort(array, function(a, b, position) {
 *     return SuperMap.BoundingSphere.distanceSquaredTo(b, position) - SuperMap.BoundingSphere.distanceSquaredTo(a, position);
 * }, position);
 * @param array - The array to sort.
 * @param comparator - The function to use to compare elements in the array.
 * @param [userDefinedObject] - Any item to pass as the third parameter to <code>comparator</code>.
 */
export function mergeSort(array: any[], comparator: mergeSortComparator, userDefinedObject?: any): void;

/**
* Converts an object representing a set of name/value pairs into a query string,
* with names and values encoded properly for use in a URL.  Values that are arrays
* will produce multiple values with the same name.
* @example
* const str = SuperMap.objectToQuery({
*     key1 : 'some value',
*     key2 : 'a/b',
*     key3 : ['x', 'y']
* });
* @param obj - The object containing data to encode.
* @returns An encoded query string.
*/
export function objectToQuery(obj: any): string;

/**
 * Determines if a point is inside a triangle.
 * @example
 * // Returns true
 * const p = new SuperMap.Cartesian2(0.25, 0.25);
 * const b = SuperMap.pointInsideTriangle(p,
 *   new SuperMap.Cartesian2(0.0, 0.0),
 *   new SuperMap.Cartesian2(1.0, 0.0),
 *   new SuperMap.Cartesian2(0.0, 1.0));
 * @param point - The point to test.
 * @param p0 - The first point of the triangle.
 * @param p1 - The second point of the triangle.
 * @param p2 - The third point of the triangle.
 * @returns <code>true</code> if the point is inside the triangle; otherwise, <code>false</code>.
 */
export function pointInsideTriangle(point: Cartesian2 | Cartesian3, p0: Cartesian2 | Cartesian3, p1: Cartesian2 | Cartesian3, p2: Cartesian2 | Cartesian3): boolean;

/**
 * Parses a query string into an object, where the keys and values of the object are the
 * name/value pairs from the query string, decoded. If a name appears multiple times,
 * the value in the object will be an array of values.
 * @example
 * const obj = SuperMap.queryToObject('key1=some%20value&key2=a%2Fb&key3=x&key3=y');
 * // obj will be:
 * // {
 * //   key1 : 'some value',
 * //   key2 : 'a/b',
 * //   key3 : ['x', 'y']
 * // }
 * @param queryString - The query string.
 * @returns An object containing the parameters parsed from the query string.
 */
export function queryToObject(queryString: string): any;

/**
 * A browser-independent function to request a new animation frame.  This is used to create
 * an application's draw loop as shown in the example below.
 * @example
 * // Create a draw loop using requestAnimationFrame. The
 * // tick callback function is called for every animation frame.
 * function tick() {
 *   scene.render();
 *   SuperMap.requestAnimationFrame(tick);
 * }
 * tick();
 * @param callback - The function to call when the next frame should be drawn.
 * @returns An ID that can be passed to {@link cancelAnimationFrame} to cancel the request.
 */
export function requestAnimationFrame(callback: requestAnimationFrameCallback): number;

/**
 * Initiates a terrain height query for an array of {@link Cartographic} positions by
 * requesting tiles from a terrain provider, sampling, and interpolating.  The interpolation
 * matches the triangles used to render the terrain at the specified level.  The query
 * happens asynchronously, so this function returns a promise that is resolved when
 * the query completes.  Each point height is modified in place.  If a height can not be
 * determined because no terrain data is available for the specified level at that location,
 * or another error occurs, the height is set to undefined.  As is typical of the
 * {@link Cartographic} type, the supplied height is a height above the reference ellipsoid
 * (such as {@link Ellipsoid.WGS84}) rather than an altitude above mean sea level.  In other
 * words, it will not necessarily be 0.0 if sampled in the ocean. This function needs the
 * terrain level of detail as input, if you need to get the altitude of the terrain as precisely
 * as possible (i.e. with maximum level of detail) use {@link sampleTerrainMostDetailed}.
 * @example
 * // Query the terrain height of two Cartographic positions
 * const terrainProvider = SuperMap.createWorldTerrain();
 * const positions = [
 *     SuperMap.Cartographic.fromDegrees(86.925145, 27.988257),
 *     SuperMap.Cartographic.fromDegrees(87.0, 28.0)
 * ];
 * const promise = SuperMap.sampleTerrain(terrainProvider, 11, positions);
 * Promise.resolve(promise).then(function(updatedPositions) {
 *     // positions[0].height and positions[1].height have been updated.
 *     // updatedPositions is just a reference to positions.
 * });
 * @param terrainProvider - The terrain provider from which to query heights.
 * @param level - The terrain level-of-detail from which to query terrain heights.
 * @param positions - The positions to update with terrain heights.
 * @returns A promise that resolves to the provided list of positions when terrain the query has completed.
 */
export function sampleTerrain(terrainProvider: TerrainProvider, level: number, positions: Cartographic[]): Promise<Cartographic[]>;

/**
 * Initiates a sampleTerrain() request at the maximum available tile level for a terrain dataset.
 * @example
 * // Query the terrain height of two Cartographic positions
 * const terrainProvider = SuperMap.createWorldTerrain();
 * const positions = [
 *     SuperMap.Cartographic.fromDegrees(86.925145, 27.988257),
 *     SuperMap.Cartographic.fromDegrees(87.0, 28.0)
 * ];
 * const promise = SuperMap.sampleTerrainMostDetailed(terrainProvider, positions);
 * Promise.resolve(promise).then(function(updatedPositions) {
 *     // positions[0].height and positions[1].height have been updated.
 *     // updatedPositions is just a reference to positions.
 * });
 * @param terrainProvider - The terrain provider from which to query heights.
 * @param positions - The positions to update with terrain heights.
 * @returns A promise that resolves to the provided list of positions when terrain the query has completed.  This
 *                                     promise will reject if the terrain provider's `availability` property is undefined.
 */
export function sampleTerrainMostDetailed(terrainProvider: TerrainProvider, positions: Cartographic[]): Promise<Cartographic[]>;

/**
 * Subdivides an array into a number of smaller, equal sized arrays.
 * @param array - The array to divide.
 * @param numberOfArrays - The number of arrays to divide the provided array into.
 */
export function subdivideArray(array: any[], numberOfArrays: number): void;

/**
 * Writes the given text into a new canvas.  The canvas will be sized to fit the text.
 * If text is blank, returns undefined.
 * @param text - The text to write.
 * @param [options] - Object with the following properties:
 * @param [options.font = '10px sans-serif'] - The CSS font to use.
 * @param [options.textBaseline = 'bottom'] - The baseline of the text.
 * @param [options.fill = true] - Whether to fill the text.
 * @param [options.stroke = false] - Whether to stroke the text.
 * @param [options.fillColor = Color.WHITE] - The fill color.
 * @param [options.strokeColor = Color.BLACK] - The stroke color.
 * @param [options.strokeWidth = 1] - The stroke width.
 * @param [options.backgroundColor = Color.TRANSPARENT] - The background color of the canvas.
 * @param [options.padding = 0] - The pixel size of the padding to add around the text.
 * @returns A new canvas with the given text drawn into it.  The dimensions object
 *                   from measureText will also be added to the returned canvas. If text is
 *                   blank, returns undefined.
 */
export function writeTextToCanvas(text: string, options?: {
  font?: string;
  textBaseline?: string;
  fill?: boolean;
  stroke?: boolean;
  fillColor?: Color;
  strokeColor?: Color;
  strokeWidth?: number;
  backgroundColor?: Color;
  padding?: number;
}): HTMLCanvasElement | undefined;

export namespace BillboardGraphics {
  /**
   * Initialization options for the BillboardGraphics constructor
   * @property [show = true] - A boolean Property specifying the visibility of the billboard.
   * @property [image] - A Property specifying the Image, URI, or Canvas to use for the billboard.
   * @property [scale = 1.0] - A numeric Property specifying the scale to apply to the image size.
   * @property [pixelOffset = Cartesian2.ZERO] - A {@link Cartesian2} Property specifying the pixel offset.
   * @property [eyeOffset = Cartesian3.ZERO] - A {@link Cartesian3} Property specifying the eye offset.
   * @property [horizontalOrigin = HorizontalOrigin.CENTER] - A Property specifying the {@link HorizontalOrigin}.
   * @property [verticalOrigin = VerticalOrigin.CENTER] - A Property specifying the {@link VerticalOrigin}.
   * @property [heightReference = HeightReference.NONE] - A Property specifying what the height is relative to.
   * @property [color = Color.WHITE] - A Property specifying the tint {@link Color} of the image.
   * @property [rotation = 0] - A numeric Property specifying the rotation about the alignedAxis.
   * @property [alignedAxis = Cartesian3.ZERO] - A {@link Cartesian3} Property specifying the unit vector axis of rotation.
   * @property [sizeInMeters] - A boolean Property specifying whether this billboard's size should be measured in meters.
   * @property [width] - A numeric Property specifying the width of the billboard in pixels, overriding the native size.
   * @property [height] - A numeric Property specifying the height of the billboard in pixels, overriding the native size.
   * @property [scaleByDistance] - A {@link NearFarScalar} Property used to scale the point based on distance from the camera.
   * @property [translucencyByDistance] - A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
   * @property [pixelOffsetScaleByDistance] - A {@link NearFarScalar} Property used to set pixelOffset based on distance from the camera.
   * @property [imageSubRegion] - A Property specifying a {@link BoundingRectangle} that defines a sub-region of the image to use for the billboard, rather than the entire image, measured in pixels from the bottom-left.
   * @property [distanceDisplayCondition] - A Property specifying at what distance from the camera that this billboard will be displayed.
   * @property [disableDepthTestDistance] - A Property specifying the distance from the camera at which to disable the depth test to.
   */
  type ConstructorOptions = {
    show?: Property | boolean;
    image?: Property | string | HTMLCanvasElement;
    scale?: Property | number;
    pixelOffset?: Property | Cartesian2;
    eyeOffset?: Property | Cartesian3;
    horizontalOrigin?: Property | HorizontalOrigin;
    verticalOrigin?: Property | VerticalOrigin;
    heightReference?: Property | HeightReference;
    color?: Property | Color;
    rotation?: Property | number;
    alignedAxis?: Property | Cartesian3;
    sizeInMeters?: Property | boolean;
    width?: Property | number;
    height?: Property | number;
    scaleByDistance?: Property | NearFarScalar;
    translucencyByDistance?: Property | NearFarScalar;
    pixelOffsetScaleByDistance?: Property | NearFarScalar;
    imageSubRegion?: Property | BoundingRectangle;
    distanceDisplayCondition?: Property | DistanceDisplayCondition;
    disableDepthTestDistance?: Property | number;
  };
}

/**
 * Describes a two dimensional icon located at the position of the containing {@link Entity}.
 * <p>
 * <div align='center'>
 * <img src='Images/Billboard.png' width='400' height='300' /><br />
 * Example billboards
 * </div>
 * </p>
 * @param [options] - Object describing initialization options
 */
export class BillboardGraphics {
  constructor(options?: BillboardGraphics.ConstructorOptions);
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the boolean Property specifying the visibility of the billboard.
   */
  show: Property | undefined;
  /**
   * Gets or sets the Property specifying the Image, URI, or Canvas to use for the billboard.
   */
  image: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
   * A scale greater than <code>1.0</code> enlarges the billboard while a scale less than <code>1.0</code> shrinks it.
   * <p>
   * <div align='center'>
   * <img src='Images/Billboard.setScale.png' width='400' height='300' /><br/>
   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>, and <code>2.0</code>.
   * </div>
   * </p>
   */
  scale: Property | undefined;
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the billboard's pixel offset in screen space
   * from the origin of this billboard.  This is commonly used to align multiple billboards and labels at
   * the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
   * canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
   * <td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='Images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
   * </tr></table>
   * The billboard's origin is indicated by the yellow point.
   * </div>
   * </p>
   */
  pixelOffset: Property | undefined;
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the billboard's offset in eye coordinates.
   * Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
   * right, <code>y</code> points up, and <code>z</code> points into the screen.
   * <p>
   * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
   * arrange a billboard above its corresponding 3D model.
   * </p>
   * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
   * appear on top of the Earth regardless of the viewer's or Earth's orientation.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
   * </tr></table>
   * <code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code>
   * </div>
   * </p>
   */
  eyeOffset: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link HorizontalOrigin}.
   */
  horizontalOrigin: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link VerticalOrigin}.
   */
  verticalOrigin: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   */
  heightReference: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link Color} that is multiplied with the <code>image</code>.
   * This has two common use cases.  First, the same white texture may be used by many different billboards,
   * each with a different color, to create colored billboards. Second, the color's alpha component can be
   * used to make the billboard translucent as shown below. An alpha of <code>0.0</code> makes the billboard
   * transparent, and <code>1.0</code> makes the billboard opaque.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
   * <td align='center'><code>alpha : 0.5</code><br/><img src='Images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
   * </tr></table>
   * </div>
   * </p>
   */
  color: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the rotation of the image
   * counter clockwise from the <code>alignedAxis</code>.
   */
  rotation: Property | undefined;
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the unit vector axis of rotation
   * in the fixed frame. When set to Cartesian3.ZERO the rotation is from the top of the screen.
   */
  alignedAxis: Property | undefined;
  /**
   * Gets or sets the boolean Property specifying if this billboard's size will be measured in meters.
   */
  sizeInMeters: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the width of the billboard in pixels.
   * When undefined, the native width is used.
   */
  width: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the height of the billboard in pixels.
   * When undefined, the native height is used.
   */
  height: Property | undefined;
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the scale of the billboard based on the distance from the camera.
   * A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's scale remains clamped to the nearest bound.
   */
  scaleByDistance: Property | undefined;
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the translucency of the billboard based on the distance from the camera.
   * A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's translucency remains clamped to the nearest bound.
   */
  translucencyByDistance: Property | undefined;
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the billboard based on the distance from the camera.
   * A billboard's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's pixel offset remains clamped to the nearest bound.
   */
  pixelOffsetScaleByDistance: Property | undefined;
  /**
   * Gets or sets the Property specifying a {@link BoundingRectangle} that defines a
   * sub-region of the <code>image</code> to use for the billboard, rather than the entire image,
   * measured in pixels from the bottom-left.
   */
  imageSubRegion: Property | undefined;
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this billboard will be displayed.
   */
  distanceDisplayCondition: Property | undefined;
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   */
  disableDepthTestDistance: Property | undefined;
  /**
   * Duplicates this instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new instance if one was not provided.
   */
  clone(result?: BillboardGraphics): BillboardGraphics;
  /**
   * Assigns each unassigned property on this object to the value
   * of the same property on the provided source object.
   * @param source - The object to be merged into this object.
   */
  merge(source: BillboardGraphics): void;
}

/**
 * A {@link Visualizer} which maps {@link Entity#billboard} to a {@link Billboard}.
 * @param entityCluster - The entity cluster to manage the collection of billboards and optionally cluster with other entities.
 * @param entityCollection - The entityCollection to visualize.
 */
export class BillboardVisualizer {
  constructor(entityCluster: EntityCluster, entityCollection: EntityCollection);
  /**
   * Updates the primitives created by this visualizer to match their
   * Entity counterpart at the given time.
   * @param time - The time to update to.
   * @returns This function always returns true.
   */
  update(time: JulianDate): boolean;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Removes and destroys all primitives created by this instance.
   */
  destroy(): void;
}

/**
 * A {@link GeometryUpdater} for boxes.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class BoxGeometryUpdater {
  constructor(entity: Entity, scene: Scene);
  /**
   * Creates the geometry instance which represents the fill of the geometry.
   * @param time - The time to use when retrieving initial attribute values.
   * @returns The geometry instance representing the filled portion of the geometry.
   */
  createFillGeometryInstance(time: JulianDate): GeometryInstance;
  /**
   * Creates the geometry instance which represents the outline of the geometry.
   * @param time - The time to use when retrieving initial attribute values.
   * @returns The geometry instance representing the outline portion of the geometry.
   */
  createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
}

export namespace BoxGraphics {
  /**
   * Initialization options for the BoxGraphics constructor
   * @property [show = true] - A boolean Property specifying the visibility of the box.
   * @property [dimensions] - A {@link Cartesian3} Property specifying the length, width, and height of the box.
   * @property [heightReference = HeightReference.NONE] - A Property specifying what the height from the entity position is relative to.
   * @property [fill = true] - A boolean Property specifying whether the box is filled with the provided material.
   * @property [material = Color.WHITE] - A Property specifying the material used to fill the box.
   * @property [outline = false] - A boolean Property specifying whether the box is outlined.
   * @property [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
   * @property [outlineWidth = 1.0] - A numeric Property specifying the width of the outline.
   * @property [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the box casts or receives shadows from light sources.
   * @property [distanceDisplayCondition] - A Property specifying at what distance from the camera that this box will be displayed.
   */
  type ConstructorOptions = {
    show?: Property | boolean;
    dimensions?: Property | Cartesian3;
    heightReference?: Property | HeightReference;
    fill?: Property | boolean;
    material?: MaterialProperty | Color;
    outline?: Property | boolean;
    outlineColor?: Property | Color;
    outlineWidth?: Property | number;
    shadows?: Property | ShadowMode;
    distanceDisplayCondition?: Property | DistanceDisplayCondition;
  };
}

/**
 * Describes a box. The center position and orientation are determined by the containing {@link Entity}.
 * @param [options] - Object describing initialization options
 */
export class BoxGraphics {
  constructor(options?: BoxGraphics.ConstructorOptions);
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the boolean Property specifying the visibility of the box.
   */
  show: Property | undefined;
  /**
   * Gets or sets {@link Cartesian3} Property property specifying the length, width, and height of the box.
   */
  dimensions: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   */
  heightReference: Property | undefined;
  /**
   * Gets or sets the boolean Property specifying whether the box is filled with the provided material.
   */
  fill: Property | undefined;
  /**
   * Gets or sets the material used to fill the box.
   */
  material: MaterialProperty | undefined;
  /**
   * Gets or sets the Property specifying whether the box is outlined.
   */
  outline: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   */
  outlineColor: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   */
  outlineWidth: Property | undefined;
  /**
   * Get or sets the enum Property specifying whether the box
   * casts or receives shadows from light sources.
   */
  shadows: Property | undefined;
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this box will be displayed.
   */
  distanceDisplayCondition: Property | undefined;
  /**
   * Duplicates this instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new instance if one was not provided.
   */
  clone(result?: BoxGraphics): BoxGraphics;
  /**
   * Assigns each unassigned property on this object to the value
   * of the same property on the provided source object.
   * @param source - The object to be merged into this object.
   */
  merge(source: BoxGraphics): void;
}

/**
 * A {@link Property} whose value is lazily evaluated by a callback function.
 * @param callback - The function to be called when the property is evaluated.
 * @param isConstant - <code>true</code> when the callback function returns the same value every time, <code>false</code> if the value will change.
 */
export class CallbackProperty {
  constructor(callback: CallbackProperty.Callback, isConstant: boolean);
  /**
   * Gets a value indicating if this property is constant.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is changed whenever setCallback is called.
   */
  readonly definitionChanged: Event;
  /**
   * Gets the value of the property.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied or is unsupported.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Sets the callback to be used.
   * @param callback - The function to be called when the property is evaluated.
   * @param isConstant - <code>true</code> when the callback function returns the same value every time, <code>false</code> if the value will change.
   */
  setCallback(callback: CallbackProperty.Callback, isConstant: boolean): void;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

export namespace CallbackProperty {
  /**
   * A function that returns the value of the property.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into. If omitted, the function must create and return a new instance.
   */
  type Callback = (time: JulianDate, result?: any) => any;
}

/**
* A {@link MaterialProperty} that maps to solid color {@link Material} uniforms.
* @param [color = Color.WHITE] - The {@link Color} Property to be used.
*/
export class ColorMaterialProperty {
  constructor(color?: Property | Color);
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the {@link Color} {@link Property}.
   */
  color: Property | undefined;
  /**
   * Gets the {@link Material} type at the provided time.
   * @param time - The time for which to retrieve the type.
   * @returns The type of material.
   */
  getType(time: JulianDate): string;
  /**
   * Gets the value of the property at the provided time.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
 * A {@link CompositeProperty} which is also a {@link PositionProperty}.
 * @param [referenceFrame = ReferenceFrame.FIXED] - The reference frame in which the position is defined.
 */
export class CompositePositionProperty {
  constructor(referenceFrame?: ReferenceFrame);
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is changed whenever setValue is called with data different
   * than the current value.
   */
  readonly definitionChanged: Event;
  /**
   * Gets the interval collection.
   */
  intervals: TimeIntervalCollection;
  /**
   * Gets or sets the reference frame which this position presents itself as.
   * Each PositionProperty making up this object has it's own reference frame,
   * so this property merely exposes a "preferred" reference frame for clients
   * to use.
   */
  referenceFrame: ReferenceFrame;
  /**
   * Gets the value of the property at the provided time in the fixed frame.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: Cartesian3): Cartesian3 | undefined;
  /**
   * Gets the value of the property at the provided time and in the provided reference frame.
   * @param time - The time for which to retrieve the value.
   * @param referenceFrame - The desired referenceFrame of the result.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValueInReferenceFrame(time: JulianDate, referenceFrame: ReferenceFrame, result?: Cartesian3): Cartesian3 | undefined;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
* A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
* data property of each {@link TimeInterval} is another Property instance which is
* evaluated at the provided time.
* @example
* const constantProperty = ...;
* const sampledProperty = ...;
*
* //Create a composite property from two previously defined properties
* //where the property is valid on August 1st, 2012 and uses a constant
* //property for the first half of the day and a sampled property for the
* //remaining half.
* const composite = new SuperMap.CompositeProperty();
* composite.intervals.addInterval(SuperMap.TimeInterval.fromIso8601({
*     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T12:00:00.00Z',
*     data : constantProperty
* }));
* composite.intervals.addInterval(SuperMap.TimeInterval.fromIso8601({
*     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-02T00:00:00.00Z',
*     isStartIncluded : false,
*     isStopIncluded : false,
*     data : sampledProperty
* }));
*/
export class CompositeProperty {
  constructor();
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is changed whenever setValue is called with data different
   * than the current value.
   */
  readonly definitionChanged: Event;
  /**
   * Gets the interval collection.
   */
  intervals: TimeIntervalCollection;
  /**
   * Gets the value of the property at the provided time.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
* A {@link PositionProperty} whose value does not change in respect to the
* {@link ReferenceFrame} in which is it defined.
* @param [value] - The property value.
* @param [referenceFrame = ReferenceFrame.FIXED] - The reference frame in which the position is defined.
*/
export class ConstantPositionProperty {
  constructor(value?: Cartesian3, referenceFrame?: ReferenceFrame);
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   */
  readonly definitionChanged: Event;
  /**
   * Gets the reference frame in which the position is defined.
   */
  referenceFrame: ReferenceFrame;
  /**
   * Gets the value of the property at the provided time in the fixed frame.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Sets the value of the property.
   * @param value - The property value.
   * @param [referenceFrame = this.referenceFrame] - The reference frame in which the position is defined.
   */
  setValue(value: Cartesian3, referenceFrame?: ReferenceFrame): void;
  /**
   * Gets the value of the property at the provided time and in the provided reference frame.
   * @param time - The time for which to retrieve the value.
   * @param referenceFrame - The desired referenceFrame of the result.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValueInReferenceFrame(time: JulianDate, referenceFrame: ReferenceFrame, result?: Cartesian3): Cartesian3;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
* A {@link Property} whose value does not change with respect to simulation time.
* @param [value] - The property value.
*/
export class ConstantProperty {
  constructor(value?: any);
  /**
   * Gets a value indicating if this property is constant.
   * This property always returns <code>true</code>.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is changed whenever setValue is called with data different
   * than the current value.
   */
  readonly definitionChanged: Event;
  /**
   * Gets the value of the property.
   * @param [time] - The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time?: JulianDate, result?: any): any;
  /**
   * Sets the value of the property.
   * @param value - The property value.
   */
  setValue(value: any): void;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
  /**
   * Gets this property's value.
   * @returns This property's value.
   */
  valueOf(): any;
  /**
   * Creates a string representing this property's value.
   * @returns A string representing the property's value.
   */
  toString(): string;
}

/**
 * Defines the interface for data sources, which turn arbitrary data into a
 * {@link EntityCollection} for generic consumption. This object is an interface
 * for documentation purposes and is not intended to be instantiated directly.
 */
export class DataSource {
  constructor();
  /**
   * Gets a human-readable name for this instance.
   */
  name: string;
  /**
   * Gets the preferred clock settings for this data source.
   */
  clock: DataSourceClock;
  /**
   * Gets the collection of {@link Entity} instances.
   */
  entities: EntityCollection;
  /**
   * Gets a value indicating if the data source is currently loading data.
   */
  isLoading: boolean;
  /**
   * Gets an event that will be raised when the underlying data changes.
   */
  changedEvent: Event;
  /**
   * Gets an event that will be raised if an error is encountered during processing.
   */
  errorEvent: Event<(arg0: this, arg1: RequestErrorEvent) => void>;
  /**
   * Gets an event that will be raised when the value of isLoading changes.
   */
  loadingEvent: Event<(arg0: this, arg1: boolean) => void>;
  /**
   * Gets whether or not this data source should be displayed.
   */
  show: boolean;
  /**
   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
   */
  clustering: EntityCluster;
  /**
   * Updates the data source to the provided time.  This function is optional and
   * is not required to be implemented.  It is provided for data sources which
   * retrieve data based on the current animation time or scene state.
   * If implemented, update will be called by {@link DataSourceDisplay} once a frame.
   * @param time - The simulation time.
   * @returns True if this data source is ready to be displayed at the provided time, false otherwise.
   */
  update(time: JulianDate): boolean;
}

/**
* Represents desired clock settings for a particular {@link DataSource}.  These settings may be applied
* to the {@link Clock} when the DataSource is loaded.
*/
export class DataSourceClock {
  constructor();
  /**
   * Gets the event that is raised whenever a new property is assigned.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the desired start time of the clock.
   * See {@link Clock#startTime}.
   */
  startTime: JulianDate;
  /**
   * Gets or sets the desired stop time of the clock.
   * See {@link Clock#stopTime}.
   */
  stopTime: JulianDate;
  /**
   * Gets or sets the desired current time when this data source is loaded.
   * See {@link Clock#currentTime}.
   */
  currentTime: JulianDate;
  /**
   * Gets or sets the desired clock range setting.
   * See {@link Clock#clockRange}.
   */
  clockRange: ClockRange;
  /**
   * Gets or sets the desired clock step setting.
   * See {@link Clock#clockStep}.
   */
  clockStep: ClockStep;
  /**
   * Gets or sets the desired clock multiplier.
   * See {@link Clock#multiplier}.
   */
  multiplier: number;
  /**
   * Duplicates a DataSourceClock instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new instance if one was not provided.
   */
  clone(result?: DataSourceClock): DataSourceClock;
  /**
   * Returns true if this DataSourceClock is equivalent to the other
   * @param other - The other DataSourceClock to compare to.
   * @returns <code>true</code> if the DataSourceClocks are equal; otherwise, <code>false</code>.
   */
  equals(other: DataSourceClock): boolean;
  /**
   * Assigns each unassigned property on this object to the value
   * of the same property on the provided source object.
   * @param source - The object to be merged into this object.
   */
  merge(source: DataSourceClock): void;
  /**
   * Gets the value of this clock instance as a {@link Clock} object.
   * @returns The modified result parameter or a new instance if one was not provided.
   */
  getValue(): Clock;
}

/**
 * Defines how screen space objects (billboards, points, labels) are clustered.
 * @param [options] - An object with the following properties:
 * @param [options.enabled = false] - Whether or not to enable clustering.
 * @param [options.pixelRange = 80] - The pixel range to extend the screen space bounding box.
 * @param [options.minimumClusterSize = 2] - The minimum number of screen space objects that can be clustered.
 * @param [options.clusterBillboards = true] - Whether or not to cluster the billboards of an entity.
 * @param [options.clusterLabels = true] - Whether or not to cluster the labels of an entity.
 * @param [options.clusterPoints = true] - Whether or not to cluster the points of an entity.
 * @param [options.show = true] - Determines if the entities in the cluster will be shown.
 */
export class EntityCluster {
  constructor(options?: {
    enabled?: boolean;
    pixelRange?: number;
    minimumClusterSize?: number;
    clusterBillboards?: boolean;
    clusterLabels?: boolean;
    clusterPoints?: boolean;
    show?: boolean;
  });
  /**
   * Determines if entities in this collection will be shown.
   */
  show: boolean;
  /**
   * Gets or sets whether clustering is enabled.
   */
  enabled: boolean;
  /**
   * Gets or sets the pixel range to extend the screen space bounding box.
   */
  pixelRange: number;
  /**
   * Gets or sets the minimum number of screen space objects that can be clustered.
   */
  minimumClusterSize: number;
  /**
   * Gets the event that will be raised when a new cluster will be displayed. The signature of the event listener is {@link EntityCluster.newClusterCallback}.
   */
  clusterEvent: Event<EntityCluster.newClusterCallback>;
  /**
   * Gets or sets whether clustering billboard entities is enabled.
   */
  clusterBillboards: boolean;
  /**
   * Gets or sets whether clustering labels entities is enabled.
   */
  clusterLabels: boolean;
  /**
   * Gets or sets whether clustering point entities is enabled.
   */
  clusterPoints: boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <p>
   * Unlike other objects that use WebGL resources, this object can be reused. For example, if a data source is removed
   * from a data source collection and added to another.
   * </p>
   */
  destroy(): void;
}

export namespace EntityCluster {
  /**
   * A event listener function used to style clusters.
   * @example
   * // The default cluster values.
   * dataSource.clustering.clusterEvent.addEventListener(function(entities, cluster) {
   *     cluster.label.show = true;
   *     cluster.label.text = entities.length.toLocaleString();
   * });
   * @param clusteredEntities - An array of the entities contained in the cluster.
   * @param cluster - An object containing the Billboard, Label, and Point
   * primitives that represent this cluster of entities.
   */
  type newClusterCallback = (clusteredEntities: Entity[], cluster: {
    billboard: Billboard;
    label: Label;
    point: PointPrimitive;
  }) => void;
}

/**
 * An abstract class for updating geometry entities.
 * @param options - An object with the following properties:
 * @param options.entity - The entity containing the geometry to be visualized.
 * @param options.scene - The scene where visualization is taking place.
 * @param options.geometryOptions - Options for the geometry
 * @param options.geometryPropertyName - The geometry property name
 * @param options.observedPropertyNames - The entity properties this geometry cares about
 */
export class GeometryUpdater {
  constructor(options: {
    entity: Entity;
    scene: Scene;
    geometryOptions: any;
    geometryPropertyName: string;
    observedPropertyNames: string[];
  });
  /**
   * Gets the unique ID associated with this updater
   */
  readonly id: string;
  /**
   * Gets the entity associated with this geometry.
   */
  readonly entity: Entity;
  /**
   * Gets a value indicating if the geometry has a fill component.
   */
  readonly fillEnabled: boolean;
  /**
   * Gets a value indicating if fill visibility varies with simulation time.
   */
  readonly hasConstantFill: boolean;
  /**
   * Gets the material property used to fill the geometry.
   */
  readonly fillMaterialProperty: MaterialProperty;
  /**
   * Gets a value indicating if the geometry has an outline component.
   */
  readonly outlineEnabled: boolean;
  /**
   * Gets a value indicating if the geometry has an outline component.
   */
  readonly hasConstantOutline: boolean;
  /**
   * Gets the {@link Color} property for the geometry outline.
   */
  readonly outlineColorProperty: Property;
  /**
   * Gets the constant with of the geometry outline, in pixels.
   * This value is only valid if isDynamic is false.
   */
  readonly outlineWidth: number;
  /**
   * Gets the property specifying whether the geometry
   * casts or receives shadows from light sources.
   */
  readonly shadowsProperty: Property;
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
   */
  readonly distanceDisplayConditionProperty: Property;
  /**
   * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.
   */
  readonly classificationTypeProperty: Property;
  /**
   * Gets a value indicating if the geometry is time-varying.
   * If true, all visualization is delegated to a DynamicGeometryUpdater
   * returned by GeometryUpdater#createDynamicUpdater.
   */
  readonly isDynamic: boolean;
  /**
   * Gets a value indicating if the geometry is closed.
   * This property is only valid for  geometry.
   */
  readonly isClosed: boolean;
  /**
   * Gets an event that is raised whenever the public properties
   * of this updater change.
   */
  readonly geometryChanged: boolean;
  /**
   * Checks if the geometry is outlined at the provided time.
   * @param time - The time for which to retrieve visibility.
   * @returns true if geometry is outlined at the provided time, false otherwise.
   */
  isOutlineVisible(time: JulianDate): boolean;
  /**
   * Checks if the geometry is filled at the provided time.
   * @param time - The time for which to retrieve visibility.
   * @returns true if geometry is filled at the provided time, false otherwise.
   */
  isFilled(time: JulianDate): boolean;
  /**
   * Creates the geometry instance which represents the fill of the geometry.
   * @param time - The time to use when retrieving initial attribute values.
   * @returns The geometry instance representing the filled portion of the geometry.
   */
  createFillGeometryInstance(time: JulianDate): GeometryInstance;
  /**
   * Creates the geometry instance which represents the outline of the geometry.
   * @param time - The time to use when retrieving initial attribute values.
   * @returns The geometry instance representing the outline portion of the geometry.
   */
  createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
   */
  destroy(): void;
}

/**
* A general purpose visualizer for geometry represented by {@link Primitive} instances.
* @param scene - The scene the primitives will be rendered in.
* @param entityCollection - The entityCollection to visualize.
* @param [primitives = scene.primitives] - A collection to add primitives related to the entities
* @param [groundPrimitives = scene.groundPrimitives] - A collection to add ground primitives related to the entities
*/
export class GeometryVisualizer {
  constructor(scene: Scene, entityCollection: EntityCollection, primitives?: PrimitiveCollection, groundPrimitives?: PrimitiveCollection);
  /**
   * Updates all of the primitives created by this visualizer to match their
   * Entity counterpart at the given time.
   * @param time - The time to update to.
   * @returns True if the visualizer successfully updated to the provided time,
   * false if the visualizer is waiting for asynchronous primitives to be created.
   */
  update(time: JulianDate): boolean;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Removes and destroys all primitives created by this instance.
   */
  destroy(): void;
}

/**
 * An abstract class for updating ground geometry entities.
 * @param options - An object with the following properties:
 * @param options.entity - The entity containing the geometry to be visualized.
 * @param options.scene - The scene where visualization is taking place.
 * @param options.geometryOptions - Options for the geometry
 * @param options.geometryPropertyName - The geometry property name
 * @param options.observedPropertyNames - The entity properties this geometry cares about
 */
export class GroundGeometryUpdater {
  constructor(options: {
    entity: Entity;
    scene: Scene;
    geometryOptions: any;
    geometryPropertyName: string;
    observedPropertyNames: string[];
  });
  /**
   * Gets the zindex
   */
  readonly zIndex: number;
  /**
   * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
   */
  destroy(): void;
}

/**
* A {@link MaterialProperty} that maps to image {@link Material} uniforms.
* @param [options] - Object with the following properties:
* @param [options.image] - A Property specifying the Image, URL, Canvas, or Video.
* @param [options.repeat = new Cartesian2(1.0, 1.0)] - A {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
* @param [options.color = Color.WHITE] - The color applied to the image
* @param [options.transparent = false] - Set to true when the image has transparency (for example, when a png has transparent sections)
*/
export class ImageMaterialProperty {
  constructor(options?: {
    image?: Property | string | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;
    repeat?: Property | Cartesian2;
    color?: Property | Color;
    transparent?: Property | boolean;
  });
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the Property specifying Image, URL, Canvas, or Video to use.
   */
  image: Property | undefined;
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
   */
  repeat: Property | undefined;
  /**
   * Gets or sets the Color Property specifying the desired color applied to the image.
   */
  color: Property | undefined;
  /**
   * Gets or sets the Boolean Property specifying whether the image has transparency
   */
  transparent: Property | undefined;
  /**
   * Gets the {@link Material} type at the provided time.
   * @param time - The time for which to retrieve the type.
   * @returns The type of material.
   */
  getType(time: JulianDate): string;
  /**
   * Gets the value of the property at the provided time.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
* Representation of <Camera> from KML
* @param position - camera position
* @param headingPitchRoll - camera orientation
*/
export class KmlCamera {
  constructor(position: Cartesian3, headingPitchRoll: HeadingPitchRoll);
}

export namespace KmlDataSource {
  /**
   * Initialization options for the `load` method.
   * @property [sourceUri] - Overrides the url to use for resolving relative links and other KML network features.
   * @property [clampToGround = false] - true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.
   * @property [ellipsoid = Ellipsoid.WGS84] - The global ellipsoid used for geographical calculations.
   * @property [screenOverlayContainer] - A container for ScreenOverlay images.
   */
  type LoadOptions = {
    sourceUri?: string;
    clampToGround?: boolean;
    ellipsoid?: Ellipsoid;
    screenOverlayContainer?: Element | string;
  };
  /**
   * Options for constructing a new KmlDataSource, or calling the  `load` method.
   * @property [camera] - The camera that is used for viewRefreshModes and sending camera properties to network links.
   * @property [canvas] - The canvas that is used for sending viewer properties to network links.
   * @property [credit] - A credit for the data source, which is displayed on the canvas.
   * @property [sourceUri] - Overrides the url to use for resolving relative links and other KML network features.
   * @property [clampToGround = false] - true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.
   * @property [ellipsoid = Ellipsoid.WGS84] - The global ellipsoid used for geographical calculations.
   * @property [screenOverlayContainer] - A container for ScreenOverlay images.
   */
  type ConstructorOptions = {
    camera?: Camera;
    canvas?: HTMLCanvasElement;
    credit?: Credit | string;
    sourceUri?: string;
    clampToGround?: boolean;
    ellipsoid?: Ellipsoid;
    screenOverlayContainer?: Element | string;
  };
}

/**
* A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).
* <p>
* Non visual feature data, such as <code>atom:author</code> and <code>ExtendedData</code>
* is exposed via an instance of {@link KmlFeatureData}, which is added to each {@link Entity}
* under the <code>kml</code> property.
* </p>
* @example
* const viewer = new SuperMap.Viewer('CesiumContainer');
* viewer.dataSources.add(SuperMap.KmlDataSource.load('../../SampleData/facilities.kmz',
*      {
*           camera: viewer.scene.camera,
*           canvas: viewer.scene.canvas
*      })
* );
* @param [options] - Object describing initialization options
*/
export class KmlDataSource {
  constructor(options?: KmlDataSource.ConstructorOptions);
  /**
   * The current size of this Canvas will be used to populate the Link parameters
   * for client height and width.
   */
  canvas: HTMLCanvasElement | undefined;
  /**
   * The position and orientation of this {@link Camera} will be used to
   * populate various camera parameters when making network requests.
   * Camera movement will determine when to trigger NetworkLink refresh if
   * <code>viewRefreshMode</code> is <code>onStop</code>.
   */
  camera: Camera | undefined;
  /**
   * Creates a Promise to a new instance loaded with the provided KML data.
   * @param data - A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.
   * @param [options] - An object specifying configuration options
   * @returns A promise that will resolve to a new KmlDataSource instance once the KML is loaded.
   */
  load(data: Resource | string | Document | Blob, options?: KmlDataSource.ConstructorOptions): Promise<KmlDataSource>;
  /**
   * Gets or sets a human-readable name for this instance.
   * This will be automatically be set to the KML document name on load.
   */
  name: string;
  /**
   * Gets the clock settings defined by the loaded KML. This represents the total
   * availability interval for all time-dynamic data. If the KML does not contain
   * time-dynamic data, this value is undefined.
   */
  clock: DataSourceClock;
  /**
   * Gets the collection of {@link Entity} instances.
   */
  entities: EntityCollection;
  /**
   * Gets a value indicating if the data source is currently loading data.
   */
  isLoading: boolean;
  /**
   * Gets an event that will be raised when the underlying data changes.
   */
  changedEvent: Event;
  /**
   * Gets an event that will be raised if an error is encountered during processing.
   */
  errorEvent: Event;
  /**
   * Gets an event that will be raised when the data source either starts or stops loading.
   */
  loadingEvent: Event;
  /**
   * Gets an event that will be raised when the data source refreshes a network link.
   */
  refreshEvent: Event;
  /**
   * Gets an event that will be raised when the data source finds an unsupported node type.
   */
  unsupportedNodeEvent: Event;
  /**
   * Gets whether or not this data source should be displayed.
   */
  show: boolean;
  /**
   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
   */
  clustering: EntityCluster;
  /**
   * Gets the credit that will be displayed for the data source
   */
  credit: Credit;
  /**
   * Gets the KML Tours that are used to guide the camera to specified destinations on given time intervals.
   */
  kmlTours: KmlTour[];
  /**
   * Asynchronously loads the provided KML data, replacing any existing data.
   * @param data - A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.
   * @param [options] - An object specifying configuration options
   * @returns A promise that will resolve to this instances once the KML is loaded.
   */
  load(data: Resource | string | Document | Blob, options?: KmlDataSource.LoadOptions): Promise<KmlDataSource>;
  /**
   * Cleans up any non-entity elements created by the data source. Currently this only affects ScreenOverlay elements.
   */
  destroy(): void;
  /**
   * Updates any NetworkLink that require updating.
   * @param time - The simulation time.
   * @returns True if this data source is ready to be displayed at the provided time, false otherwise.
   */
  update(time: JulianDate): boolean;
}

/**
 * @param position - camera position
 * @param headingPitchRange - camera orientation
 */
export class KmlLookAt {
  constructor(position: Cartesian3, headingPitchRange: HeadingPitchRange);
}

/**
* Describes a KmlTour, which uses KmlTourFlyTo, and KmlTourWait to
* guide the camera to a specified destinations on given time intervals.
* @param name - name parsed from KML
* @param id - id parsed from KML
* @param playlist - array with KmlTourFlyTos and KmlTourWaits
*/
export class KmlTour {
  constructor(name: string, id: string, playlist: any[]);
  /**
   * Id of kml gx:Tour entry
   */
  id: string;
  /**
   * Tour name
   */
  name: string;
  /**
   * Index of current entry from playlist
   */
  playlistIndex: number;
  /**
   * Array of playlist entries
   */
  playlist: any[];
  /**
   * Event will be called when tour starts to play,
   * before any playlist entry starts to play.
   */
  tourStart: Event;
  /**
   * Event will be called when all playlist entries are
   * played, or tour playback being canceled.
   *
   * If tour playback was terminated, event callback will
   * be called with terminated=true parameter.
   */
  tourEnd: Event;
  /**
   * Event will be called when entry from playlist starts to play.
   *
   * Event callback will be called with curent entry as first parameter.
   */
  entryStart: Event;
  /**
   * Event will be called when entry from playlist ends to play.
   *
   * Event callback will be called with following parameters:
   * 1. entry - entry
   * 2. terminated - true if playback was terminated by calling {@link KmlTour#stop}
   */
  entryEnd: Event;
  /**
   * Add entry to this tour playlist.
   * @param entry - an entry to add to the playlist.
   */
  addPlaylistEntry(entry: KmlTourFlyTo | KmlTourWait): void;
  /**
   * Play this tour.
   * @param viewer - viewer widget.
   * @param [cameraOptions] - these options will be merged with {@link Camera#flyTo}
   * options for FlyTo playlist entries.
   */
  play(viewer: Viewer, cameraOptions?: any): void;
  /**
   * Stop curently playing tour.
   */
  stop(): void;
}

/**
* Transitions the KmlTour to the next destination. This transition is facilitated
* using a specified flyToMode over a given number of seconds.
* @param duration - entry duration
* @param flyToMode - KML fly to mode: bounce, smooth, etc
* @param view - KmlCamera or KmlLookAt
*/
export class KmlTourFlyTo {
  constructor(duration: number, flyToMode: string, view: KmlCamera | KmlLookAt);
  /**
   * Play this playlist entry
   * @param done - function which will be called when playback ends
   * @param camera - SuperMap camera
   * @param [cameraOptions] - which will be merged with camera flyTo options. See {@link Camera#flyTo}
   */
  play(done: KmlTourFlyTo.DoneCallback, camera: Camera, cameraOptions?: any): void;
  /**
   * Stop execution of curent entry. Cancel camera flyTo
   */
  stop(): void;
  /**
   * Returns options for {@link Camera#flyTo} or {@link Camera#flyToBoundingSphere}
   * depends on this.view type.
   * @param cameraOptions - options to merge with generated. See {@link Camera#flyTo}
   * @returns {@link Camera#flyTo} or {@link Camera#flyToBoundingSphere} options
   */
  getCameraOptions(cameraOptions: any): any;
}

export namespace KmlTourFlyTo {
  /**
   * A function that will be executed when the flight completes.
   * @param terminated - true if {@link KmlTourFlyTo#stop} was
   * called before entry done playback.
   */
  type DoneCallback = (terminated: boolean) => void;
}

/**
* Pauses the KmlTour for a given number of seconds.
* @param duration - entry duration
*/
export class KmlTourWait {
  constructor(duration: number);
  /**
   * Play this playlist entry
   * @param done - function which will be called when playback ends
   */
  play(done: KmlTourWait.DoneCallback): void;
  /**
   * Stop execution of curent entry, cancel curent timeout
   */
  stop(): void;
}

export namespace KmlTourWait {
  /**
   * A function which will be called when playback ends.
   * @param terminated - true if {@link KmlTourWait#stop} was
   * called before entry done playback.
   */
  type DoneCallback = (terminated: boolean) => void;
}

export namespace LabelGraphics {
  /**
   * Initialization options for the LabelGraphics constructor
   * @property [show = true] - A boolean Property specifying the visibility of the label.
   * @property [text] - A Property specifying the text. Explicit newlines '\n' are supported.
   * @property [font = '30px sans-serif'] - A Property specifying the CSS font.
   * @property [style = LabelStyle.FILL] - A Property specifying the {@link LabelStyle}.
   * @property [scale = 1.0] - A numeric Property specifying the scale to apply to the text.
   * @property [showBackground = false] - A boolean Property specifying the visibility of the background behind the label.
   * @property [backgroundColor = new Color(0.165, 0.165, 0.165, 0.8)] - A Property specifying the background {@link Color}.
   * @property [backgroundPadding = new Cartesian2(7, 5)] - A {@link Cartesian2} Property specifying the horizontal and vertical background padding in pixels.
   * @property [pixelOffset = Cartesian2.ZERO] - A {@link Cartesian2} Property specifying the pixel offset.
   * @property [eyeOffset = Cartesian3.ZERO] - A {@link Cartesian3} Property specifying the eye offset.
   * @property [horizontalOrigin = HorizontalOrigin.CENTER] - A Property specifying the {@link HorizontalOrigin}.
   * @property [verticalOrigin = VerticalOrigin.CENTER] - A Property specifying the {@link VerticalOrigin}.
   * @property [heightReference = HeightReference.NONE] - A Property specifying what the height is relative to.
   * @property [fillColor = Color.WHITE] - A Property specifying the fill {@link Color}.
   * @property [outlineColor = Color.BLACK] - A Property specifying the outline {@link Color}.
   * @property [outlineWidth = 1.0] - A numeric Property specifying the outline width.
   * @property [translucencyByDistance] - A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
   * @property [pixelOffsetScaleByDistance] - A {@link NearFarScalar} Property used to set pixelOffset based on distance from the camera.
   * @property [scaleByDistance] - A {@link NearFarScalar} Property used to set scale based on distance from the camera.
   * @property [distanceDisplayCondition] - A Property specifying at what distance from the camera that this label will be displayed.
   * @property [disableDepthTestDistance] - A Property specifying the distance from the camera at which to disable the depth test to.
   */
  type ConstructorOptions = {
    show?: Property | boolean;
    text?: Property | string;
    font?: Property | string;
    style?: Property | LabelStyle;
    scale?: Property | number;
    showBackground?: Property | boolean;
    backgroundColor?: Property | Color;
    backgroundPadding?: Property | Cartesian2;
    pixelOffset?: Property | Cartesian2;
    eyeOffset?: Property | Cartesian3;
    horizontalOrigin?: Property | HorizontalOrigin;
    verticalOrigin?: Property | VerticalOrigin;
    heightReference?: Property | HeightReference;
    fillColor?: Property | Color;
    outlineColor?: Property | Color;
    outlineWidth?: Property | number;
    translucencyByDistance?: Property | NearFarScalar;
    pixelOffsetScaleByDistance?: Property | NearFarScalar;
    scaleByDistance?: Property | NearFarScalar;
    distanceDisplayCondition?: Property | DistanceDisplayCondition;
    disableDepthTestDistance?: Property | number;
  };
}

/**
* Describes a two dimensional label located at the position of the containing {@link Entity}.
* <p>
* <div align='center'>
* <img src='Images/Label.png' width='400' height='300' /><br />
* Example labels
* </div>
* </p>
* @param [options] - Object describing initialization options
*/
export class LabelGraphics {
  constructor(options?: LabelGraphics.ConstructorOptions);
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the boolean Property specifying the visibility of the label.
   */
  show: Property | undefined;
  /**
   * Gets or sets the string Property specifying the text of the label.
   * Explicit newlines '\n' are supported.
   */
  text: Property | undefined;
  /**
   * Gets or sets the string Property specifying the font in CSS syntax.
   */
  font: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link LabelStyle}.
   */
  style: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
   * A scale greater than <code>1.0</code> enlarges the label while a scale less than <code>1.0</code> shrinks it.
   * <p>
   * <div align='center'>
   * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>
   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
   * and <code>2.0</code>.
   * </div>
   * </p>
   */
  scale: Property | undefined;
  /**
   * Gets or sets the boolean Property specifying the visibility of the background behind the label.
   */
  showBackground: Property | undefined;
  /**
   * Gets or sets the Property specifying the background {@link Color}.
   */
  backgroundColor: Property | undefined;
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the label's horizontal and vertical
   * background padding in pixels.
   */
  backgroundPadding: Property | undefined;
  /**
   * Gets or sets the {@link Cartesian2} Property specifying the label's pixel offset in screen space
   * from the origin of this label.  This is commonly used to align multiple labels and labels at
   * the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
   * canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
   * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
   * </tr></table>
   * The label's origin is indicated by the yellow point.
   * </div>
   * </p>
   */
  pixelOffset: Property | undefined;
  /**
   * Gets or sets the {@link Cartesian3} Property specifying the label's offset in eye coordinates.
   * Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
   * right, <code>y</code> points up, and <code>z</code> points into the screen.
   * <p>
   * An eye offset is commonly used to arrange multiple labels or objects at the same position, e.g., to
   * arrange a label above its corresponding 3D model.
   * </p>
   * Below, the label is positioned at the center of the Earth but an eye offset makes it always
   * appear on top of the Earth regardless of the viewer's or Earth's orientation.
   * <p>
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
   * </tr></table>
   * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
   * </div>
   * </p>
   */
  eyeOffset: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link HorizontalOrigin}.
   */
  horizontalOrigin: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link VerticalOrigin}.
   */
  verticalOrigin: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   */
  heightReference: Property | undefined;
  /**
   * Gets or sets the Property specifying the fill {@link Color}.
   */
  fillColor: Property | undefined;
  /**
   * Gets or sets the Property specifying the outline {@link Color}.
   */
  outlineColor: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the outline width.
   */
  outlineWidth: Property | undefined;
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the translucency of the label based on the distance from the camera.
   * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's translucency remains clamped to the nearest bound.
   */
  translucencyByDistance: Property | undefined;
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the label based on the distance from the camera.
   * A label's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's pixel offset remains clamped to the nearest bound.
   */
  pixelOffsetScaleByDistance: Property | undefined;
  /**
   * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.
   * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,
   * scaleByDistance will be disabled.
   */
  scaleByDistance: Property | undefined;
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this label will be displayed.
   */
  distanceDisplayCondition: Property | undefined;
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   */
  disableDepthTestDistance: Property | undefined;
  /**
   * Duplicates this instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new instance if one was not provided.
   */
  clone(result?: LabelGraphics): LabelGraphics;
  /**
   * Assigns each unassigned property on this object to the value
   * of the same property on the provided source object.
   * @param source - The object to be merged into this object.
   */
  merge(source: LabelGraphics): void;
}

/**
* A {@link Visualizer} which maps the {@link LabelGraphics} instance
* in {@link Entity#label} to a {@link Label}.
* @param entityCluster - The entity cluster to manage the collection of billboards and optionally cluster with other entities.
* @param entityCollection - The entityCollection to visualize.
*/
export class LabelVisualizer {
  constructor(entityCluster: EntityCluster, entityCollection: EntityCollection);
  /**
   * Updates the primitives created by this visualizer to match their
   * Entity counterpart at the given time.
   * @param time - The time to update to.
   * @returns This function always returns true.
   */
  update(time: JulianDate): boolean;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Removes and destroys all primitives created by this instance.
   */
  destroy(): void;
}

/**
* The interface for all {@link Property} objects that represent {@link Material} uniforms.
* This type defines an interface and cannot be instantiated directly.
*/
export class MaterialProperty {
  constructor();
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   */
  readonly definitionChanged: Event;
  /**
   * Gets the {@link Material} type at the provided time.
   * @param time - The time for which to retrieve the type.
   * @returns The type of material.
   */
  getType(time: JulianDate): string;
  /**
   * Gets the value of the property at the provided time.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

export namespace PointGraphics {
  /**
   * Initialization options for the PointGraphics constructor
   * @property [show = true] - A boolean Property specifying the visibility of the point.
   * @property [pixelSize = 1] - A numeric Property specifying the size in pixels.
   * @property [heightReference = HeightReference.NONE] - A Property specifying what the height is relative to.
   * @property [color = Color.WHITE] - A Property specifying the {@link Color} of the point.
   * @property [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
   * @property [outlineWidth = 0] - A numeric Property specifying the the outline width in pixels.
   * @property [scaleByDistance] - A {@link NearFarScalar} Property used to scale the point based on distance.
   * @property [translucencyByDistance] - A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
   * @property [distanceDisplayCondition] - A Property specifying at what distance from the camera that this point will be displayed.
   * @property [disableDepthTestDistance] - A Property specifying the distance from the camera at which to disable the depth test to.
   */
  type ConstructorOptions = {
    show?: Property | boolean;
    pixelSize?: Property | number;
    heightReference?: Property | HeightReference;
    color?: Property | Color;
    outlineColor?: Property | Color;
    outlineWidth?: Property | number;
    scaleByDistance?: Property | NearFarScalar;
    translucencyByDistance?: Property | NearFarScalar;
    distanceDisplayCondition?: Property | DistanceDisplayCondition;
    disableDepthTestDistance?: Property | number;
  };
}

/**
* Describes a graphical point located at the position of the containing {@link Entity}.
* @param [options] - Object describing initialization options
*/
export class PointGraphics {
  constructor(options?: PointGraphics.ConstructorOptions);
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the boolean Property specifying the visibility of the point.
   */
  show: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the size in pixels.
   */
  pixelSize: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   */
  heightReference: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link Color} of the point.
   */
  color: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   */
  outlineColor: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the the outline width in pixels.
   */
  outlineWidth: Property | undefined;
  /**
   * Gets or sets the {@link NearFarScalar} Property used to scale the point based on distance.
   * If undefined, a constant size is used.
   */
  scaleByDistance: Property | undefined;
  /**
   * Gets or sets {@link NearFarScalar} Property specifying the translucency of the point based on the distance from the camera.
   * A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the points's translucency remains clamped to the nearest bound.
   */
  translucencyByDistance: Property | undefined;
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this point will be displayed.
   */
  distanceDisplayCondition: Property | undefined;
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   */
  disableDepthTestDistance: Property | undefined;
  /**
   * Duplicates this instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new instance if one was not provided.
   */
  clone(result?: PointGraphics): PointGraphics;
  /**
   * Assigns each unassigned property on this object to the value
   * of the same property on the provided source object.
   * @param source - The object to be merged into this object.
   */
  merge(source: PointGraphics): void;
}

/**
* A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.
* @param entityCluster - The entity cluster to manage the collection of billboards and optionally cluster with other entities.
* @param entityCollection - The entityCollection to visualize.
*/
export class PointVisualizer {
  constructor(entityCluster: EntityCluster, entityCollection: EntityCollection);
  /**
   * Updates the primitives created by this visualizer to match their
   * Entity counterpart at the given time.
   * @param time - The time to update to.
   * @returns This function always returns true.
   */
  update(time: JulianDate): boolean;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Removes and destroys all primitives created by this instance.
   */
  destroy(): void;
}

/**
* A {@link GeometryUpdater} for polygons.
* Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
* @param entity - The entity containing the geometry to be visualized.
* @param scene - The scene where visualization is taking place.
*/
export class PolygonGeometryUpdater {
  constructor(entity: Entity, scene: Scene);
  /**
   * Creates the geometry instance which represents the fill of the geometry.
   * @param time - The time to use when retrieving initial attribute values.
   * @returns The geometry instance representing the filled portion of the geometry.
   */
  createFillGeometryInstance(time: JulianDate): GeometryInstance;
  /**
   * Creates the geometry instance which represents the outline of the geometry.
   * @param time - The time to use when retrieving initial attribute values.
   * @returns The geometry instance representing the outline portion of the geometry.
   */
  createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
}

export namespace PolygonGraphics {
  /**
   * Initialization options for the PolygonGraphics constructor
   * @property [show = true] - A boolean Property specifying the visibility of the polygon.
   * @property [hierarchy] - A Property specifying the {@link PolygonHierarchy}.
   * @property [height = 0] - A numeric Property specifying the altitude of the polygon relative to the ellipsoid surface.
   * @property [heightReference = HeightReference.NONE] - A Property specifying what the height is relative to.
   * @property [extrudedHeight] - A numeric Property specifying the altitude of the polygon's extruded face relative to the ellipsoid surface.
   * @property [extrudedHeightReference = HeightReference.NONE] - A Property specifying what the extrudedHeight is relative to.
   * @property [stRotation = 0.0] - A numeric property specifying the rotation of the polygon texture counter-clockwise from north. Only has an effect if textureCoordinates is not defined.
   * @property [granularity = SuperMap.Math.RADIANS_PER_DEGREE] - A numeric Property specifying the angular distance between each latitude and longitude point.
   * @property [fill = true] - A boolean Property specifying whether the polygon is filled with the provided material.
   * @property [material = Color.WHITE] - A Property specifying the material used to fill the polygon.
   * @property [outline = false] - A boolean Property specifying whether the polygon is outlined.
   * @property [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
   * @property [outlineWidth = 1.0] - A numeric Property specifying the width of the outline.
   * @property [perPositionHeight = false] - A boolean specifying whether or not the height of each position is used.
   * @property [closeTop = true] - When false, leaves off the top of an extruded polygon open.
   * @property [closeBottom = true] - When false, leaves off the bottom of an extruded polygon open.
   * @property [arcType = ArcType.GEODESIC] - The type of line the polygon edges must follow.
   * @property [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the polygon casts or receives shadows from light sources.
   * @property [distanceDisplayCondition] - A Property specifying at what distance from the camera that this polygon will be displayed.
   * @property [classificationType = ClassificationType.BOTH] - An enum Property specifying whether this polygon will classify terrain, 3D Tiles, or both when on the ground.
   * @property [zIndex = 0] - A property specifying the zIndex used for ordering ground geometry.  Only has an effect if the polygon is constant and neither height or extrudedHeight are specified.
   * @property [textureCoordinates] - A Property specifying texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.
   */
  type ConstructorOptions = {
    show?: Property | boolean;
    hierarchy?: Property | PolygonHierarchy;
    height?: Property | number;
    heightReference?: Property | HeightReference;
    extrudedHeight?: Property | number;
    extrudedHeightReference?: Property | HeightReference;
    stRotation?: Property | number;
    granularity?: Property | number;
    fill?: Property | boolean;
    material?: MaterialProperty | Color;
    outline?: Property | boolean;
    outlineColor?: Property | Color;
    outlineWidth?: Property | number;
    perPositionHeight?: Property | boolean;
    closeTop?: boolean | boolean;
    closeBottom?: boolean | boolean;
    arcType?: Property | ArcType;
    shadows?: Property | ShadowMode;
    distanceDisplayCondition?: Property | DistanceDisplayCondition;
    classificationType?: Property | ClassificationType;
    zIndex?: ConstantProperty | number;
    textureCoordinates?: Property | PolygonHierarchy;
  };
}

/**
* Describes a polygon defined by an hierarchy of linear rings which make up the outer shape and any nested holes.
* The polygon conforms to the curvature of the globe and can be placed on the surface or
* at altitude and can optionally be extruded into a volume.
* @param [options] - Object describing initialization options
*/
export class PolygonGraphics {
  constructor(options?: PolygonGraphics.ConstructorOptions);
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the boolean Property specifying the visibility of the polygon.
   */
  show: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link PolygonHierarchy}.
   */
  hierarchy: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the constant altitude of the polygon.
   */
  height: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link HeightReference}.
   */
  heightReference: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the altitude of the polygon extrusion.
   * If {@link PolygonGraphics#perPositionHeight} is false, the volume starts at {@link PolygonGraphics#height} and ends at this altitude.
   * If {@link PolygonGraphics#perPositionHeight} is true, the volume starts at the height of each {@link PolygonGraphics#hierarchy} position and ends at this altitude.
   */
  extrudedHeight: Property | undefined;
  /**
   * Gets or sets the Property specifying the extruded {@link HeightReference}.
   */
  extrudedHeightReference: Property | undefined;
  /**
   * Gets or sets the numeric property specifying the rotation of the polygon texture counter-clockwise from north. Only has an effect if textureCoordinates is not defined.
   */
  stRotation: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the angular distance between points on the polygon.
   */
  granularity: Property | undefined;
  /**
   * Gets or sets the boolean Property specifying whether the polygon is filled with the provided material.
   */
  fill: Property | undefined;
  /**
   * Gets or sets the Property specifying the material used to fill the polygon.
   */
  material: MaterialProperty;
  /**
   * Gets or sets the Property specifying whether the polygon is outlined.
   */
  outline: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   */
  outlineColor: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   */
  outlineWidth: Property | undefined;
  /**
   * Gets or sets the boolean specifying whether or not the the height of each position is used.
   * If true, the shape will have non-uniform altitude defined by the height of each {@link PolygonGraphics#hierarchy} position.
   * If false, the shape will have a constant altitude as specified by {@link PolygonGraphics#height}.
   */
  perPositionHeight: Property | undefined;
  /**
   * Gets or sets a boolean specifying whether or not the top of an extruded polygon is included.
   */
  closeTop: Property | undefined;
  /**
   * Gets or sets a boolean specifying whether or not the bottom of an extruded polygon is included.
   */
  closeBottom: Property | undefined;
  /**
   * Gets or sets the {@link ArcType} Property specifying the type of lines the polygon edges use.
   */
  arcType: Property | undefined;
  /**
   * Get or sets the enum Property specifying whether the polygon
   * casts or receives shadows from light sources.
   */
  shadows: Property | undefined;
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this polygon will be displayed.
   */
  distanceDisplayCondition: Property | undefined;
  /**
   * Gets or sets the {@link ClassificationType} Property specifying whether this polygon will classify terrain, 3D Tiles, or both when on the ground.
   */
  classificationType: Property | undefined;
  /**
   * Gets or sets the zIndex Prperty specifying the ordering of ground geometry.  Only has an effect if the polygon is constant and neither height or extrudedHeight are specified.
   */
  zIndex: ConstantProperty | undefined;
  /**
   * A Property specifying texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.
   */
  textureCoordinates: Property | undefined;
  /**
   * Duplicates this instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new instance if one was not provided.
   */
  clone(result?: PolygonGraphics): PolygonGraphics;
  /**
   * Assigns each unassigned property on this object to the value
   * of the same property on the provided source object.
   * @param source - The object to be merged into this object.
   */
  merge(source: PolygonGraphics): void;
}

/**
* A {@link MaterialProperty} that maps to PolylineArrow {@link Material} uniforms.
* @param [color = Color.WHITE] - The {@link Color} Property to be used.
*/
export class PolylineArrowMaterialProperty {
  constructor(color?: Property | Color);
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the {@link Color} {@link Property}.
   */
  color: Property | undefined;
  /**
   * Gets the {@link Material} type at the provided time.
   * @param time - The time for which to retrieve the type.
   * @returns The type of material.
   */
  getType(time: JulianDate): string;
  /**
   * Gets the value of the property at the provided time.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
* A {@link MaterialProperty} that maps to polyline dash {@link Material} uniforms.
* @param [options] - Object with the following properties:
* @param [options.color = Color.WHITE] - A Property specifying the {@link Color} of the line.
* @param [options.gapColor = Color.TRANSPARENT] - A Property specifying the {@link Color} of the gaps in the line.
* @param [options.dashLength = 16.0] - A numeric Property specifying the length of the dash pattern in pixels.
* @param [options.dashPattern = 255.0] - A numeric Property specifying a 16 bit pattern for the dash
*/
export class PolylineDashMaterialProperty {
  constructor(options?: {
    color?: Property | Color;
    gapColor?: Property | Color;
    dashLength?: Property | number;
    dashPattern?: Property | number;
  });
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the Property specifying the {@link Color} of the line.
   */
  color: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link Color} of the gaps in the line.
   */
  gapColor: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the length of a dash cycle
   */
  dashLength: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying a dash pattern
   */
  dashPattern: Property | undefined;
  /**
   * Gets the {@link Material} type at the provided time.
   * @param time - The time for which to retrieve the type.
   * @returns The type of material.
   */
  getType(time: JulianDate): string;
  /**
   * Gets the value of the property at the provided time.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
* A {@link GeometryUpdater} for polylines.
* Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
* @param entity - The entity containing the geometry to be visualized.
* @param scene - The scene where visualization is taking place.
*/
export class PolylineGeometryUpdater {
  constructor(entity: Entity, scene: Scene);
  /**
   * Gets the unique ID associated with this updater
   */
  readonly id: string;
  /**
   * Gets the entity associated with this geometry.
   */
  readonly entity: Entity;
  /**
   * Gets a value indicating if the geometry has a fill component.
   */
  readonly fillEnabled: boolean;
  /**
   * Gets a value indicating if fill visibility varies with simulation time.
   */
  readonly hasConstantFill: boolean;
  /**
   * Gets the material property used to fill the geometry.
   */
  readonly fillMaterialProperty: MaterialProperty;
  /**
   * Gets the material property used to fill the geometry when it fails the depth test.
   */
  readonly depthFailMaterialProperty: MaterialProperty;
  /**
   * Gets a value indicating if the geometry has an outline component.
   */
  readonly outlineEnabled: boolean;
  /**
   * Gets a value indicating if outline visibility varies with simulation time.
   */
  readonly hasConstantOutline: boolean;
  /**
   * Gets the {@link Color} property for the geometry outline.
   */
  readonly outlineColorProperty: Property;
  /**
   * Gets the property specifying whether the geometry
   * casts or receives shadows from light sources.
   */
  readonly shadowsProperty: Property;
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
   */
  readonly distanceDisplayConditionProperty: Property;
  /**
   * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.
   */
  readonly classificationTypeProperty: Property;
  /**
   * Gets a value indicating if the geometry is time-varying.
   * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
   * returned by GeometryUpdater#createDynamicUpdater.
   */
  readonly isDynamic: boolean;
  /**
   * Gets a value indicating if the geometry is closed.
   * This property is only valid for  geometry.
   */
  readonly isClosed: boolean;
  /**
   * Gets an event that is raised whenever the public properties
   * of this updater change.
   */
  readonly geometryChanged: boolean;
  /**
   * Gets a value indicating if the path of the line.
   */
  readonly arcType: ArcType;
  /**
   * Gets a value indicating if the geometry is clamped to the ground.
   * Returns false if polylines on terrain is not supported.
   */
  readonly clampToGround: boolean;
  /**
   * Gets the zindex
   */
  readonly zIndex: number;
  /**
   * Checks if the geometry is outlined at the provided time.
   * @param time - The time for which to retrieve visibility.
   * @returns true if geometry is outlined at the provided time, false otherwise.
   */
  isOutlineVisible(time: JulianDate): boolean;
  /**
   * Checks if the geometry is filled at the provided time.
   * @param time - The time for which to retrieve visibility.
   * @returns true if geometry is filled at the provided time, false otherwise.
   */
  isFilled(time: JulianDate): boolean;
  /**
   * Creates the geometry instance which represents the fill of the geometry.
   * @param time - The time to use when retrieving initial attribute values.
   * @returns The geometry instance representing the filled portion of the geometry.
   */
  createFillGeometryInstance(time: JulianDate): GeometryInstance;
  /**
   * Creates the geometry instance which represents the outline of the geometry.
   * @param time - The time to use when retrieving initial attribute values.
   * @returns The geometry instance representing the outline portion of the geometry.
   */
  createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
   */
  destroy(): void;
}

/**
* A {@link MaterialProperty} that maps to polyline glow {@link Material} uniforms.
* @param [options] - Object with the following properties:
* @param [options.color = Color.WHITE] - A Property specifying the {@link Color} of the line.
* @param [options.glowPower = 0.25] - A numeric Property specifying the strength of the glow, as a percentage of the total line width.
* @param [options.taperPower = 1.0] - A numeric Property specifying the strength of the tapering effect, as a percentage of the total line length.  If 1.0 or higher, no taper effect is used.
*/
export class PolylineGlowMaterialProperty {
  constructor(options?: {
    color?: Property | Color;
    glowPower?: Property | number;
    taperPower?: Property | number;
  });
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the Property specifying the {@link Color} of the line.
   */
  color: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the strength of the glow, as a percentage of the total line width (less than 1.0).
   */
  glowPower: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the strength of the tapering effect, as a percentage of the total line length.  If 1.0 or higher, no taper effect is used.
   */
  taperPower: Property | undefined;
  /**
   * Gets the {@link Material} type at the provided time.
   * @param time - The time for which to retrieve the type.
   * @returns The type of material.
   */
  getType(time: JulianDate): string;
  /**
   * Gets the value of the property at the provided time.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

export namespace PolylineGraphics {
  /**
   * Initialization options for the PolylineGraphics constructor
   * @property [show = true] - A boolean Property specifying the visibility of the polyline.
   * @property [positions] - A Property specifying the array of {@link Cartesian3} positions that define the line strip.
   * @property [width = 1.0] - A numeric Property specifying the width in pixels.
   * @property [granularity = SuperMap.Math.RADIANS_PER_DEGREE] - A numeric Property specifying the angular distance between each latitude and longitude if arcType is not ArcType.NONE.
   * @property [material = Color.WHITE] - A Property specifying the material used to draw the polyline.
   * @property [depthFailMaterial] - A property specifying the material used to draw the polyline when it is below the terrain.
   * @property [arcType = ArcType.GEODESIC] - The type of line the polyline segments must follow.
   * @property [clampToGround = false] - A boolean Property specifying whether the Polyline should be clamped to the ground.
   * @property [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the polyline casts or receives shadows from light sources.
   * @property [distanceDisplayCondition] - A Property specifying at what distance from the camera that this polyline will be displayed.
   * @property [classificationType = ClassificationType.BOTH] - An enum Property specifying whether this polyline will classify terrain, 3D Tiles, or both when on the ground.
   * @property [zIndex = 0] - A Property specifying the zIndex used for ordering ground geometry. Only has an effect if `clampToGround` is true and polylines on terrain is supported.
   */
  type ConstructorOptions = {
    show?: Property | boolean;
    positions?: Property | Cartesian3[];
    width?: Property | number;
    granularity?: Property | number;
    material?: MaterialProperty | Color;
    depthFailMaterial?: MaterialProperty | Color;
    arcType?: Property | ArcType;
    clampToGround?: Property | boolean;
    shadows?: Property | ShadowMode;
    distanceDisplayCondition?: Property | DistanceDisplayCondition;
    classificationType?: Property | ClassificationType;
    zIndex?: Property | number;
  };
}

/**
* Describes a polyline. The first two positions define a line segment,
* and each additional position defines a line segment from the previous position. The segments
* can be linear connected points, great arcs, or clamped to terrain.
* @param [options] - Object describing initialization options
*/
export class PolylineGraphics {
  constructor(options?: PolylineGraphics.ConstructorOptions);
  /**
   * Gets the event that is raised whenever a property or sub-property is changed or modified.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the boolean Property specifying the visibility of the polyline.
   */
  show: Property | undefined;
  /**
   * Gets or sets the Property specifying the array of {@link Cartesian3}
   * positions that define the line strip.
   */
  positions: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the width in pixels.
   */
  width: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the angular distance between each latitude and longitude if arcType is not ArcType.NONE and clampToGround is false.
   */
  granularity: Property | undefined;
  /**
   * Gets or sets the Property specifying the material used to draw the polyline.
   */
  material: MaterialProperty;
  /**
   * Gets or sets the Property specifying the material used to draw the polyline when it fails the depth test.
   * <p>
   * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,
   * there may be artifacts.
   * </p>
   */
  depthFailMaterial: MaterialProperty;
  /**
   * Gets or sets the {@link ArcType} Property specifying whether the line segments should be great arcs, rhumb lines or linearly connected.
   */
  arcType: Property | undefined;
  /**
   * Gets or sets the boolean Property specifying whether the polyline
   * should be clamped to the ground.
   */
  clampToGround: Property | undefined;
  /**
   * Get or sets the enum Property specifying whether the polyline
   * casts or receives shadows from light sources.
   */
  shadows: Property | undefined;
  /**
   * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this polyline will be displayed.
   */
  distanceDisplayCondition: Property | undefined;
  /**
   * Gets or sets the {@link ClassificationType} Property specifying whether this polyline will classify terrain, 3D Tiles, or both when on the ground.
   */
  classificationType: Property | undefined;
  /**
   * Gets or sets the zIndex Property specifying the ordering of the polyline. Only has an effect if `clampToGround` is true and polylines on terrain is supported.
   */
  zIndex: ConstantProperty | undefined;
  /**
   * Duplicates this instance.
   * @param [result] - The object onto which to store the result.
   * @returns The modified result parameter or a new instance if one was not provided.
   */
  clone(result?: PolylineGraphics): PolylineGraphics;
  /**
   * Assigns each unassigned property on this object to the value
   * of the same property on the provided source object.
   * @param source - The object to be merged into this object.
   */
  merge(source: PolylineGraphics): void;
}

/**
* A {@link MaterialProperty} that maps to polyline outline {@link Material} uniforms.
* @param [options] - Object with the following properties:
* @param [options.color = Color.WHITE] - A Property specifying the {@link Color} of the line.
* @param [options.outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
* @param [options.outlineWidth = 1.0] - A numeric Property specifying the width of the outline, in pixels.
*/
export class PolylineOutlineMaterialProperty {
  constructor(options?: {
    color?: Property | Color;
    outlineColor?: Property | Color;
    outlineWidth?: Property | number;
  });
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the Property specifying the {@link Color} of the line.
   */
  color: Property | undefined;
  /**
   * Gets or sets the Property specifying the {@link Color} of the outline.
   */
  outlineColor: Property | undefined;
  /**
   * Gets or sets the numeric Property specifying the width of the outline.
   */
  outlineWidth: Property | undefined;
  /**
   * Gets the {@link Material} type at the provided time.
   * @param time - The time for which to retrieve the type.
   * @returns The type of material.
   */
  getType(time: JulianDate): string;
  /**
   * Gets the value of the property at the provided time.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
* A visualizer for polylines represented by {@link Primitive} instances.
* @param scene - The scene the primitives will be rendered in.
* @param entityCollection - The entityCollection to visualize.
* @param [primitives = scene.primitives] - A collection to add primitives related to the entities
* @param [groundPrimitives = scene.groundPrimitives] - A collection to add ground primitives related to the entities
*/
export class PolylineVisualizer {
  constructor(scene: Scene, entityCollection: EntityCollection, primitives?: PrimitiveCollection, groundPrimitives?: PrimitiveCollection);
  /**
   * Updates all of the primitives created by this visualizer to match their
   * Entity counterpart at the given time.
   * @param time - The time to update to.
   * @returns True if the visualizer successfully updated to the provided time,
   * false if the visualizer is waiting for asynchronous primitives to be created.
   */
  update(time: JulianDate): boolean;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Removes and destroys all primitives created by this instance.
   */
  destroy(): void;
}

/**
* A {@link GeometryUpdater} for polyline volumes.
* Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
* @param entity - The entity containing the geometry to be visualized.
* @param scene - The scene where visualization is taking place.
*/
export class PolylineVolumeGeometryUpdater {
  constructor(entity: Entity, scene: Scene);
  /**
   * Creates the geometry instance which represents the fill of the geometry.
   * @param time - The time to use when retrieving initial attribute values.
   * @returns The geometry instance representing the filled portion of the geometry.
   */
  createFillGeometryInstance(time: JulianDate): GeometryInstance;
  /**
   * Creates the geometry instance which represents the outline of the geometry.
   * @param time - The time to use when retrieving initial attribute values.
   * @returns The geometry instance representing the outline portion of the geometry.
   */
  createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
}
/**
 * The interface for all {@link Property} objects that define a world
 * location as a {@link Cartesian3} with an associated {@link ReferenceFrame}.
 * This type defines an interface and cannot be instantiated directly.
 */
export class PositionProperty {
  constructor();
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   */
  readonly definitionChanged: Event;
  /**
   * Gets the reference frame that the position is defined in.
   */
  referenceFrame: ReferenceFrame;
  /**
   * Gets the value of the property at the provided time in the fixed frame.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: Cartesian3): Cartesian3 | undefined;
  /**
   * Gets the value of the property at the provided time and in the provided reference frame.
   * @param time - The time for which to retrieve the value.
   * @param referenceFrame - The desired referenceFrame of the result.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValueInReferenceFrame(time: JulianDate, referenceFrame: ReferenceFrame, result?: Cartesian3): Cartesian3 | undefined;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
* A {@link Property} whose value is an array whose items are the computed value
* of other PositionProperty instances.
* @param [value] - An array of Property instances.
* @param [referenceFrame = ReferenceFrame.FIXED] - The reference frame in which the position is defined.
*/
export class PositionPropertyArray {
  constructor(value?: Property[], referenceFrame?: ReferenceFrame);
  /**
   * Gets a value indicating if this property is constant.  This property
   * is considered constant if all property items in the array are constant.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is changed whenever setValue is called with data different
   * than the current value or one of the properties in the array also changes.
   */
  readonly definitionChanged: Event;
  /**
   * Gets the reference frame in which the position is defined.
   */
  referenceFrame: ReferenceFrame;
  /**
   * Gets the value of the property.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: Cartesian3[]): Cartesian3[];
  /**
   * Gets the value of the property at the provided time and in the provided reference frame.
   * @param time - The time for which to retrieve the value.
   * @param referenceFrame - The desired referenceFrame of the result.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValueInReferenceFrame(time: JulianDate, referenceFrame: ReferenceFrame, result?: Cartesian3[]): Cartesian3[];
  /**
   * Sets the value of the property.
   * @param value - An array of Property instances.
   */
  setValue(value: Property[]): void;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
* The interface for all properties, which represent a value that can optionally vary over time.
* This type defines an interface and cannot be instantiated directly.
*/
export class Property {
  constructor();
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   */
  readonly definitionChanged: Event;
  /**
   * Gets the value of the property at the provided time.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

export interface PropertyBag extends Record<string, any> {
}

/**
 * A {@link Property} whose value is a key-value mapping of property names to the computed value of other properties.
 * @param [value] - An object, containing key-value mapping of property names to properties.
 * @param [createPropertyCallback] - A function that will be called when the value of any of the properties in value are not a Property.
 */
export class PropertyBag implements Record<string, any> {
  constructor(value?: any, createPropertyCallback?: (...params: any[]) => any);
  /**
   * Gets the names of all properties registered on this instance.
   */
  propertyNames: any[];
  /**
   * Gets a value indicating if this property is constant.  This property
   * is considered constant if all property items in this object are constant.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the set of properties contained in this
   * object changes, or one of the properties itself changes.
   */
  readonly definitionChanged: Event;
  /**
   * Determines if this object has defined a property with the given name.
   * @param propertyName - The name of the property to check for.
   * @returns True if this object has defined a property with the given name, false otherwise.
   */
  hasProperty(propertyName: string): boolean;
  /**
   * Adds a property to this object.
   * @param propertyName - The name of the property to add.
   * @param [value] - The value of the new property, if provided.
   * @param [createPropertyCallback] - A function that will be called when the value of this new property is set to a value that is not a Property.
   */
  addProperty(propertyName: string, value?: any, createPropertyCallback?: (...params: any[]) => any): void;
  /**
   * Removed a property previously added with addProperty.
   * @param propertyName - The name of the property to remove.
   */
  removeProperty(propertyName: string): void;
  /**
   * Gets the value of this property.  Each contained property will be evaluated at the given time, and the overall
   * result will be an object, mapping property names to those values.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * Note that any properties in result which are not part of this PropertyBag will be left as-is.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Assigns each unassigned property on this object to the value
   * of the same property on the provided source object.
   * @param source - The object to be merged into this object.
   * @param [createPropertyCallback] - A function that will be called when the value of any of the properties in value are not a Property.
   */
  merge(source: any, createPropertyCallback?: (...params: any[]) => any): void;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
 * A {@link GeometryUpdater} for rectangles.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class RectangleGeometryUpdater {
  constructor(entity: Entity, scene: Scene);
  /**
   * Creates the geometry instance which represents the fill of the geometry.
   * @param time - The time to use when retrieving initial attribute values.
   * @returns The geometry instance representing the filled portion of the geometry.
   */
  createFillGeometryInstance(time: JulianDate): GeometryInstance;
  /**
   * Creates the geometry instance which represents the outline of the geometry.
   * @param time - The time to use when retrieving initial attribute values.
   * @returns The geometry instance representing the outline portion of the geometry.
   */
  createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
}

/**
 * A {@link Property} whose value is interpolated for a given time from the
 * provided set of samples and specified interpolation algorithm and degree.
 * @example
 * //Create a linearly interpolated Cartesian2
 * const property = new Cesium.SampledProperty(Cesium.Cartesian2);
 *
 * //Populate it with data
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), new Cesium.Cartesian2(0, 0));
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-02T00:00:00.00Z'), new Cesium.Cartesian2(4, 7));
 *
 * //Retrieve an interpolated value
 * const result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T12:00:00.00Z'));
 * @example
 * //Create a simple numeric SampledProperty that uses third degree Hermite Polynomial Approximation
 * const property = new Cesium.SampledProperty(Number);
 * property.setInterpolationOptions({
 *     interpolationDegree : 3,
 *     interpolationAlgorithm : Cesium.HermitePolynomialApproximation
 * });
 *
 * //Populate it with data
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), 1.0);
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:01:00.00Z'), 6.0);
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:00.00Z'), 12.0);
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:03:30.00Z'), 5.0);
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:06:30.00Z'), 2.0);
 *
 * //Samples can be added in any order.
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:30.00Z'), 6.2);
 *
 * //Retrieve an interpolated value
 * const result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:34.00Z'));
 * @param type - The type of property.
 * @param [derivativeTypes] - When supplied, indicates that samples will contain derivative information of the specified types.
 */
export class SampledProperty {
  constructor(type: number | Packable, derivativeTypes?: Packable[]);
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is considered to have changed if a call to getValue would return
   * a different result for the same time.
   */
  readonly definitionChanged: Event;
  /**
   * Gets the type of property.
   */
  type: any;
  /**
   * Gets the derivative types used by this property.
   */
  derivativeTypes: Packable[];
  /**
   * Gets the degree of interpolation to perform when retrieving a value.
   */
  interpolationDegree: number;
  /**
   * Gets the interpolation algorithm to use when retrieving a value.
   */
  interpolationAlgorithm: InterpolationAlgorithm;
  /**
   * Gets or sets the type of extrapolation to perform when a value
   * is requested at a time after any available samples.
   */
  forwardExtrapolationType: ExtrapolationType;
  /**
   * Gets or sets the amount of time to extrapolate forward before
   * the property becomes undefined.  A value of 0 will extrapolate forever.
   */
  forwardExtrapolationDuration: number;
  /**
   * Gets or sets the type of extrapolation to perform when a value
   * is requested at a time before any available samples.
   */
  backwardExtrapolationType: ExtrapolationType;
  /**
   * Gets or sets the amount of time to extrapolate backward
   * before the property becomes undefined.  A value of 0 will extrapolate forever.
   */
  backwardExtrapolationDuration: number;
  /**
   * Gets the value of the property at the provided time.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Sets the algorithm and degree to use when interpolating a value.
   * @param [options] - Object with the following properties:
   * @param [options.interpolationAlgorithm] - The new interpolation algorithm.  If undefined, the existing property will be unchanged.
   * @param [options.interpolationDegree] - The new interpolation degree.  If undefined, the existing property will be unchanged.
   */
  setInterpolationOptions(options?: {
    interpolationAlgorithm?: InterpolationAlgorithm;
    interpolationDegree?: number;
  }): void;
  /**
   * Adds a new sample.
   * @param time - The sample time.
   * @param value - The value at the provided time.
   * @param [derivatives] - The array of derivatives at the provided time.
   */
  addSample(time: JulianDate, value: Packable, derivatives?: Packable[]): void;
  /**
   * Adds an array of samples.
   * @param times - An array of JulianDate instances where each index is a sample time.
   * @param values - The array of values, where each value corresponds to the provided times index.
   * @param [derivativeValues] - An array where each item is the array of derivatives at the equivalent time index.
   */
  addSamples(times: JulianDate[], values: Packable[], derivativeValues?: any[][]): void;
  /**
   * Adds samples as a single packed array where each new sample is represented as a date,
   * followed by the packed representation of the corresponding value and derivatives.
   * @param packedSamples - The array of packed samples.
   * @param [epoch] - If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.
   */
  addSamplesPackedArray(packedSamples: number[], epoch?: JulianDate): void;
  /**
   * Removes a sample at the given time, if present.
   * @param time - The sample time.
   * @returns <code>true</code> if a sample at time was removed, <code>false</code> otherwise.
   */
  removeSample(time: JulianDate): boolean;
  /**
   * Removes all samples for the given time interval.
   * @param time - The time interval for which to remove all samples.
   */
  removeSamples(time: TimeInterval): void;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
 * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
 * data property of each {@link TimeInterval} represents the value at time.
 * @example
 * //Create a Cartesian2 interval property which contains data on August 1st, 2012
 * //and uses a different value every 6 hours.
 * const composite = new Cesium.TimeIntervalCollectionProperty();
 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
 *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T06:00:00.00Z',
 *     isStartIncluded : true,
 *     isStopIncluded : false,
 *     data : new Cesium.Cartesian2(2.0, 3.4)
 * }));
 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
 *     iso8601 : '2012-08-01T06:00:00.00Z/2012-08-01T12:00:00.00Z',
 *     isStartIncluded : true,
 *     isStopIncluded : false,
 *     data : new Cesium.Cartesian2(12.0, 2.7)
 * }));
 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
 *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-01T18:00:00.00Z',
 *     isStartIncluded : true,
 *     isStopIncluded : false,
 *     data : new Cesium.Cartesian2(5.0, 12.4)
 * }));
 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
 *     iso8601 : '2012-08-01T18:00:00.00Z/2012-08-02T00:00:00.00Z',
 *     isStartIncluded : true,
 *     isStopIncluded : true,
 *     data : new Cesium.Cartesian2(85.0, 4.1)
 * }));
 */
export class TimeIntervalCollectionProperty {
  constructor();
  /**
   * Gets a value indicating if this property is constant.  A property is considered
   * constant if getValue always returns the same result for the current definition.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   * The definition is changed whenever setValue is called with data different
   * than the current value.
   */
  readonly definitionChanged: Event;
  /**
   * Gets the interval collection.
   */
  readonly intervals: TimeIntervalCollection;
  /**
   * Gets the value of the property at the provided time.
   * @param time - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time: JulianDate, result?: any): any;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
* A {@link Property} which evaluates to a {@link Quaternion} rotation
* based on the velocity of the provided {@link PositionProperty}.
* @example
* //Create an entity with position and orientation.
* const position = new Cesium.SampledProperty();
* position.addSamples(...);
* const entity = viewer.entities.add({
*   position : position,
*   orientation : new Cesium.VelocityOrientationProperty(position)
* }));
* @param [position] - The position property used to compute the orientation.
* @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid used to determine which way is up.
*/
export class VelocityOrientationProperty {
  constructor(position?: PositionProperty, ellipsoid?: Ellipsoid);
  /**
   * Gets a value indicating if this property is constant.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the position property used to compute orientation.
   */
  position: Property | undefined;
  /**
   * Gets or sets the ellipsoid used to determine which way is up.
   */
  ellipsoid: Property | undefined;
  /**
   * Gets the value of the property at the provided time.
   * @param [time] - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time?: JulianDate, result?: Quaternion): Quaternion;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
* A {@link Property} which evaluates to a {@link Cartesian3} vector
* based on the velocity of the provided {@link PositionProperty}.
* @example
* //Create an entity with a billboard rotated to match its velocity.
* const position = new Cesium.SampledProperty();
* position.addSamples(...);
* const entity = viewer.entities.add({
*   position : position,
*   billboard : {
*     image : 'image.png',
*     alignedAxis : new Cesium.VelocityVectorProperty(position, true) // alignedAxis must be a unit vector
*   }
* }));
* @param [position] - The position property used to compute the velocity.
* @param [normalize = true] - Whether to normalize the computed velocity vector.
*/
export class VelocityVectorProperty {
  constructor(position?: PositionProperty, normalize?: boolean);
  /**
   * Gets a value indicating if this property is constant.
   */
  readonly isConstant: boolean;
  /**
   * Gets the event that is raised whenever the definition of this property changes.
   */
  readonly definitionChanged: Event;
  /**
   * Gets or sets the position property used to compute the velocity vector.
   */
  position: Property | undefined;
  /**
   * Gets or sets whether the vector produced by this property
   * will be normalized or not.
   */
  normalize: boolean;
  /**
   * Gets the value of the property at the provided time.
   * @param [time] - The time for which to retrieve the value.
   * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
   * @returns The modified result parameter or a new instance if the result parameter was not supplied.
   */
  getValue(time?: JulianDate, result?: Cartesian3): Cartesian3;
  /**
   * Compares this property to the provided property and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   * @param [other] - The other property.
   * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(other?: Property): boolean;
}

/**
 * The data type of a pixel.
 */
export enum PixelDatatype {
  UNSIGNED_BYTE = WebGLConstants.UNSIGNED_BYTE,
  UNSIGNED_SHORT = WebGLConstants.UNSIGNED_SHORT,
  UNSIGNED_INT = WebGLConstants.UNSIGNED_INT,
  FLOAT = WebGLConstants.FLOAT,
  HALF_FLOAT = WebGLConstants.HALF_FLOAT_OES,
  UNSIGNED_INT_24_8 = WebGLConstants.UNSIGNED_INT_24_8,
  UNSIGNED_SHORT_4_4_4_4 = WebGLConstants.UNSIGNED_SHORT_4_4_4_4,
  UNSIGNED_SHORT_5_5_5_1 = WebGLConstants.UNSIGNED_SHORT_5_5_5_1,
  UNSIGNED_SHORT_5_6_5 = WebGLConstants.UNSIGNED_SHORT_5_6_5
}

/**
* Enumerates all possible filters used when magnifying WebGL textures.
*/
export enum TextureMagnificationFilter {
  /**
   * Samples the texture by returning the closest pixel.
   */
  NEAREST = WebGLConstants.NEAREST,
  /**
   * Samples the texture through bi-linear interpolation of the four nearest pixels. This produces smoother results than <code>NEAREST</code> filtering.
   */
  LINEAR = WebGLConstants.LINEAR
}

/**
* Enumerates all possible filters used when minifying WebGL textures.
*/
export enum TextureMinificationFilter {
  /**
   * Samples the texture by returning the closest pixel.
   */
  NEAREST = WebGLConstants.NEAREST,
  /**
   * Samples the texture through bi-linear interpolation of the four nearest pixels. This produces smoother results than <code>NEAREST</code> filtering.
   */
  LINEAR = WebGLConstants.LINEAR,
  /**
   * Selects the nearest mip level and applies nearest sampling within that level.
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   */
  NEAREST_MIPMAP_NEAREST = WebGLConstants.NEAREST_MIPMAP_NEAREST,
  /**
   * Selects the nearest mip level and applies linear sampling within that level.
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   */
  LINEAR_MIPMAP_NEAREST = WebGLConstants.LINEAR_MIPMAP_NEAREST,
  /**
   * Read texture values with nearest sampling from two adjacent mip levels and linearly interpolate the results.
   * <p>
   * This option provides a good balance of visual quality and speed when sampling from a mipmapped texture.
   * </p>
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   */
  NEAREST_MIPMAP_LINEAR = WebGLConstants.NEAREST_MIPMAP_LINEAR,
  /**
   * Read texture values with linear sampling from two adjacent mip levels and linearly interpolate the results.
   * <p>
   * This option provides a good balance of visual quality and speed when sampling from a mipmapped texture.
   * </p>
   * <p>
   * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
   * </p>
   */
  LINEAR_MIPMAP_LINEAR = WebGLConstants.LINEAR_MIPMAP_LINEAR
}

/**
* An appearance defines the full GLSL vertex and fragment shaders and the
* render state used to draw a {@link Primitive}.  All appearances implement
* this base <code>Appearance</code> interface.
* @param [options] - Object with the following properties:
* @param [options.translucent = true] - When <code>true</code>, the geometry is expected to appear translucent so {@link Appearance#renderState} has alpha blending enabled.
* @param [options.closed = false] - When <code>true</code>, the geometry is expected to be closed so {@link Appearance#renderState} has backface culling enabled.
* @param [options.material = Material.ColorType] - The material used to determine the fragment color.
* @param [options.vertexShaderSource] - Optional GLSL vertex shader source to override the default vertex shader.
* @param [options.fragmentShaderSource] - Optional GLSL fragment shader source to override the default fragment shader.
* @param [options.renderState] - Optional render state to override the default render state.
*/
export class Appearance {
  constructor(options?: {
    translucent?: boolean;
    closed?: boolean;
    material?: Material;
    vertexShaderSource?: string;
    fragmentShaderSource?: string;
    renderState?: any;
  });
  /**
   * The material used to determine the fragment color.  Unlike other {@link Appearance}
   * properties, this is not read-only, so an appearance's material can change on the fly.
   */
  material: Material;
  /**
   * When <code>true</code>, the geometry is expected to appear translucent.
   */
  translucent: boolean;
  /**
   * The GLSL source code for the vertex shader.
   */
  readonly vertexShaderSource: string;
  /**
   * The GLSL source code for the fragment shader.  The full fragment shader
   * source is built procedurally taking into account the {@link Appearance#material}.
   * Use {@link Appearance#getFragmentShaderSource} to get the full source.
   */
  readonly fragmentShaderSource: string;
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   */
  readonly renderState: any;
  /**
   * When <code>true</code>, the geometry is expected to be closed.
   */
  readonly closed: boolean;
  /**
   * Procedurally creates the full GLSL fragment shader source for this appearance
   * taking into account {@link Appearance#fragmentShaderSource} and {@link Appearance#material}.
   * @returns The full GLSL fragment shader source.
   */
  getFragmentShaderSource(): string;
  /**
   * Determines if the geometry is translucent based on {@link Appearance#translucent} and {@link Material#isTranslucent}.
   * @returns <code>true</code> if the appearance is translucent.
   */
  isTranslucent(): boolean;
  /**
   * Creates a render state.  This is not the final render state instance; instead,
   * it can contain a subset of render state properties identical to the render state
   * created in the context.
   * @returns The render state.
   */
  getRenderState(): any;
}

/**
 * A viewport-aligned image positioned in the 3D scene, that is created
 * and rendered using a {@link BillboardCollection}.  A billboard is created and its initial
 * properties are set by calling {@link BillboardCollection#add}.
 * <br /><br />
 * <div align='center'>
 * <img src='Images/Billboard.png' width='400' height='300' /><br />
 * Example billboards
 * </div>
 */
export class Billboard {
  constructor();
  /**
   * Determines if this billboard will be shown.  Use this to hide or show a billboard, instead
   * of removing it and re-adding it to the collection.
   */
  show: boolean;
  /**
   * Gets or sets the Cartesian position of this billboard.
   */
  position: Cartesian3;
  /**
   * Gets or sets the height reference of this billboard.
   */
  heightReference: HeightReference;
  /**
   * Gets or sets the pixel offset in screen space from the origin of this billboard.  This is commonly used
   * to align multiple billboards and labels at the same position, e.g., an image and text.  The
   * screen space origin is the top, left corner of the canvas; <code>x</code> increases from
   * left to right, and <code>y</code> increases from top to bottom.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
   * <td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='Images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
   * </tr></table>
   * The billboard's origin is indicated by the yellow point.
   * </div>
   */
  pixelOffset: Cartesian2;
  /**
   * Gets or sets near and far scaling properties of a Billboard based on the billboard's distance from the camera.
   * A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's scale remains clamped to the nearest bound.  If undefined,
   * scaleByDistance will be disabled.
   * @example
   * // Example 1.
   * // Set a billboard's scaleByDistance to scale by 1.5 when the
   * // camera is 1500 meters from the billboard and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * b.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);
   * @example
   * // Example 2.
   * // disable scaling by distance
   * b.scaleByDistance = undefined;
   */
  scaleByDistance: NearFarScalar;
  /**
   * Gets or sets near and far translucency properties of a Billboard based on the billboard's distance from the camera.
   * A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's translucency remains clamped to the nearest bound.  If undefined,
   * translucencyByDistance will be disabled.
   * @example
   * // Example 1.
   * // Set a billboard's translucency to 1.0 when the
   * // camera is 1500 meters from the billboard and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * b.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
   * @example
   * // Example 2.
   * // disable translucency by distance
   * b.translucencyByDistance = undefined;
   */
  translucencyByDistance: NearFarScalar;
  /**
   * Gets or sets near and far pixel offset scaling properties of a Billboard based on the billboard's distance from the camera.
   * A billboard's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the billboard's pixel offset scale remains clamped to the nearest bound.  If undefined,
   * pixelOffsetScaleByDistance will be disabled.
   * @example
   * // Example 1.
   * // Set a billboard's pixel offset scale to 0.0 when the
   * // camera is 1500 meters from the billboard and scale pixel offset to 10.0 pixels
   * // in the y direction the camera distance approaches 8.0e6 meters.
   * b.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);
   * b.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);
   * @example
   * // Example 2.
   * // disable pixel offset by distance
   * b.pixelOffsetScaleByDistance = undefined;
   */
  pixelOffsetScaleByDistance: NearFarScalar;
  /**
   * Gets or sets the 3D Cartesian offset applied to this billboard in eye coordinates.  Eye coordinates is a left-handed
   * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
   * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
   * which is typically meters.
   * <br /><br />
   * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
   * arrange a billboard above its corresponding 3D model.
   * <br /><br />
   * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
   * appear on top of the Earth regardless of the viewer's or Earth's orientation.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
   * </tr></table>
   * <code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
   * </div>
   */
  eyeOffset: Cartesian3;
  /**
   * Gets or sets the horizontal origin of this billboard, which determines if the billboard is
   * to the left, center, or right of its anchor position.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />
   * </div>
   * @example
   * // Use a bottom, left origin
   * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
   * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
   */
  horizontalOrigin: HorizontalOrigin;
  /**
   * Gets or sets the vertical origin of this billboard, which determines if the billboard is
   * to the above, below, or at the center of its anchor position.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />
   * </div>
   * @example
   * // Use a bottom, left origin
   * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
   * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
   */
  verticalOrigin: VerticalOrigin;
  /**
   * Gets or sets the uniform scale that is multiplied with the billboard's image size in pixels.
   * A scale of <code>1.0</code> does not change the size of the billboard; a scale greater than
   * <code>1.0</code> enlarges the billboard; a positive scale less than <code>1.0</code> shrinks
   * the billboard.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setScale.png' width='400' height='300' /><br/>
   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
   * and <code>2.0</code>.
   * </div>
   */
  scale: number;
  /**
   * Gets or sets the color that is multiplied with the billboard's texture.  This has two common use cases.  First,
   * the same white texture may be used by many different billboards, each with a different color, to create
   * colored billboards.  Second, the color's alpha component can be used to make the billboard translucent as shown below.
   * An alpha of <code>0.0</code> makes the billboard transparent, and <code>1.0</code> makes the billboard opaque.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
   * <td align='center'><code>alpha : 0.5</code><br/><img src='Images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
   * </tr></table>
   * </div>
   * <br />
   * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
   * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
   * (no intensity) to <code>1.0</code> (full intensity).
   * @example
   * // Example 1. Assign yellow.
   * b.color = Cesium.Color.YELLOW;
   * @example
   * // Example 2. Make a billboard 50% translucent.
   * b.color = new Cesium.Color(1.0, 1.0, 1.0, 0.5);
   */
  color: Color;
  /**
   * Gets or sets the rotation angle in radians.
   */
  rotation: number;
  /**
   * Gets or sets the aligned axis in world space. The aligned axis is the unit vector that the billboard up vector points towards.
   * The default is the zero vector, which means the billboard is aligned to the screen up vector.
   * @example
   * // Example 1.
   * // Have the billboard up vector point north
   * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;
   * @example
   * // Example 2.
   * // Have the billboard point east.
   * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;
   * billboard.rotation = -Cesium.Math.PI_OVER_TWO;
   * @example
   * // Example 3.
   * // Reset the aligned axis
   * billboard.alignedAxis = Cesium.Cartesian3.ZERO;
   */
  alignedAxis: Cartesian3;
  /**
   * Gets or sets a width for the billboard. If undefined, the image width will be used.
   */
  width: number;
  /**
   * Gets or sets a height for the billboard. If undefined, the image height will be used.
   */
  height: number;
  /**
   * Gets or sets if the billboard size is in meters or pixels. <code>true</code> to size the billboard in meters;
   * otherwise, the size is in pixels.
   */
  sizeInMeters: boolean;
  /**
   * Gets or sets the condition specifying at what distance from the camera that this billboard will be displayed.
   */
  distanceDisplayCondition: DistanceDisplayCondition;
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   */
  disableDepthTestDistance: number;
  /**
   * Gets or sets the user-defined object returned when the billboard is picked.
   */
  id: any;
  /**
   * <p>
   * Gets or sets the image to be used for this billboard.  If a texture has already been created for the
   * given image, the existing texture is used.
   * </p>
   * <p>
   * This property can be set to a loaded Image, a URL which will be loaded as an Image automatically,
   * a canvas, or another billboard's image property (from the same billboard collection).
   * </p>
   * @example
   * // load an image from a URL
   * b.image = 'some/image/url.png';
   *
   * // assuming b1 and b2 are billboards in the same billboard collection,
   * // use the same image for both billboards.
   * b2.image = b1.image;
   */
  image: string;
  /**
   * When <code>true</code>, this billboard is ready to render, i.e., the image
   * has been downloaded and the WebGL resources are created.
   */
  readonly ready: boolean;
  /**
   * <p>
   * Sets the image to be used for this billboard.  If a texture has already been created for the
   * given id, the existing texture is used.
   * </p>
   * <p>
   * This function is useful for dynamically creating textures that are shared across many billboards.
   * Only the first billboard will actually call the function and create the texture, while subsequent
   * billboards created with the same id will simply re-use the existing texture.
   * </p>
   * <p>
   * To load an image from a URL, setting the {@link Billboard#image} property is more convenient.
   * </p>
   * @example
   * // create a billboard image dynamically
   * function drawImage(id) {
   *   // create and draw an image using a canvas
   *   const canvas = document.createElement('canvas');
   *   const context2D = canvas.getContext('2d');
   *   // ... draw image
   *   return canvas;
   * }
   * // drawImage will be called to create the texture
   * b.setImage('myImage', drawImage);
   *
   * // subsequent billboards created in the same collection using the same id will use the existing
   * // texture, without the need to create the canvas or draw the image
   * b2.setImage('myImage', drawImage);
   * @param id - The id of the image.  This can be any string that uniquely identifies the image.
   * @param image - The image to load.  This parameter
   *        can either be a loaded Image or Canvas, a URL which will be loaded as an Image automatically,
   *        or a function which will be called to create the image if it hasn't been loaded already.
   */
  setImage(id: string, image: HTMLImageElement | HTMLCanvasElement | string | Resource | Billboard.CreateImageCallback): void;
  /**
   * Uses a sub-region of the image with the given id as the image for this billboard,
   * measured in pixels from the bottom-left.
   * @param id - The id of the image to use.
   * @param subRegion - The sub-region of the image.
   */
  setImageSubRegion(id: string, subRegion: BoundingRectangle): void;
  /**
   * Computes the screen-space position of the billboard's origin, taking into account eye and pixel offsets.
   * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from
   * left to right, and <code>y</code> increases from top to bottom.
   * @example
   * console.log(b.computeScreenSpacePosition(scene).toString());
   * @param scene - The scene.
   * @param [result] - The object onto which to store the result.
   * @returns The screen-space position of the billboard.
   */
  computeScreenSpacePosition(scene: Scene, result?: Cartesian2): Cartesian2;
  /**
   * Determines if this billboard equals another billboard.  Billboards are equal if all their properties
   * are equal.  Billboards in different collections can be equal.
   * @param other - The billboard to compare for equality.
   * @returns <code>true</code> if the billboards are equal; otherwise, <code>false</code>.
   */
  equals(other: Billboard): boolean;
}

export namespace Billboard {
  /**
   * A function that creates an image.
   * @param id - The identifier of the image to load.
   */
  type CreateImageCallback = (id: string) => HTMLImageElement | HTMLCanvasElement | Promise<HTMLImageElement | HTMLCanvasElement>;
}

/**
* A renderable collection of billboards.  Billboards are viewport-aligned
* images positioned in the 3D scene.
* <br /><br />
* <div align='center'>
* <img src='Images/Billboard.png' width='400' height='300' /><br />
* Example billboards
* </div>
* <br /><br />
* Billboards are added and removed from the collection using {@link BillboardCollection#add}
* and {@link BillboardCollection#remove}.  Billboards in a collection automatically share textures
* for images with the same identifier.
* @example
* // Create a billboard collection with two billboards
* const billboards = scene.primitives.add(new Cesium.BillboardCollection());
* billboards.add({
*   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),
*   image : 'url/to/image'
* });
* billboards.add({
*   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),
*   image : 'url/to/another/image'
* });
* @param [options] - Object with the following properties:
* @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms each billboard from model to world coordinates.
* @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
* @param [options.scene] - Must be passed in for billboards that use the height reference property or will be depth tested against the globe.
* @param [options.blendOption = BlendOption.OPAQUE_AND_TRANSLUCENT] - The billboard blending option. The default
* is used for rendering both opaque and translucent billboards. However, if either all of the billboards are completely opaque or all are completely translucent,
* setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.
* @param [options.show = true] - Determines if the billboards in the collection will be shown.
*/
export class BillboardCollection {
  constructor(options?: {
    modelMatrix?: Matrix4;
    debugShowBoundingVolume?: boolean;
    scene?: Scene;
    blendOption?: BlendOption;
    show?: boolean;
  });
  /**
   * Determines if billboards in this collection will be shown.
   */
  show: boolean;
  /**
   * The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.
   * When this is the identity matrix, the billboards are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
   * Local reference frames can be used by providing a different transformation matrix, like that returned
   * by {@link Transforms.eastNorthUpToFixedFrame}.
   * @example
   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
   * billboards.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
   * billboards.add({
   *   image : 'url/to/image',
   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center
   * });
   * billboards.add({
   *   image : 'url/to/image',
   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east
   * });
   * billboards.add({
   *   image : 'url/to/image',
   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north
   * });
   * billboards.add({
   *   image : 'url/to/image',
   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up
   * });
   */
  modelMatrix: Matrix4;
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the bounding sphere for each draw command in the primitive.
   * </p>
   */
  debugShowBoundingVolume: boolean;
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the texture atlas for this BillboardCollection as a fullscreen quad.
   * </p>
   */
  debugShowTextureAtlas: boolean;
  /**
   * The billboard blending option. The default is used for rendering both opaque and translucent billboards.
   * However, if either all of the billboards are completely opaque or all are completely translucent,
   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve
   * performance by up to 2x.
   */
  blendOption: BlendOption;
  /**
   * Returns the number of billboards in this collection.  This is commonly used with
   * {@link BillboardCollection#get} to iterate over all the billboards
   * in the collection.
   */
  length: number;
  /**
   * Creates and adds a billboard with the specified initial properties to the collection.
   * The added billboard is returned so it can be modified or removed from the collection later.
   * @example
   * // Example 1:  Add a billboard, specifying all the default values.
   * const b = billboards.add({
   *   show : true,
   *   position : Cesium.Cartesian3.ZERO,
   *   pixelOffset : Cesium.Cartesian2.ZERO,
   *   eyeOffset : Cesium.Cartesian3.ZERO,
   *   heightReference : Cesium.HeightReference.NONE,
   *   horizontalOrigin : Cesium.HorizontalOrigin.CENTER,
   *   verticalOrigin : Cesium.VerticalOrigin.CENTER,
   *   scale : 1.0,
   *   image : 'url/to/image',
   *   imageSubRegion : undefined,
   *   color : Cesium.Color.WHITE,
   *   id : undefined,
   *   rotation : 0.0,
   *   alignedAxis : Cesium.Cartesian3.ZERO,
   *   width : undefined,
   *   height : undefined,
   *   scaleByDistance : undefined,
   *   translucencyByDistance : undefined,
   *   pixelOffsetScaleByDistance : undefined,
   *   sizeInMeters : false,
   *   distanceDisplayCondition : undefined
   * });
   * @example
   * // Example 2:  Specify only the billboard's cartographic position.
   * const b = billboards.add({
   *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)
   * });
   * @param [options] - A template describing the billboard's properties as shown in Example 1.
   * @returns The billboard that was added to the collection.
   */
  add(options?: any): Billboard;
  /**
   * Removes a billboard from the collection.
   * @example
   * const b = billboards.add(...);
   * billboards.remove(b);  // Returns true
   * @param billboard - The billboard to remove.
   * @returns <code>true</code> if the billboard was removed; <code>false</code> if the billboard was not found in the collection.
   */
  remove(billboard: Billboard): boolean;
  /**
   * Removes all billboards from the collection.
   * @example
   * billboards.add(...);
   * billboards.add(...);
   * billboards.removeAll();
   */
  removeAll(): void;
  /**
   * Check whether this collection contains a given billboard.
   * @param [billboard] - The billboard to check for.
   * @returns true if this collection contains the billboard, false otherwise.
   */
  contains(billboard?: Billboard): boolean;
  /**
   * Returns the billboard in the collection at the specified index.  Indices are zero-based
   * and increase as billboards are added.  Removing a billboard shifts all billboards after
   * it to the left, changing their indices.  This function is commonly used with
   * {@link BillboardCollection#length} to iterate over all the billboards
   * in the collection.
   * @example
   * // Toggle the show property of every billboard in the collection
   * const len = billboards.length;
   * for (let i = 0; i < len; ++i) {
   *   const b = billboards.get(i);
   *   b.show = !b.show;
   * }
   * @param index - The zero-based index of the billboard.
   * @returns The billboard at the specified index.
   */
  get(index: number): Billboard;
  /**
   * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
   * get the draw commands needed to render this primitive.
   * <p>
   * Do not call this function directly.  This is documented just to
   * list the exceptions that may be propagated when the scene is rendered:
   * </p>
   */
  update(): void;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * billboards = billboards && billboards.destroy();
   */
  destroy(): void;
}

export namespace BingMapsImageryProvider {
  /**
   * Initialization options for the BingMapsImageryProvider constructor
   * @property url - The url of the Bing Maps server hosting the imagery.
   * @property key - The Bing Maps key for your application, which can be
   *        created at {@link https://www.bingmapsportal.com/}.
   * @property [tileProtocol] - The protocol to use when loading tiles, e.g. 'http' or 'https'.
   *        By default, tiles are loaded using the same protocol as the page.
   * @property [mapStyle = BingMapsStyle.AERIAL] - The type of Bing Maps imagery to load.
   * @property [culture = ''] - The culture to use when requesting Bing Maps imagery. Not
   *        all cultures are supported. See {@link http://msdn.microsoft.com/en-us/library/hh441729.aspx}
   *        for information on the supported cultures.
   * @property [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
   * @property [tileDiscardPolicy] - The policy that determines if a tile
   *        is invalid and should be discarded.  By default, a {@link DiscardEmptyTileImagePolicy}
   *        will be used, with the expectation that the Bing Maps server will send a zero-length response for missing tiles.
   *        To ensure that no tiles are discarded, construct and pass a {@link NeverTileDiscardPolicy} for this parameter.
   */
  type ConstructorOptions = {
    url: Resource | string;
    key: string;
    tileProtocol?: string;
    mapStyle?: BingMapsStyle;
    culture?: string;
    ellipsoid?: Ellipsoid;
    tileDiscardPolicy?: TileDiscardPolicy;
  };
}

/**
* Provides tiled imagery using the Bing Maps Imagery REST API.
* @example
* const bing = new Cesium.BingMapsImageryProvider({
*     url : 'https://dev.virtualearth.net',
*     key : 'get-yours-at-https://www.bingmapsportal.com/',
*     mapStyle : Cesium.BingMapsStyle.AERIAL
* });
* @param options - Object describing initialization options
*/
export class BingMapsImageryProvider {
  constructor(options: BingMapsImageryProvider.ConstructorOptions);
  /**
   * The default alpha blending value of this provider, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  defaultAlpha: number | undefined;
  /**
   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  defaultNightAlpha: number | undefined;
  /**
   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  defaultDayAlpha: number | undefined;
  /**
   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0
   * makes the imagery darker while greater than 1.0 makes it brighter.
   */
  defaultBrightness: number | undefined;
  /**
   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces
   * the contrast while greater than 1.0 increases it.
   */
  defaultContrast: number | undefined;
  /**
   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.
   */
  defaultHue: number | undefined;
  /**
   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the
   * saturation while greater than 1.0 increases it.
   */
  defaultSaturation: number | undefined;
  /**
   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.
   */
  defaultGamma: number | undefined;
  /**
   * The default texture minification filter to apply to this provider.
   */
  defaultMinificationFilter: TextureMinificationFilter;
  /**
   * The default texture magnification filter to apply to this provider.
   */
  defaultMagnificationFilter: TextureMagnificationFilter;
  /**
   * Gets the name of the BingMaps server url hosting the imagery.
   */
  readonly url: string;
  /**
   * Gets the proxy used by this provider.
   */
  readonly proxy: Proxy;
  /**
   * Gets the Bing Maps key.
   */
  readonly key: string;
  /**
   * Gets the type of Bing Maps imagery to load.
   */
  readonly mapStyle: BingMapsStyle;
  /**
   * The culture to use when requesting Bing Maps imagery. Not
   * all cultures are supported. See {@link http://msdn.microsoft.com/en-us/library/hh441729.aspx}
   * for information on the supported cultures.
   */
  readonly culture: string;
  /**
   * Gets the width of each tile, in pixels. This function should
   * not be called before {@link BingMapsImageryProvider#ready} returns true.
   */
  readonly tileWidth: number;
  /**
   * Gets the height of each tile, in pixels.  This function should
   * not be called before {@link BingMapsImageryProvider#ready} returns true.
   */
  readonly tileHeight: number;
  /**
   * Gets the maximum level-of-detail that can be requested.  This function should
   * not be called before {@link BingMapsImageryProvider#ready} returns true.
   */
  readonly maximumLevel: number | undefined;
  /**
   * Gets the minimum level-of-detail that can be requested.  This function should
   * not be called before {@link BingMapsImageryProvider#ready} returns true.
   */
  readonly minimumLevel: number;
  /**
   * Gets the tiling scheme used by this provider.  This function should
   * not be called before {@link BingMapsImageryProvider#ready} returns true.
   */
  readonly tilingScheme: TilingScheme;
  /**
   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
   * not be called before {@link BingMapsImageryProvider#ready} returns true.
   */
  readonly rectangle: Rectangle;
  /**
   * Gets the tile discard policy.  If not undefined, the discard policy is responsible
   * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
   * returns undefined, no tiles are filtered.  This function should
   * not be called before {@link BingMapsImageryProvider#ready} returns true.
   */
  readonly tileDiscardPolicy: TileDiscardPolicy;
  /**
   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
   * are passed an instance of {@link TileProviderError}.
   */
  readonly errorEvent: Event;
  /**
   * Gets a value indicating whether or not the provider is ready for use.
   */
  readonly ready: boolean;
  /**
   * Gets a promise that resolves to true when the provider is ready for use.
   */
  readonly readyPromise: Promise<boolean>;
  /**
   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
   * the source of the imagery.  This function should not be called before {@link BingMapsImageryProvider#ready} returns true.
   */
  readonly credit: Credit;
  /**
   * Gets a value indicating whether or not the images provided by this imagery provider
   * include an alpha channel.  If this property is false, an alpha channel, if present, will
   * be ignored.  If this property is true, any images without an alpha channel will be treated
   * as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage
   * and texture upload time.
   */
  readonly hasAlphaChannel: boolean;
  /**
   * Gets the credits to be displayed when a given tile is displayed.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level;
   * @returns The credits to be displayed when the tile is displayed.
   */
  getTileCredits(x: number, y: number, level: number): Credit[];
  /**
   * Requests the image for a given tile.  This function should
   * not be called before {@link BingMapsImageryProvider#ready} returns true.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level.
   * @param [request] - The request object. Intended for internal use only.
   * @returns A promise for the image that will resolve when the image is available, or
   *          undefined if there are too many active requests to the server, and the request should be retried later.
   */
  requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
  /**
   * Picking features is not currently supported by this imagery provider, so this function simply returns
   * undefined.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level.
   * @param longitude - The longitude at which to pick features.
   * @param latitude - The latitude at which to pick features.
   * @returns Undefined since picking is not supported.
   */
  pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): undefined;
  /**
   * Converts a tiles (x, y, level) position into a quadkey used to request an image
   * from a Bing Maps server.
   * @param x - The tile's x coordinate.
   * @param y - The tile's y coordinate.
   * @param level - The tile's zoom level.
   */
  tileXYToQuadKey(x: number, y: number, level: number): void;
  /**
   * Converts a tile's quadkey used to request an image from a Bing Maps server into the
   * (x, y, level) position.
   * @param quadkey - The tile's quad key
   */
  quadKeyToTileXY(quadkey: string): void;
  /**
   * Gets or sets the URL to the Bing logo for display in the credit.
   */
  logoUrl: string;
}

/**
* The types of imagery provided by Bing Maps.
*/
export enum BingMapsStyle {
  /**
   * Aerial imagery.
   */
  AERIAL = "Aerial",
  /**
   * Aerial imagery with a road overlay.
   */
  AERIAL_WITH_LABELS = "AerialWithLabels",
  /**
   * Aerial imagery with a road overlay.
   */
  AERIAL_WITH_LABELS_ON_DEMAND = "AerialWithLabelsOnDemand",
  /**
   * Roads without additional imagery.
   */
  ROAD = "Road",
  /**
   * Roads without additional imagery.
   */
  ROAD_ON_DEMAND = "RoadOnDemand",
  /**
   * A dark version of the road maps.
   */
  CANVAS_DARK = "CanvasDark",
  /**
   * A lighter version of the road maps.
   */
  CANVAS_LIGHT = "CanvasLight",
  /**
   * A grayscale version of the road maps.
   */
  CANVAS_GRAY = "CanvasGray",
  /**
   * Ordnance Survey imagery. This imagery is visible only for the London, UK area.
   */
  ORDNANCE_SURVEY = "OrdnanceSurvey",
  /**
   * Collins Bart imagery.
   */
  COLLINS_BART = "CollinsBart"
}

/**
* Determines how two pixels' values are combined.
*/
export enum BlendEquation {
  /**
   * Pixel values are added componentwise.  This is used in additive blending for translucency.
   */
  ADD = WebGLConstants.FUNC_ADD,
  /**
   * Pixel values are subtracted componentwise (source - destination).  This is used in alpha blending for translucency.
   */
  SUBTRACT = WebGLConstants.FUNC_SUBTRACT,
  /**
   * Pixel values are subtracted componentwise (destination - source).
   */
  REVERSE_SUBTRACT = WebGLConstants.FUNC_REVERSE_SUBTRACT,
  /**
   * Pixel values are given to the minimum function (min(source, destination)).
   *
   * This equation operates on each pixel color component.
   */
  MIN = WebGLConstants.MIN,
  /**
   * Pixel values are given to the maximum function (max(source, destination)).
   *
   * This equation operates on each pixel color component.
   */
  MAX = WebGLConstants.MAX
}

/**
* Determines how blending factors are computed.
*/
export enum BlendFunction {
  /**
   * The blend factor is zero.
   */
  ZERO = WebGLConstants.ZERO,
  /**
   * The blend factor is one.
   */
  ONE = WebGLConstants.ONE,
  /**
   * The blend factor is the source color.
   */
  SOURCE_COLOR = WebGLConstants.SRC_COLOR,
  /**
   * The blend factor is one minus the source color.
   */
  ONE_MINUS_SOURCE_COLOR = WebGLConstants.ONE_MINUS_SRC_COLOR,
  /**
   * The blend factor is the destination color.
   */
  DESTINATION_COLOR = WebGLConstants.DST_COLOR,
  /**
   * The blend factor is one minus the destination color.
   */
  ONE_MINUS_DESTINATION_COLOR = WebGLConstants.ONE_MINUS_DST_COLOR,
  /**
   * The blend factor is the source alpha.
   */
  SOURCE_ALPHA = WebGLConstants.SRC_ALPHA,
  /**
   * The blend factor is one minus the source alpha.
   */
  ONE_MINUS_SOURCE_ALPHA = WebGLConstants.ONE_MINUS_SRC_ALPHA,
  /**
   * The blend factor is the destination alpha.
   */
  DESTINATION_ALPHA = WebGLConstants.DST_ALPHA,
  /**
   * The blend factor is one minus the destination alpha.
   */
  ONE_MINUS_DESTINATION_ALPHA = WebGLConstants.ONE_MINUS_DST_ALPHA,
  /**
   * The blend factor is the constant color.
   */
  CONSTANT_COLOR = WebGLConstants.CONSTANT_COLOR,
  /**
   * The blend factor is one minus the constant color.
   */
  ONE_MINUS_CONSTANT_COLOR = WebGLConstants.ONE_MINUS_CONSTANT_COLOR,
  /**
   * The blend factor is the constant alpha.
   */
  CONSTANT_ALPHA = WebGLConstants.CONSTANT_ALPHA,
  /**
   * The blend factor is one minus the constant alpha.
   */
  ONE_MINUS_CONSTANT_ALPHA = WebGLConstants.ONE_MINUS_CONSTANT_ALPHA,
  /**
   * The blend factor is the saturated source alpha.
   */
  SOURCE_ALPHA_SATURATE = WebGLConstants.SRC_ALPHA_SATURATE
}

/**
* Determines how opaque and translucent parts of billboards, points, and labels are blended with the scene.
*/
export enum BlendOption {
  /**
   * The billboards, points, or labels in the collection are completely opaque.
   */
  OPAQUE = 0,
  /**
   * The billboards, points, or labels in the collection are completely translucent.
   */
  TRANSLUCENT = 1,
  /**
   * The billboards, points, or labels in the collection are both opaque and translucent.
   */
  OPAQUE_AND_TRANSLUCENT = 2
}

/**
 * The blending state combines {@link BlendEquation} and {@link BlendFunction} and the
 * <code>enabled</code> flag to define the full blending state for combining source and
 * destination fragments when rendering.
 * <p>
 * This is a helper when using custom render states with {@link Appearance#renderState}.
 * </p>
 */
export namespace BlendingState {
  /**
   * Blending is disabled.
   */
  const DISABLED: any;
  /**
   * Blending is enabled using alpha blending, <code>source(source.alpha) + destination(1 - source.alpha)</code>.
   */
  const ALPHA_BLEND: any;
  /**
   * Blending is enabled using alpha blending with premultiplied alpha, <code>source + destination(1 - source.alpha)</code>.
   */
  const PRE_MULTIPLIED_ALPHA_BLEND: any;
  /**
   * Blending is enabled using additive blending, <code>source(source.alpha) + destination</code>.
   */
  const ADDITIVE_BLEND: any;
}

/**
 * The camera is defined by a position, orientation, and view frustum.
 * <br /><br />
 * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.
 * <br /><br />
 * The viewing frustum is defined by 6 planes.
 * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
 * define the unit vector normal to the plane, and the w component is the distance of the
 * plane from the origin/camera position.
 * @example
 * // Create a camera looking down the negative z-axis, positioned at the origin,
 * // with a field of view of 60 degrees, and 1:1 aspect ratio.
 * const camera = new Cesium.Camera(scene);
 * camera.position = new Cesium.Cartesian3();
 * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());
 * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);
 * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;
 * camera.frustum.near = 1.0;
 * camera.frustum.far = 2.0;
 * @param scene - The scene.
 */
export class Camera {
  constructor(scene: Scene);
  /**
   * The position of the camera.
   */
  position: Cartesian3;
  /**
   * The view direction of the camera.
   */
  direction: Cartesian3;
  /**
   * The up direction of the camera.
   */
  up: Cartesian3;
  /**
   * The right direction of the camera.
   */
  right: Cartesian3;
  /**
   * The region of space in view.
   */
  frustum: PerspectiveFrustum | PerspectiveOffCenterFrustum | OrthographicFrustum;
  /**
   * The default amount to move the camera when an argument is not
   * provided to the move methods.
   */
  defaultMoveAmount: number;
  /**
   * The default amount to rotate the camera when an argument is not
   * provided to the look methods.
   */
  defaultLookAmount: number;
  /**
   * The default amount to rotate the camera when an argument is not
   * provided to the rotate methods.
   */
  defaultRotateAmount: number;
  /**
   * The default amount to move the camera when an argument is not
   * provided to the zoom methods.
   */
  defaultZoomAmount: number;
  /**
   * If set, the camera will not be able to rotate past this axis in either direction.
   */
  constrainedAxis: Cartesian3;
  /**
   * The factor multiplied by the the map size used to determine where to clamp the camera position
   * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.
   */
  maximumZoomFactor: number;
  /**
   * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.
   */
  percentageChanged: number;
  /**
   * The default rectangle the camera will view on creation.
   */
  DEFAULT_VIEW_RECTANGLE: Rectangle;
  /**
   * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.
   * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero
   * will move it further away from the extent, and a value less than zero will move it close to the extent.
   */
  DEFAULT_VIEW_FACTOR: number;
  /**
   * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.
   */
  DEFAULT_OFFSET: HeadingPitchRange;
  /**
   * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.
   */
  readonly transform: Matrix4;
  /**
   * Gets the inverse camera transform.
   */
  readonly inverseTransform: Matrix4;
  /**
   * Gets the view matrix.
   */
  readonly viewMatrix: Matrix4;
  /**
   * Gets the inverse view matrix.
   */
  readonly inverseViewMatrix: Matrix4;
  /**
   * Gets the {@link Cartographic} position of the camera, with longitude and latitude
   * expressed in radians and height in meters.  In 2D and Columbus View, it is possible
   * for the returned longitude and latitude to be outside the range of valid longitudes
   * and latitudes when the camera is outside the map.
   */
  readonly positionCartographic: Cartographic;
  /**
   * Gets the position of the camera in world coordinates.
   */
  readonly positionWC: Cartesian3;
  /**
   * Gets the view direction of the camera in world coordinates.
   */
  readonly directionWC: Cartesian3;
  /**
   * Gets the up direction of the camera in world coordinates.
   */
  readonly upWC: Cartesian3;
  /**
   * Gets the right direction of the camera in world coordinates.
   */
  readonly rightWC: Cartesian3;
  /**
   * Gets the camera heading in radians.
   */
  readonly heading: number;
  /**
   * Gets the camera pitch in radians.
   */
  readonly pitch: number;
  /**
   * Gets the camera roll in radians.
   */
  readonly roll: number;
  /**
   * Gets the event that will be raised at when the camera starts to move.
   */
  readonly moveStart: Event;
  /**
   * Gets the event that will be raised when the camera has stopped moving.
   */
  readonly moveEnd: Event;
  /**
   * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.
   */
  readonly changed: Event;
  /**
   * Sets the camera position, orientation and transform.
   * @example
   * // 1. Set position with a top-down view
   * viewer.camera.setView({
   *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)
   * });
   *
   * // 2 Set view with heading, pitch and roll
   * viewer.camera.setView({
   *     destination : cartesianPosition,
   *     orientation: {
   *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)
   *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)
   *         roll : 0.0                             // default value
   *     }
   * });
   *
   * // 3. Change heading, pitch and roll with the camera position remaining the same.
   * viewer.camera.setView({
   *     orientation: {
   *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)
   *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)
   *         roll : 0.0                             // default value
   *     }
   * });
   *
   *
   * // 4. View rectangle with a top-down view
   * viewer.camera.setView({
   *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)
   * });
   *
   * // 5. Set position with an orientation using unit vectors.
   * viewer.camera.setView({
   *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),
   *     orientation : {
   *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),
   *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)
   *     }
   * });
   * @param options - Object with the following properties:
   * @param [options.destination] - The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.
   * @param [options.orientation] - An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point
   * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive
   * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.
   * @param [options.endTransform] - Transform matrix representing the reference frame of the camera.
   * @param [options.convert] - Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.
   */
  setView(options: {
    destination?: Cartesian3 | Rectangle;
    orientation?: HeadingPitchRollValues | DirectionUp;
    endTransform?: Matrix4;
    convert?: boolean;
  }): void;
  /**
   * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set
   * the default view for the 3D scene.  The home view for 2D and columbus view shows the
   * entire map.
   * @param [duration] - The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}
   */
  flyHome(duration?: number): void;
  /**
   * Transform a vector or point from world coordinates to the camera's reference frame.
   * @param cartesian - The vector or point to transform.
   * @param [result] - The object onto which to store the result.
   * @returns The transformed vector or point.
   */
  worldToCameraCoordinates(cartesian: Cartesian4, result?: Cartesian4): Cartesian4;
  /**
   * Transform a point from world coordinates to the camera's reference frame.
   * @param cartesian - The point to transform.
   * @param [result] - The object onto which to store the result.
   * @returns The transformed point.
   */
  worldToCameraCoordinatesPoint(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
  /**
   * Transform a vector from world coordinates to the camera's reference frame.
   * @param cartesian - The vector to transform.
   * @param [result] - The object onto which to store the result.
   * @returns The transformed vector.
   */
  worldToCameraCoordinatesVector(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
  /**
   * Transform a vector or point from the camera's reference frame to world coordinates.
   * @param cartesian - The vector or point to transform.
   * @param [result] - The object onto which to store the result.
   * @returns The transformed vector or point.
   */
  cameraToWorldCoordinates(cartesian: Cartesian4, result?: Cartesian4): Cartesian4;
  /**
   * Transform a point from the camera's reference frame to world coordinates.
   * @param cartesian - The point to transform.
   * @param [result] - The object onto which to store the result.
   * @returns The transformed point.
   */
  cameraToWorldCoordinatesPoint(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
  /**
   * Transform a vector from the camera's reference frame to world coordinates.
   * @param cartesian - The vector to transform.
   * @param [result] - The object onto which to store the result.
   * @returns The transformed vector.
   */
  cameraToWorldCoordinatesVector(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
  /**
   * Translates the camera's position by <code>amount</code> along <code>direction</code>.
   * @param direction - The direction to move.
   * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
   */
  move(direction: Cartesian3, amount?: number): void;
  /**
   * Translates the camera's position by <code>amount</code> along the camera's view vector.
   * When in 2D mode, this will zoom in the camera instead of translating the camera's position.
   * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
   */
  moveForward(amount?: number): void;
  /**
   * Translates the camera's position by <code>amount</code> along the opposite direction
   * of the camera's view vector.
   * When in 2D mode, this will zoom out the camera instead of translating the camera's position.
   * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
   */
  moveBackward(amount?: number): void;
  /**
   * Translates the camera's position by <code>amount</code> along the camera's up vector.
   * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
   */
  moveUp(amount?: number): void;
  /**
   * Translates the camera's position by <code>amount</code> along the opposite direction
   * of the camera's up vector.
   * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
   */
  moveDown(amount?: number): void;
  /**
   * Translates the camera's position by <code>amount</code> along the camera's right vector.
   * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
   */
  moveRight(amount?: number): void;
  /**
   * Translates the camera's position by <code>amount</code> along the opposite direction
   * of the camera's right vector.
   * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
   */
  moveLeft(amount?: number): void;
  /**
   * Rotates the camera around its up vector by amount, in radians, in the opposite direction
   * of its right vector if not in 2D mode.
   * @param [amount] - The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
   */
  lookLeft(amount?: number): void;
  /**
   * Rotates the camera around its up vector by amount, in radians, in the direction
   * of its right vector if not in 2D mode.
   * @param [amount] - The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
   */
  lookRight(amount?: number): void;
  /**
   * Rotates the camera around its right vector by amount, in radians, in the direction
   * of its up vector if not in 2D mode.
   * @param [amount] - The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
   */
  lookUp(amount?: number): void;
  /**
   * Rotates the camera around its right vector by amount, in radians, in the opposite direction
   * of its up vector if not in 2D mode.
   * @param [amount] - The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
   */
  lookDown(amount?: number): void;
  /**
   * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>
   * @param axis - The axis to rotate around.
   * @param [angle] - The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
   */
  look(axis: Cartesian3, angle?: number): void;
  /**
   * Rotate the camera counter-clockwise around its direction vector by amount, in radians.
   * @param [amount] - The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
   */
  twistLeft(amount?: number): void;
  /**
   * Rotate the camera clockwise around its direction vector by amount, in radians.
   * @param [amount] - The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
   */
  twistRight(amount?: number): void;
  /**
   * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance
   * of the camera's position to the center of the camera's reference frame remains the same.
   * @param axis - The axis to rotate around given in world coordinates.
   * @param [angle] - The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
   */
  rotate(axis: Cartesian3, angle?: number): void;
  /**
   * Rotates the camera around the center of the camera's reference frame by angle downwards.
   * @param [angle] - The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
   */
  rotateDown(angle?: number): void;
  /**
   * Rotates the camera around the center of the camera's reference frame by angle upwards.
   * @param [angle] - The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
   */
  rotateUp(angle?: number): void;
  /**
   * Rotates the camera around the center of the camera's reference frame by angle to the right.
   * @param [angle] - The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
   */
  rotateRight(angle?: number): void;
  /**
   * Rotates the camera around the center of the camera's reference frame by angle to the left.
   * @param [angle] - The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
   */
  rotateLeft(angle?: number): void;
  /**
   * Zooms <code>amount</code> along the camera's view vector.
   * @param [amount] - The amount to move. Defaults to <code>defaultZoomAmount</code>.
   */
  zoomIn(amount?: number): void;
  /**
   * Zooms <code>amount</code> along the opposite direction of
   * the camera's view vector.
   * @param [amount] - The amount to move. Defaults to <code>defaultZoomAmount</code>.
   */
  zoomOut(amount?: number): void;
  /**
   * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and
   * Columbus view, this is the distance to the map.
   * @returns The magnitude of the position.
   */
  getMagnitude(): number;
  /**
   * Sets the camera position and orientation using a target and offset. The target must be given in
   * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.
   * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset
   * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.
   * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
   * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.
   *
   * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
   * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be
   * determined from the offset, the heading will be north.
   * @example
   * // 1. Using a cartesian offset
   * const center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);
   * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));
   *
   * // 2. Using a HeadingPitchRange offset
   * const center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);
   * const heading = Cesium.Math.toRadians(50.0);
   * const pitch = Cesium.Math.toRadians(-20.0);
   * const range = 5000.0;
   * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));
   * @param target - The target position in world coordinates.
   * @param offset - The offset from the target in the local east-north-up reference frame centered at the target.
   */
  lookAt(target: Cartesian3, offset: Cartesian3 | HeadingPitchRange): void;
  /**
   * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.
   * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset
   * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.
   * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
   * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.
   *
   * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the
   * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be
   * determined from the offset, the heading will be north.
   * @example
   * // 1. Using a cartesian offset
   * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));
   * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));
   *
   * // 2. Using a HeadingPitchRange offset
   * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));
   * const heading = Cesium.Math.toRadians(50.0);
   * const pitch = Cesium.Math.toRadians(-20.0);
   * const range = 5000.0;
   * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));
   * @param transform - The transformation matrix defining the reference frame.
   * @param [offset] - The offset from the target in a reference frame centered at the target.
   */
  lookAtTransform(transform: Matrix4, offset?: Cartesian3 | HeadingPitchRange): void;
  /**
   * Get the camera position needed to view a rectangle on an ellipsoid or map
   * @param rectangle - The rectangle to view.
   * @param [result] - The camera position needed to view the rectangle
   * @returns The camera position needed to view the rectangle
   */
  getRectangleCameraCoordinates(rectangle: Rectangle, result?: Cartesian3): Cartesian3;
  /**
   * Pick an ellipsoid or map.
   * @example
   * const canvas = viewer.scene.canvas;
   * const center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);
   * const ellipsoid = viewer.scene.globe.ellipsoid;
   * const result = viewer.camera.pickEllipsoid(center, ellipsoid);
   * @param windowPosition - The x and y coordinates of a pixel.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid to pick.
   * @param [result] - The object onto which to store the result.
   * @returns If the ellipsoid or map was picked,
   * returns the point on the surface of the ellipsoid or map in world
   * coordinates. If the ellipsoid or map was not picked, returns undefined.
   */
  pickEllipsoid(windowPosition: Cartesian2, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3 | undefined;
  /**
   * Create a ray from the camera position through the pixel at <code>windowPosition</code>
   * in world coordinates.
   * @param windowPosition - The x and y coordinates of a pixel.
   * @param [result] - The object onto which to store the result.
   * @returns Returns the {@link Cartesian3} position and direction of the ray, or undefined if the pick ray cannot be determined.
   */
  getPickRay(windowPosition: Cartesian2, result?: Ray): Ray | undefined;
  /**
   * Return the distance from the camera to the front of the bounding sphere.
   * @param boundingSphere - The bounding sphere in world coordinates.
   * @returns The distance to the bounding sphere.
   */
  distanceToBoundingSphere(boundingSphere: BoundingSphere): number;
  /**
   * Return the pixel size in meters.
   * @param boundingSphere - The bounding sphere in world coordinates.
   * @param drawingBufferWidth - The drawing buffer width.
   * @param drawingBufferHeight - The drawing buffer height.
   * @returns The pixel size in meters.
   */
  getPixelSize(boundingSphere: BoundingSphere, drawingBufferWidth: number, drawingBufferHeight: number): number;
  /**
   * Cancels the current camera flight and leaves the camera at its current location.
   * If no flight is in progress, this this function does nothing.
   */
  cancelFlight(): void;
  /**
   * Completes the current camera flight and moves the camera immediately to its final destination.
   * If no flight is in progress, this this function does nothing.
   */
  completeFlight(): void;
  /**
   * Flies the camera from its current position to a new position.
   * @example
   * // 1. Fly to a position with a top-down view
   * viewer.camera.flyTo({
   *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)
   * });
   *
   * // 2. Fly to a Rectangle with a top-down view
   * viewer.camera.flyTo({
   *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)
   * });
   *
   * // 3. Fly to a position with an orientation using unit vectors.
   * viewer.camera.flyTo({
   *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),
   *     orientation : {
   *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),
   *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)
   *     }
   * });
   *
   * // 4. Fly to a position with an orientation using heading, pitch and roll.
   * viewer.camera.flyTo({
   *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),
   *     orientation : {
   *         heading : Cesium.Math.toRadians(175.0),
   *         pitch : Cesium.Math.toRadians(-35.0),
   *         roll : 0.0
   *     }
   * });
   * @param options - Object with the following properties:
   * @param options.destination - The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.
   * @param [options.orientation] - An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point
   * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive
   * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.
   * @param [options.duration] - The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.
   * @param [options.complete] - The function to execute when the flight is complete.
   * @param [options.cancel] - The function to execute if the flight is cancelled.
   * @param [options.endTransform] - Transform matrix representing the reference frame the camera will be in when the flight is completed.
   * @param [options.maximumHeight] - The maximum height at the peak of the flight.
   * @param [options.pitchAdjustHeight] - If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.
   * @param [options.flyOverLongitude] - There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.
   * @param [options.flyOverLongitudeWeight] - Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.
   * @param [options.convert] - Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.
   * @param [options.easingFunction] - Controls how the time is interpolated over the duration of the flight.
   */
  // flyTo(options: {
  //   destination: Cartesian3 | Rectangle;
  //   orientation?: any;
  //   duration?: number;
  //   complete?: Camera.FlightCompleteCallback;
  //   cancel?: Camera.FlightCancelledCallback;
  //   endTransform?: Matrix4;
  //   maximumHeight?: number;
  //   pitchAdjustHeight?: number;
  //   flyOverLongitude?: number;
  //   flyOverLongitudeWeight?: number;
  //   convert?: boolean;
  //   easingFunction?: EasingFunction.Callback;
  // }): void;
  /**
   * Sets the camera so that the current view contains the provided bounding sphere.
   *
   * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
   * The heading and the pitch angles are defined in the local east-north-up reference frame.
   * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
   * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is
   * zero, a range will be computed such that the whole bounding sphere is visible.</p>
   *
   * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
   * target will be the range. The heading will be determined from the offset. If the heading cannot be
   * determined from the offset, the heading will be north.</p>
   * @param boundingSphere - The bounding sphere to view, in world coordinates.
   * @param [offset] - The offset from the target in the local east-north-up reference frame centered at the target.
   */
  viewBoundingSphere(boundingSphere: BoundingSphere, offset?: HeadingPitchRange): void;
  /**
   * Flies the camera to a location where the current view contains the provided bounding sphere.
   *
   * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
   * The heading and the pitch angles are defined in the local east-north-up reference frame.
   * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
   * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is
   * zero, a range will be computed such that the whole bounding sphere is visible.</p>
   *
   * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the
   * target will be the range. The heading will be aligned to local north.</p>
   * @param boundingSphere - The bounding sphere to view, in world coordinates.
   * @param [options] - Object with the following properties:
   * @param [options.duration] - The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.
   * @param [options.offset] - The offset from the target in the local east-north-up reference frame centered at the target.
   * @param [options.complete] - The function to execute when the flight is complete.
   * @param [options.cancel] - The function to execute if the flight is cancelled.
   * @param [options.endTransform] - Transform matrix representing the reference frame the camera will be in when the flight is completed.
   * @param [options.maximumHeight] - The maximum height at the peak of the flight.
   * @param [options.pitchAdjustHeight] - If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.
   * @param [options.flyOverLongitude] - There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.
   * @param [options.flyOverLongitudeWeight] - Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.
   * @param [options.easingFunction] - Controls how the time is interpolated over the duration of the flight.
   */
  // flyToBoundingSphere(boundingSphere: BoundingSphere, options?: {
  //   duration?: number;
  //   offset?: HeadingPitchRange;
  //   complete?: Camera.FlightCompleteCallback;
  //   cancel?: Camera.FlightCancelledCallback;
  //   endTransform?: Matrix4;
  //   maximumHeight?: number;
  //   pitchAdjustHeight?: number;
  //   flyOverLongitude?: number;
  //   flyOverLongitudeWeight?: number;
  //   easingFunction?: EasingFunction.Callback;
  // }): void;
  /**
   * Computes the approximate visible rectangle on the ellipsoid.
   * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid that you want to know the visible region.
   * @param [result] - The rectangle in which to store the result
   * @returns The visible rectangle or undefined if the ellipsoid isn't visible at all.
   */
  computeViewRectangle(ellipsoid?: Ellipsoid, result?: Rectangle): Rectangle | undefined;
  /**
   * Switches the frustum/projection to perspective.
   *
   * This function is a no-op in 2D which must always be orthographic.
   */
  switchToPerspectiveFrustum(): void;
  /**
   * Switches the frustum/projection to orthographic.
   *
   * This function is a no-op in 2D which will always be orthographic.
   */
  switchToOrthographicFrustum(): void;
}

export namespace Camera {
  /**
   * A function that will execute when a flight completes.
   */
  type FlightCompleteCallback = () => void;
  /**
   * A function that will execute when a flight is cancelled.
   */
  type FlightCancelledCallback = () => void;
}

/**
* Aggregates input events. For example, suppose the following inputs are received between frames:
* left mouse button down, mouse move, mouse move, left mouse button up. These events will be aggregated into
* one event with a start and end position of the mouse.
* @param [canvas = document] - The element to handle events for.
*/
export class CameraEventAggregator {
  constructor(canvas?: HTMLCanvasElement);
  /**
   * Gets the current mouse position.
   */
  currentMousePosition: Cartesian2;
  /**
   * Gets whether any mouse button is down, a touch has started, or the wheel has been moved.
   */
  anyButtonDown: boolean;
  /**
   * Gets if a mouse button down or touch has started and has been moved.
   * @param type - The camera event type.
   * @param [modifier] - The keyboard modifier.
   * @returns Returns <code>true</code> if a mouse button down or touch has started and has been moved; otherwise, <code>false</code>
   */
  isMoving(type: CameraEventType, modifier?: KeyboardEventModifier): boolean;
  /**
   * Gets the aggregated start and end position of the current event.
   * @param type - The camera event type.
   * @param [modifier] - The keyboard modifier.
   * @returns An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code>.
   */
  getMovement(type: CameraEventType, modifier?: KeyboardEventModifier): any;
  /**
   * Gets the start and end position of the last move event (not the aggregated event).
   * @param type - The camera event type.
   * @param [modifier] - The keyboard modifier.
   * @returns An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code> or <code>undefined</code>.
   */
  getLastMovement(type: CameraEventType, modifier?: KeyboardEventModifier): any | undefined;
  /**
   * Gets whether the mouse button is down or a touch has started.
   * @param type - The camera event type.
   * @param [modifier] - The keyboard modifier.
   * @returns Whether the mouse button is down or a touch has started.
   */
  isButtonDown(type: CameraEventType, modifier?: KeyboardEventModifier): boolean;
  /**
   * Gets the mouse position that started the aggregation.
   * @param type - The camera event type.
   * @param [modifier] - The keyboard modifier.
   * @returns The mouse position.
   */
  getStartMousePosition(type: CameraEventType, modifier?: KeyboardEventModifier): Cartesian2;
  /**
   * Gets the time the button was pressed or the touch was started.
   * @param type - The camera event type.
   * @param [modifier] - The keyboard modifier.
   * @returns The time the button was pressed or the touch was started.
   */
  getButtonPressTime(type: CameraEventType, modifier?: KeyboardEventModifier): Date;
  /**
   * Gets the time the button was released or the touch was ended.
   * @param type - The camera event type.
   * @param [modifier] - The keyboard modifier.
   * @returns The time the button was released or the touch was ended.
   */
  getButtonReleaseTime(type: CameraEventType, modifier?: KeyboardEventModifier): Date;
  /**
   * Signals that all of the events have been handled and the aggregator should be reset to handle new events.
   */
  reset(): void;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Removes mouse listeners held by this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * handler = handler && handler.destroy();
   */
  destroy(): void;
}

/**
* Enumerates the available input for interacting with the camera.
*/
export enum CameraEventType {
  /**
   * A left mouse button press followed by moving the mouse and releasing the button.
   */
  LEFT_DRAG = 0,
  /**
   * A right mouse button press followed by moving the mouse and releasing the button.
   */
  RIGHT_DRAG = 1,
  /**
   * A middle mouse button press followed by moving the mouse and releasing the button.
   */
  MIDDLE_DRAG = 2,
  /**
   * Scrolling the middle mouse button.
   */
  WHEEL = 3,
  /**
   * A two-finger touch on a touch surface.
   */
  PINCH = 4
}

/**
 * A classification primitive represents a volume enclosing geometry in the {@link Scene} to be highlighted.
 * <p>
 * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including
 * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
 * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
 * and match most of them and add a new geometry or appearance independently of each other.
 * Only {@link PerInstanceColorAppearance} with the same color across all instances is supported at this time when using
 * ClassificationPrimitive directly.
 * For full {@link Appearance} support when classifying terrain or 3D Tiles use {@link GroundPrimitive} instead.
 * </p>
 * <p>
 * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there
 * will be rendering artifacts for some viewing angles.
 * </p>
 * <p>
 * Valid geometries are {@link BoxGeometry}, {@link CylinderGeometry}, {@link EllipsoidGeometry}, {@link PolylineVolumeGeometry}, and {@link SphereGeometry}.
 * </p>
 * <p>
 * Geometries that follow the surface of the ellipsoid, such as {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry},
 * are also valid if they are extruded volumes; otherwise, they will not be rendered.
 * </p>
 * @param [options] - Object with the following properties:
 * @param [options.geometryInstances] - The geometry instances to render. This can either be a single instance or an array of length one.
 * @param [options.appearance] - The appearance used to render the primitive. Defaults to PerInstanceColorAppearance when GeometryInstances have a color attribute.
 * @param [options.show = true] - Determines if this primitive will be shown.
 * @param [options.vertexCacheOptimize = false] - When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
 * @param [options.interleave = false] - When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
 * @param [options.compressVertices = true] - When <code>true</code>, the geometry vertices are compressed, which will save memory.
 * @param [options.releaseGeometryInstances = true] - When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
 * @param [options.allowPicking = true] - When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
 * @param [options.asynchronous = true] - Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.
 * @param [options.classificationType = ClassificationType.BOTH] - Determines whether terrain, 3D Tiles or both will be classified.
 * @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
 * @param [options.debugShowShadowVolume = false] - For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on
 *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.
 */
export class ClassificationPrimitive {
  constructor(options?: {
    geometryInstances?: any[] | GeometryInstance;
    appearance?: Appearance;
    show?: boolean;
    vertexCacheOptimize?: boolean;
    interleave?: boolean;
    compressVertices?: boolean;
    releaseGeometryInstances?: boolean;
    allowPicking?: boolean;
    asynchronous?: boolean;
    classificationType?: ClassificationType;
    debugShowBoundingVolume?: boolean;
    debugShowShadowVolume?: boolean;
  });
  /**
   * The geometry instance rendered with this primitive.  This may
   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
   * is <code>true</code> when the primitive is constructed.
   * <p>
   * Changing this property after the primitive is rendered has no effect.
   * </p>
   * <p>
   * Because of the rendering technique used, all geometry instances must be the same color.
   * If there is an instance with a differing color, a <code>DeveloperError</code> will be thrown
   * on the first attempt to render.
   * </p>
   */
  readonly geometryInstances: any[] | GeometryInstance;
  /**
   * Determines if the primitive will be shown.  This affects all geometry
   * instances in the primitive.
   */
  show: boolean;
  /**
   * Determines whether terrain, 3D Tiles or both will be classified.
   */
  classificationType: ClassificationType;
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the bounding sphere for each draw command in the primitive.
   * </p>
   */
  debugShowBoundingVolume: boolean;
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the shadow volume for each geometry in the primitive.
   * </p>
   */
  debugShowShadowVolume: boolean;
  /**
   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
   */
  readonly vertexCacheOptimize: boolean;
  /**
   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
   */
  readonly interleave: boolean;
  /**
   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
   */
  readonly releaseGeometryInstances: boolean;
  /**
   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
   */
  readonly allowPicking: boolean;
  /**
   * Determines if the geometry instances will be created and batched on a web worker.
   */
  readonly asynchronous: boolean;
  /**
   * When <code>true</code>, geometry vertices are compressed, which will save memory.
   */
  readonly compressVertices: boolean;
  /**
   * Determines if the primitive is complete and ready to render.  If this property is
   * true, the primitive will be rendered the next time that {@link ClassificationPrimitive#update}
   * is called.
   */
  readonly ready: boolean;
  /**
   * Gets a promise that resolves when the primitive is ready to render.
   */
  readonly readyPromise: Promise<ClassificationPrimitive>;
  /**
   * Determines if ClassificationPrimitive rendering is supported.
   * @param scene - The scene.
   * @returns <code>true</code> if ClassificationPrimitives are supported; otherwise, returns <code>false</code>
   */
  isSupported(scene: Scene): boolean;
  /**
   * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
   * get the draw commands needed to render this primitive.
   * <p>
   * Do not call this function directly.  This is documented just to
   * list the exceptions that may be propagated when the scene is rendered:
   * </p>
   */
  update(): void;
  /**
   * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
   * @example
   * const attributes = primitive.getGeometryInstanceAttributes('an id');
   * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
   * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
   * @param id - The id of the {@link GeometryInstance}.
   * @returns The typed array in the attribute's format or undefined if the is no instance with id.
   */
  getGeometryInstanceAttributes(id: any): any;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <p>
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * </p>
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <p>
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * </p>
   * @example
   * e = e && e.destroy();
   */
  destroy(): void;
}

/**
* Whether a classification affects terrain, 3D Tiles or both.
*/
export enum ClassificationType {
  /**
   * Only terrain will be classified.
   */
  TERRAIN = 0,
  /**
   * Only 3D Tiles will be classified.
   */
  Cesium_3D_TILE = 1,
  /**
   * Both terrain and 3D Tiles will be classified.
   */
  BOTH = 2
}

/**
* A Plane in Hessian Normal form to be used with {@link ClippingPlaneCollection}.
* Compatible with mathematics functions in {@link Plane}
* @param normal - The plane's normal (normalized).
* @param distance - The shortest distance from the origin to the plane.  The sign of
* <code>distance</code> determines which side of the plane the origin
* is on.  If <code>distance</code> is positive, the origin is in the half-space
* in the direction of the normal; if negative, the origin is in the half-space
* opposite to the normal; if zero, the plane passes through the origin.
*/
export class ClippingPlane {
  constructor(normal: Cartesian3, distance: number);
  /**
   * The shortest distance from the origin to the plane.  The sign of
   * <code>distance</code> determines which side of the plane the origin
   * is on.  If <code>distance</code> is positive, the origin is in the half-space
   * in the direction of the normal; if negative, the origin is in the half-space
   * opposite to the normal; if zero, the plane passes through the origin.
   */
  distance: number;
  /**
   * The plane's normal.
   */
  normal: Cartesian3;
  /**
   * Create a ClippingPlane from a Plane object.
   * @param plane - The plane containing parameters to copy
   * @param [result] - The object on which to store the result
   * @returns The ClippingPlane generated from the plane's parameters.
   */
  fromPlane(plane: Plane, result?: ClippingPlane): ClippingPlane;
  /**
   * Clones the ClippingPlane without setting its ownership.
   * @param clippingPlane - The ClippingPlane to be cloned
   * @param [result] - The object on which to store the cloned parameters.
   * @returns a clone of the input ClippingPlane
   */
  clone(clippingPlane: ClippingPlane, result?: ClippingPlane): ClippingPlane;
}

/**
* Specifies a set of clipping planes. Clipping planes selectively disable rendering in a region on the
* outside of the specified list of {@link ClippingPlane} objects for a single gltf model, 3D Tileset, or the globe.
* <p>
* In general the clipping planes' coordinates are relative to the object they're attached to, so a plane with distance set to 0 will clip
* through the center of the object.
* </p>
* <p>
* For 3D Tiles, the root tile's transform is used to position the clipping planes. If a transform is not defined, the root tile's {@link Cesium3DTile#boundingSphere} is used instead.
* </p>
* @example
* // This clipping plane's distance is positive, which means its normal
* // is facing the origin. This will clip everything that is behind
* // the plane, which is anything with y coordinate < -5.
* const clippingPlanes = new Cesium.ClippingPlaneCollection({
*     planes : [
*         new Cesium.ClippingPlane(new Cesium.Cartesian3(0.0, 1.0, 0.0), 5.0)
*     ],
* });
* // Create an entity and attach the ClippingPlaneCollection to the model.
* const entity = viewer.entities.add({
*     position : Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, 10000),
*     model : {
*         uri : 'model.gltf',
*         minimumPixelSize : 128,
*         maximumScale : 20000,
*         clippingPlanes : clippingPlanes
*     }
* });
* viewer.zoomTo(entity);
* @param [options] - Object with the following properties:
* @param [options.planes = []] - An array of {@link ClippingPlane} objects used to selectively disable rendering on the outside of each plane.
* @param [options.enabled = true] - Determines whether the clipping planes are active.
* @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix specifying an additional transform relative to the clipping planes original coordinate system.
* @param [options.unionClippingRegions = false] - If true, a region will be clipped if it is on the outside of any plane in the collection. Otherwise, a region will only be clipped if it is on the outside of every plane.
* @param [options.edgeColor = Color.WHITE] - The color applied to highlight the edge along which an object is clipped.
* @param [options.edgeWidth = 0.0] - The width, in pixels, of the highlight applied to the edge along which an object is clipped.
*/
export class ClippingPlaneCollection {
  constructor(options?: {
    planes?: ClippingPlane[];
    enabled?: boolean;
    modelMatrix?: Matrix4;
    unionClippingRegions?: boolean;
    edgeColor?: Color;
    edgeWidth?: number;
  });
  /**
   * The 4x4 transformation matrix specifying an additional transform relative to the clipping planes
   * original coordinate system.
   */
  modelMatrix: Matrix4;
  /**
   * The color applied to highlight the edge along which an object is clipped.
   */
  edgeColor: Color;
  /**
   * The width, in pixels, of the highlight applied to the edge along which an object is clipped.
   */
  edgeWidth: number;
  /**
   * An event triggered when a new clipping plane is added to the collection.  Event handlers
   * are passed the new plane and the index at which it was added.
   */
  planeAdded: Event;
  /**
   * An event triggered when a new clipping plane is removed from the collection.  Event handlers
   * are passed the new plane and the index from which it was removed.
   */
  planeRemoved: Event;
  /**
   * Returns the number of planes in this collection.  This is commonly used with
   * {@link ClippingPlaneCollection#get} to iterate over all the planes
   * in the collection.
   */
  readonly length: number;
  /**
   * If true, a region will be clipped if it is on the outside of any plane in the
   * collection. Otherwise, a region will only be clipped if it is on the
   * outside of every plane.
   */
  unionClippingRegions: boolean;
  /**
   * If true, clipping will be enabled.
   */
  enabled: boolean;
  /**
   * Adds the specified {@link ClippingPlane} to the collection to be used to selectively disable rendering
   * on the outside of each plane. Use {@link ClippingPlaneCollection#unionClippingRegions} to modify
   * how modify the clipping behavior of multiple planes.
   * @param plane - The ClippingPlane to add to the collection.
   */
  add(plane: ClippingPlane): void;
  /**
   * Returns the plane in the collection at the specified index.  Indices are zero-based
   * and increase as planes are added.  Removing a plane shifts all planes after
   * it to the left, changing their indices.  This function is commonly used with
   * {@link ClippingPlaneCollection#length} to iterate over all the planes
   * in the collection.
   * @param index - The zero-based index of the plane.
   * @returns The ClippingPlane at the specified index.
   */
  get(index: number): ClippingPlane;
  /**
   * Checks whether this collection contains a ClippingPlane equal to the given ClippingPlane.
   * @param [clippingPlane] - The ClippingPlane to check for.
   * @returns true if this collection contains the ClippingPlane, false otherwise.
   */
  contains(clippingPlane?: ClippingPlane): boolean;
  /**
   * Removes the first occurrence of the given ClippingPlane from the collection.
   * @returns <code>true</code> if the plane was removed; <code>false</code> if the plane was not found in the collection.
   */
  remove(clippingPlane: ClippingPlane): boolean;
  /**
   * Removes all planes from the collection.
   */
  removeAll(): void;
  /**
   * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
   * build the resources for clipping planes.
   * <p>
   * Do not call this function directly.
   * </p>
   */
  update(): void;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * clippingPlanes = clippingPlanes && clippingPlanes.destroy();
   */
  destroy(): void;
}

/**
 * An expression for a style applied to a {@link Cesium3DTileset}.
 * <p>
 * Evaluates a conditions expression defined using the
 * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.
 * </p>
 * <p>
 * Implements the {@link StyleExpression} interface.
 * </p>
 * @example
 * const expression = new Cesium.ConditionsExpression({
 *     conditions : [
 *         ['${Area} > 10, 'color("#FF0000")'],
 *         ['${id} !== "1"', 'color("#00FF00")'],
 *         ['true', 'color("#FFFFFF")']
 *     ]
 * });
 * expression.evaluateColor(feature, result); // returns a Cesium.Color object
 * @param [conditionsExpression] - The conditions expression defined using the 3D Tiles Styling language.
 * @param [defines] - Defines in the style.
 */
export class ConditionsExpression {
  constructor(conditionsExpression?: any, defines?: any);
  /**
   * Gets the conditions expression defined in the 3D Tiles Styling language.
   */
  readonly conditionsExpression: any;
  /**
   * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of
   * the expression in the
   * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}
   * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript
   * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>
   * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,
   * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is
   * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.
   * @param feature - The feature whose properties may be used as variables in the expression.
   * @param [result] - The object onto which to store the result.
   * @returns The result of evaluating the expression.
   */
  evaluate(feature: Cesium3DTileFeature, result?: any): boolean | number | string | RegExp | Cartesian2 | Cartesian3 | Cartesian4 | Color;
  /**
   * Evaluates the result of a Color expression, using the values defined by a feature.
   * <p>
   * This is equivalent to {@link ConditionsExpression#evaluate} but always returns a {@link Color} object.
   * </p>
   * @param feature - The feature whose properties may be used as variables in the expression.
   * @param [result] - The object in which to store the result
   * @returns The modified result parameter or a new Color instance if one was not provided.
   */
  evaluateColor(feature: Cesium3DTileFeature, result?: Color): Color;
}

/**
 * The credit display is responsible for displaying credits on screen.
 * @example
 * const creditDisplay = new Cesium.CreditDisplay(creditContainer);
 * @param container - The HTML element where credits will be displayed
 * @param [delimiter = ' • '] - The string to separate text credits
 * @param [viewport = document.body] - The HTML element that will contain the credits popup
 */
export class CreditDisplay {
  constructor(container: HTMLElement, delimiter?: string, viewport?: HTMLElement);
  /**
   * The HTML element where credits will be displayed.
   */
  container: HTMLElement;
  /**
   * Adds a credit to the list of current credits to be displayed in the credit container
   * @param credit - The credit to display
   */
  addCredit(credit: Credit): void;
  /**
   * Adds credits that will persist until they are removed
   * @param credit - The credit to added to defaults
   */
  addDefaultCredit(credit: Credit): void;
  /**
   * Removes a default credit
   * @param credit - The credit to be removed from defaults
   */
  removeDefaultCredit(credit: Credit): void;
  /**
   * Updates the credit display before a new frame is rendered.
   */
  update(): void;
  /**
   * Resets the credit display to a beginning of frame state, clearing out current credits.
   */
  beginFrame(): void;
  /**
   * Sets the credit display to the end of frame state, displaying credits from the last frame in the credit container.
   */
  endFrame(): void;
  /**
   * Destroys the resources held by this object.  Destroying an object allows for deterministic
   * release of resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   */
  destroy(): void;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Gets or sets the Cesium logo credit.
   */
  CesiumCredit: Credit;
}

/**
* Determines which triangles, if any, are culled.
*/
export enum CullFace {
  /**
   * Front-facing triangles are culled.
   */
  FRONT = WebGLConstants.FRONT,
  /**
   * Back-facing triangles are culled.
   */
  BACK = WebGLConstants.BACK,
  /**
   * Both front-facing and back-facing triangles are culled.
   */
  FRONT_AND_BACK = WebGLConstants.FRONT_AND_BACK
}

/**
 * Draws the outline of the camera's view frustum.
 * @example
 * primitives.add(new Cesium.DebugCameraPrimitive({
 *   camera : camera,
 *   color : Cesium.Color.YELLOW
 * }));
 * @param options - Object with the following properties:
 * @param options.camera - The camera.
 * @param [options.frustumSplits] - Distances to the near and far planes of the camera frustums. This overrides the camera's frustum near and far values.
 * @param [options.color = Color.CYAN] - The color of the debug outline.
 * @param [options.updateOnChange = true] - Whether the primitive updates when the underlying camera changes.
 * @param [options.show = true] - Determines if this primitive will be shown.
 * @param [options.id] - A user-defined object to return when the instance is picked with {@link Scene#pick}.
 */
export class DebugCameraPrimitive {
  constructor(options: {
    camera: Camera;
    frustumSplits?: number[];
    color?: Color;
    updateOnChange?: boolean;
    show?: boolean;
    id?: any;
  });
  /**
   * Determines if this primitive will be shown.
   */
  show: boolean;
  /**
   * User-defined value returned when the primitive is picked.
   */
  id: any;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <p>
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * </p>
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <p>
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * </p>
   * @example
   * p = p && p.destroy();
   */
  destroy(): void;
}

/**
 * Determines the function used to compare two depths for the depth test.
 */
export enum DepthFunction {
  /**
   * The depth test never passes.
   */
  NEVER = WebGLConstants.NEVER,
  /**
   * The depth test passes if the incoming depth is less than the stored depth.
   */
  LESS = WebGLConstants.LESS,
  /**
   * The depth test passes if the incoming depth is equal to the stored depth.
   */
  EQUAL = WebGLConstants.EQUAL,
  /**
   * The depth test passes if the incoming depth is less than or equal to the stored depth.
   */
  LESS_OR_EQUAL = WebGLConstants.LEQUAL,
  /**
   * The depth test passes if the incoming depth is greater than the stored depth.
   */
  GREATER = WebGLConstants.GREATER,
  /**
   * The depth test passes if the incoming depth is not equal to the stored depth.
   */
  NOT_EQUAL = WebGLConstants.NOTEQUAL,
  /**
   * The depth test passes if the incoming depth is greater than or equal to the stored depth.
   */
  GREATER_OR_EQUAL = WebGLConstants.GEQUAL,
  /**
   * The depth test always passes.
   */
  ALWAYS = WebGLConstants.ALWAYS
}

/**
* A light that gets emitted in a single direction from infinitely far away.
* @param options - Object with the following properties:
* @param options.direction - The direction in which light gets emitted.
* @param [options.color = Color.WHITE] - The color of the light.
* @param [options.intensity = 1.0] - The intensity of the light.
*/
export class DirectionalLight {
  constructor(options: {
    direction: Cartesian3;
    color?: Color;
    intensity?: number;
  });
  /**
   * The direction in which light gets emitted.
   */
  direction: Cartesian3;
  /**
   * The color of the light.
   */
  color: Color;
  /**
   * The intensity of the light.
   */
  intensity: number;
}

/**
* A policy for discarding tile images that contain no data (and so aren't actually images).
* This policy discards {@link DiscardEmptyTileImagePolicy.EMPTY_IMAGE}, which is
* expected to be used in place of any empty tile images by the image loading code.
*/
export class DiscardEmptyTileImagePolicy {
  constructor();
  /**
   * Determines if the discard policy is ready to process images.
   * @returns True if the discard policy is ready to process images; otherwise, false.
   */
  isReady(): boolean;
  /**
   * Given a tile image, decide whether to discard that image.
   * @param image - An image to test.
   * @returns True if the image should be discarded; otherwise, false.
   */
  shouldDiscardImage(image: HTMLImageElement): boolean;
  /**
   * Default value for representing an empty image.
   */
  readonly EMPTY_IMAGE: HTMLImageElement;
}

/**
 * An expression for a style applied to a {@link Cesium3DTileset}.
 * <p>
 * Evaluates an expression defined using the
 * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.
 * </p>
 * <p>
 * Implements the {@link StyleExpression} interface.
 * </p>
 * @example
 * const expression = new Cesium.Expression('(regExp("^Chest").test(${County})) && (${YearBuilt} >= 1970)');
 * expression.evaluate(feature); // returns true or false depending on the feature's properties
 * @example
 * const expression = new Cesium.Expression('(${Temperature} > 90) ? color("red") : color("white")');
 * expression.evaluateColor(feature, result); // returns a Cesium.Color object
 * @param [expression] - The expression defined using the 3D Tiles Styling language.
 * @param [defines] - Defines in the style.
 */
export class Expression {
  constructor(expression?: string, defines?: any);
  /**
   * Gets the expression defined in the 3D Tiles Styling language.
   */
  readonly expression: string;
  /**
   * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of
   * the expression in the
   * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}
   * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript
   * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>
   * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,
   * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is
   * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.
   * @param feature - The feature whose properties may be used as variables in the expression.
   * @param [result] - The object onto which to store the result.
   * @returns The result of evaluating the expression.
   */
  evaluate(feature: Cesium3DTileFeature, result?: any): boolean | number | string | RegExp | Cartesian2 | Cartesian3 | Cartesian4 | Color;
  /**
   * Evaluates the result of a Color expression, optionally using the provided feature's properties.
   * <p>
   * This is equivalent to {@link Expression#evaluate} but always returns a {@link Color} object.
   * </p>
   * @param feature - The feature whose properties may be used as variables in the expression.
   * @param [result] - The object in which to store the result
   * @returns The modified result parameter or a new Color instance if one was not provided.
   */
  evaluateColor(feature: Cesium3DTileFeature, result?: Color): Color;
}

/**
* Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional
* performance improvements by rendering less geometry and dispatching less terrain requests.
*/
export class Fog {
  constructor();
  /**
   * <code>true</code> if fog is enabled, <code>false</code> otherwise.
   */
  enabled: boolean;
  /**
   * <code>true</code> if fog is renderable in shaders, <code>false</code> otherwise.
   * This allows to benefits from optimized tile loading strategy based on fog density without the actual visual rendering.
   */
  renderable: boolean;
  /**
   * A scalar that determines the density of the fog. Terrain that is in full fog are culled.
   * The density of the fog increases as this number approaches 1.0 and becomes less dense as it approaches zero.
   * The more dense the fog is, the more aggressively the terrain is culled. For example, if the camera is a height of
   * 1000.0m above the ellipsoid, increasing the value to 3.0e-3 will cause many tiles close to the viewer be culled.
   * Decreasing the value will push the fog further from the viewer, but decrease performance as more of the terrain is rendered.
   */
  density: number;
  /**
   * A factor used to increase the screen space error of terrain tiles when they are partially in fog. The effect is to reduce
   * the number of terrain tiles requested for rendering. If set to zero, the feature will be disabled. If the value is increased
   * for mountainous regions, less tiles will need to be requested, but the terrain meshes near the horizon may be a noticeably
   * lower resolution. If the value is increased in a relatively flat area, there will be little noticeable change on the horizon.
   */
  screenSpaceErrorFactor: number;
  /**
   * The minimum brightness of the fog color from lighting. A value of 0.0 can cause the fog to be completely black. A value of 1.0 will not affect
   * the brightness at all.
   */
  minimumBrightness: number;
}

/**
 * The globe rendered in the scene, including its terrain ({@link Globe#terrainProvider})
 * and imagery layers ({@link Globe#imageryLayers}).  Access the globe using {@link Scene#globe}.
 * @param [ellipsoid = Ellipsoid.WGS84] - Determines the size and shape of the
 * globe.
 */
export class Globe {
  constructor(ellipsoid?: Ellipsoid);
  /**
   * Determines if the globe will be shown.
   */
  show: boolean;
  /**
   * The maximum screen-space error used to drive level-of-detail refinement.  Higher
   * values will provide better performance but lower visual quality.
   */
  maximumScreenSpaceError: number;
  /**
   * The size of the terrain tile cache, expressed as a number of tiles.  Any additional
   * tiles beyond this number will be freed, as long as they aren't needed for rendering
   * this frame.  A larger number will consume more memory but will show detail faster
   * when, for example, zooming out and then back in.
   */
  tileCacheSize: number;
  /**
   * Gets or sets the number of loading descendant tiles that is considered "too many".
   * If a tile has too many loading descendants, that tile will be loaded and rendered before any of
   * its descendants are loaded and rendered. This means more feedback for the user that something
   * is happening at the cost of a longer overall load time. Setting this to 0 will cause each
   * tile level to be loaded successively, significantly increasing load time. Setting it to a large
   * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make
   * detail appear all at once after a long wait.
   */
  loadingDescendantLimit: number;
  /**
   * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.
   * Setting this to true optimizes the zoom-out experience and provides more detail in
   * newly-exposed areas when panning. The down side is that it requires loading more tiles.
   */
  preloadAncestors: boolean;
  /**
   * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.
   * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even
   * if they are culled. Setting this to true may provide a better panning experience at the
   * cost of loading more tiles.
   */
  preloadSiblings: boolean;
  /**
   * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not
   * highlighted at all. The alpha value is used to alpha blend with the tile's
   * actual color. Because terrain fill tiles do not represent the actual terrain surface,
   * it may be useful in some applications to indicate visually that they are not to be trusted.
   */
  fillHighlightColor: Color;
  /**
   * Enable lighting the globe with the scene's light source.
   */
  enableLighting: boolean;
  /**
   * A multiplier to adjust terrain lambert lighting.
   * This number is multiplied by the result of <code>czm_getLambertDiffuse</code> in GlobeFS.glsl.
   * This only takes effect when <code>enableLighting</code> is <code>true</code>.
   */
  lambertDiffuseMultiplier: number;
  /**
   * Enable dynamic lighting effects on atmosphere and fog. This only takes effect
   * when <code>enableLighting</code> is <code>true</code>.
   */
  dynamicAtmosphereLighting: boolean;
  /**
   * Whether dynamic atmosphere lighting uses the sun direction instead of the scene's
   * light direction. This only takes effect when <code>enableLighting</code> and
   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.
   */
  dynamicAtmosphereLightingFromSun: boolean;
  /**
   * Enable the ground atmosphere, which is drawn over the globe when viewed from a distance between <code>lightingFadeInDistance</code> and <code>lightingFadeOutDistance</code>.
   */
  showGroundAtmosphere: boolean;
  /**
   * The intensity of the light that is used for computing the ground atmosphere color.
   */
  atmosphereLightIntensity: number;
  /**
   * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the ground atmosphere.
   */
  atmosphereRayleighCoefficient: Cartesian3;
  /**
   * The Mie scattering coefficient used in the atmospheric scattering equations for the ground atmosphere.
   */
  atmosphereMieCoefficient: Cartesian3;
  /**
   * The Rayleigh scale height used in the atmospheric scattering equations for the ground atmosphere, in meters.
   */
  atmosphereRayleighScaleHeight: number;
  /**
   * The Mie scale height used in the atmospheric scattering equations for the ground atmosphere, in meters.
   */
  atmosphereMieScaleHeight: number;
  /**
   * The anisotropy of the medium to consider for Mie scattering.
   * <p>
   * Valid values are between -1.0 and 1.0.
   * </p>
   */
  atmosphereMieAnisotropy: number;
  /**
   * The distance where everything becomes lit. This only takes effect
   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.
   */
  lightingFadeOutDistance: number;
  /**
   * The distance where lighting resumes. This only takes effect
   * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.
   */
  lightingFadeInDistance: number;
  /**
   * The distance where the darkness of night from the ground atmosphere fades out to a lit ground atmosphere.
   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and
   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.
   */
  nightFadeOutDistance: number;
  /**
   * The distance where the darkness of night from the ground atmosphere fades in to an unlit ground atmosphere.
   * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and
   * <code>dynamicAtmosphereLighting</code> are <code>true</code>.
   */
  nightFadeInDistance: number;
  /**
   * True if an animated wave effect should be shown in areas of the globe
   * covered by water; otherwise, false.  This property is ignored if the
   * <code>terrainProvider</code> does not provide a water mask.
   */
  showWaterEffect: boolean;
  /**
   * True if primitives such as billboards, polylines, labels, etc. should be depth-tested
   * against the terrain surface, or false if such primitives should always be drawn on top
   * of terrain unless they're on the opposite side of the globe.  The disadvantage of depth
   * testing primitives against terrain is that slight numerical noise or terrain level-of-detail
   * switched can sometimes make a primitive that should be on the surface disappear underneath it.
   */
  depthTestAgainstTerrain: boolean;
  /**
   * Determines whether the globe casts or receives shadows from light sources. Setting the globe
   * to cast shadows may impact performance since the terrain is rendered again from the light's perspective.
   * Currently only terrain that is in view casts shadows. By default the globe does not cast shadows.
   */
  shadows: ShadowMode;
  /**
   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).
   * A hue shift of 1.0 indicates a complete rotation of the hues available.
   */
  atmosphereHueShift: number;
  /**
   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).
   * A saturation shift of -1.0 is monochrome.
   */
  atmosphereSaturationShift: number;
  /**
   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).
   * A brightness shift of -1.0 is complete darkness, which will let space show through.
   */
  atmosphereBrightnessShift: number;
  /**
   * A scalar used to exaggerate the terrain. Defaults to <code>1.0</code> (no exaggeration).
   * A value of <code>2.0</code> scales the terrain by 2x.
   * A value of <code>0.0</code> makes the terrain completely flat.
   * Note that terrain exaggeration will not modify any other primitive as they are positioned relative to the ellipsoid.
   */
  terrainExaggeration: number;
  /**
   * The height from which terrain is exaggerated. Defaults to <code>0.0</code> (scaled relative to ellipsoid surface).
   * Terrain that is above this height will scale upwards and terrain that is below this height will scale downwards.
   * Note that terrain exaggeration will not modify any other primitive as they are positioned relative to the ellipsoid.
   * If {@link Globe#terrainExaggeration} is <code>1.0</code> this value will have no effect.
   */
  terrainExaggerationRelativeHeight: number;
  /**
   * Whether to show terrain skirts. Terrain skirts are geometry extending downwards from a tile's edges used to hide seams between neighboring tiles.
   * Skirts are always hidden when the camera is underground or translucency is enabled.
   */
  showSkirts: boolean;
  /**
   * Whether to cull back-facing terrain. Back faces are not culled when the camera is underground or translucency is enabled.
   */
  backFaceCulling: boolean;
  /**
   * Gets an ellipsoid describing the shape of this globe.
   */
  ellipsoid: Ellipsoid;
  /**
   * Gets the collection of image layers that will be rendered on this globe.
   */
  imageryLayers: ImageryLayerCollection;
  /**
   * Gets an event that's raised when an imagery layer is added, shown, hidden, moved, or removed.
   */
  readonly imageryLayersUpdatedEvent: Event;
  /**
   * Returns <code>true</code> when the tile load queue is empty, <code>false</code> otherwise.  When the load queue is empty,
   * all terrain and imagery for the current view have been loaded.
   */
  readonly tilesLoaded: boolean;
  /**
   * Gets or sets the color of the globe when no imagery is available.
   */
  baseColor: Color;
  /**
   * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.
   */
  clippingPlanes: ClippingPlaneCollection;
  /**
   * A property specifying a {@link Rectangle} used to limit globe rendering to a cartographic area.
   * Defaults to the maximum extent of cartographic coordinates.
   */
  cartographicLimitRectangle: Rectangle;
  /**
   * The normal map to use for rendering waves in the ocean.  Setting this property will
   * only have an effect if the configured terrain provider includes a water mask.
   */
  oceanNormalMapUrl: string;
  /**
   * The terrain provider providing surface geometry for this globe.
   */
  terrainProvider: TerrainProvider;
  /**
   * Gets an event that's raised when the terrain provider is changed
   */
  readonly terrainProviderChanged: Event;
  /**
   * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,
   * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.
   */
  tileLoadProgressEvent: Event;
  /**
   * Gets or sets the material appearance of the Globe. 
   */
  material: Material | undefined;
  /**
   * The color to render the back side of the globe when the camera is underground or the globe is translucent,
   * blended with the globe color based on the camera's distance.
   * <br /><br />
   * To disable underground coloring, set <code>undergroundColor</code> to <code>undefined</code>.
   */
  undergroundColor: Color;
  /**
   * Gets or sets the near and far distance for blending {@link Globe#undergroundColor} with the globe color.
   * The alpha will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the alpha remains clamped to the nearest bound. If undefined,
   * the underground color will not be blended with the globe color.
   * <br /> <br />
   * When the camera is above the ellipsoid the distance is computed from the nearest
   * point on the ellipsoid instead of the camera's position.
   */
  undergroundColorAlphaByDistance: NearFarScalar;
  /**
   * Properties for controlling globe translucency.
   */
  translucency: GlobeTranslucency;
  /**
   * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.
   * @example
   * // find intersection of ray through a pixel and the globe
   * const ray = viewer.camera.getPickRay(windowCoordinates);
   * const intersection = globe.pick(ray, scene);
   * @param ray - The ray to test for intersection.
   * @param scene - The scene.
   * @param [result] - The object onto which to store the result.
   * @returns The intersection or <code>undefined</code> if none was found.
   */
  pick(ray: Ray, scene: Scene, result?: Cartesian3): Cartesian3 | undefined;
  /**
   * Get the height of the surface at a given cartographic.
   * @param cartographic - The cartographic for which to find the height.
   * @returns The height of the cartographic or undefined if it could not be found.
   */
  getHeight(cartographic: Cartographic): number | undefined;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * globe = globe && globe.destroy();
   */
  destroy(): void;
}

/**
 * A GroundPolylinePrimitive represents a polyline draped over the terrain or 3D Tiles in the {@link Scene}.
 * <p>
 * Only to be used with GeometryInstances containing {@link GroundPolylineGeometry}.
 * </p>
 * @example
 * // 1. Draw a polyline on terrain with a basic color material
 *
 * const instance = new Cesium.GeometryInstance({
 *   geometry : new Cesium.GroundPolylineGeometry({
 *      positions : Cesium.Cartesian3.fromDegreesArray([
 *          -112.1340164450331, 36.05494287836128,
 *          -112.08821010582645, 36.097804071380715
 *      ]),
 *      width : 4.0
 *   }),
 *   id : 'object returned when this instance is picked and to get/set per-instance attributes'
 * });
 *
 * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({
 *   geometryInstances : instance,
 *   appearance : new Cesium.PolylineMaterialAppearance()
 * }));
 *
 * // 2. Draw a looped polyline on terrain with per-instance color and a distance display condition.
 * // Distance display conditions for polylines on terrain are based on an approximate terrain height
 * // instead of true terrain height.
 *
 * const instance2 = new Cesium.GeometryInstance({
 *   geometry : new Cesium.GroundPolylineGeometry({
 *      positions : Cesium.Cartesian3.fromDegreesArray([
 *          -112.1340164450331, 36.05494287836128,
 *          -112.08821010582645, 36.097804071380715,
 *          -112.13296079730024, 36.168769146801104
 *      ]),
 *      loop : true,
 *      width : 4.0
 *   }),
 *   attributes : {
 *      color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('green').withAlpha(0.7)),
 *      distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(1000, 30000)
 *   },
 *   id : 'object returned when this instance is picked and to get/set per-instance attributes'
 * });
 *
 * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({
 *   geometryInstances : instance2,
 *   appearance : new Cesium.PolylineColorAppearance()
 * }));
 * @param [options] - Object with the following properties:
 * @param [options.geometryInstances] - GeometryInstances containing GroundPolylineGeometry
 * @param [options.appearance] - The Appearance used to render the polyline. Defaults to a white color {@link Material} on a {@link PolylineMaterialAppearance}.
 * @param [options.show = true] - Determines if this primitive will be shown.
 * @param [options.interleave = false] - When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
 * @param [options.releaseGeometryInstances = true] - When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
 * @param [options.allowPicking = true] - When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
 * @param [options.asynchronous = true] - Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.
 * @param [options.classificationType = ClassificationType.BOTH] - Determines whether terrain, 3D Tiles or both will be classified.
 * @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
 * @param [options.debugShowShadowVolume = false] - For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on creation to have effect.
 */
export class GroundPolylinePrimitive {
  constructor(options?: {
    geometryInstances?: any[] | GeometryInstance;
    appearance?: Appearance;
    show?: boolean;
    interleave?: boolean;
    releaseGeometryInstances?: boolean;
    allowPicking?: boolean;
    asynchronous?: boolean;
    classificationType?: ClassificationType;
    debugShowBoundingVolume?: boolean;
    debugShowShadowVolume?: boolean;
  });
  /**
   * The geometry instances rendered with this primitive. This may
   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
   * is <code>true</code> when the primitive is constructed.
   * <p>
   * Changing this property after the primitive is rendered has no effect.
   * </p>
   */
  readonly geometryInstances: any[] | GeometryInstance;
  /**
   * The {@link Appearance} used to shade this primitive. Each geometry
   * instance is shaded with the same appearance.  Some appearances, like
   * {@link PolylineColorAppearance} allow giving each instance unique
   * properties.
   */
  appearance: Appearance;
  /**
   * Determines if the primitive will be shown.  This affects all geometry
   * instances in the primitive.
   */
  show: boolean;
  /**
   * Determines whether terrain, 3D Tiles or both will be classified.
   */
  classificationType: ClassificationType;
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the bounding sphere for each draw command in the primitive.
   * </p>
   */
  debugShowBoundingVolume: boolean;
  /**
   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
   */
  readonly interleave: boolean;
  /**
   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
   */
  readonly releaseGeometryInstances: boolean;
  /**
   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
   */
  readonly allowPicking: boolean;
  /**
   * Determines if the geometry instances will be created and batched on a web worker.
   */
  readonly asynchronous: boolean;
  /**
   * Determines if the primitive is complete and ready to render.  If this property is
   * true, the primitive will be rendered the next time that {@link GroundPolylinePrimitive#update}
   * is called.
   */
  readonly ready: boolean;
  /**
   * Gets a promise that resolves when the primitive is ready to render.
   */
  readonly readyPromise: Promise<GroundPolylinePrimitive>;
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * If true, draws the shadow volume for each geometry in the primitive.
   * </p>
   */
  readonly debugShowShadowVolume: boolean;
  /**
   * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the
   * GroundPolylinePrimitive synchronously.
   * @returns A promise that will resolve once the terrain heights have been loaded.
   */
  initializeTerrainHeights(): Promise<void>;
  /**
   * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
   * get the draw commands needed to render this primitive.
   * <p>
   * Do not call this function directly.  This is documented just to
   * list the exceptions that may be propagated when the scene is rendered:
   * </p>
   */
  update(): void;
  /**
   * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
   * @example
   * const attributes = primitive.getGeometryInstanceAttributes('an id');
   * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
   * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
   * @param id - The id of the {@link GeometryInstance}.
   * @returns The typed array in the attribute's format or undefined if the is no instance with id.
   */
  getGeometryInstanceAttributes(id: any): any;
  /**
   * Checks if the given Scene supports GroundPolylinePrimitives.
   * GroundPolylinePrimitives require support for the WEBGL_depth_texture extension.
   * @param scene - The current scene.
   * @returns Whether or not the current scene supports GroundPolylinePrimitives.
   */
  isSupported(scene: Scene): boolean;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <p>
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * </p>
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <p>
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * </p>
   * @example
   * e = e && e.destroy();
   */
  destroy(): void;
}

/**
* A ground primitive represents geometry draped over terrain or 3D Tiles in the {@link Scene}.
* <p>
* A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including
* {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
* and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
* and match most of them and add a new geometry or appearance independently of each other.
* </p>
* <p>
* Support for the WEBGL_depth_texture extension is required to use GeometryInstances with different PerInstanceColors
* or materials besides PerInstanceColorAppearance.
* </p>
* <p>
* Textured GroundPrimitives were designed for notional patterns and are not meant for precisely mapping
* textures to terrain - for that use case, use {@link SingleTileImageryProvider}.
* </p>
* <p>
* For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there
* will be rendering artifacts for some viewing angles.
* </p>
* <p>
* Valid geometries are {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry}.
* </p>
* @example
* // Example 1: Create primitive with a single instance
* const rectangleInstance = new Cesium.GeometryInstance({
*   geometry : new Cesium.RectangleGeometry({
*     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)
*   }),
*   id : 'rectangle',
*   attributes : {
*     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)
*   }
* });
* scene.primitives.add(new Cesium.GroundPrimitive({
*   geometryInstances : rectangleInstance
* }));
*
* // Example 2: Batch instances
* const color = new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5); // Both instances must have the same color.
* const rectangleInstance = new Cesium.GeometryInstance({
*   geometry : new Cesium.RectangleGeometry({
*     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)
*   }),
*   id : 'rectangle',
*   attributes : {
*     color : color
*   }
* });
* const ellipseInstance = new Cesium.GeometryInstance({
*     geometry : new Cesium.EllipseGeometry({
*         center : Cesium.Cartesian3.fromDegrees(-105.0, 40.0),
*         semiMinorAxis : 300000.0,
*         semiMajorAxis : 400000.0
*     }),
*     id : 'ellipse',
*     attributes : {
*         color : color
*     }
* });
* scene.primitives.add(new Cesium.GroundPrimitive({
*   geometryInstances : [rectangleInstance, ellipseInstance]
* }));
* @param [options] - Object with the following properties:
* @param [options.geometryInstances] - The geometry instances to render.
* @param [options.appearance] - The appearance used to render the primitive. Defaults to a flat PerInstanceColorAppearance when GeometryInstances have a color attribute.
* @param [options.show = true] - Determines if this primitive will be shown.
* @param [options.vertexCacheOptimize = false] - When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
* @param [options.interleave = false] - When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
* @param [options.compressVertices = true] - When <code>true</code>, the geometry vertices are compressed, which will save memory.
* @param [options.releaseGeometryInstances = true] - When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
* @param [options.allowPicking = true] - When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
* @param [options.asynchronous = true] - Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.
* @param [options.classificationType = ClassificationType.BOTH] - Determines whether terrain, 3D Tiles or both will be classified.
* @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
* @param [options.debugShowShadowVolume = false] - For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on
*                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.
*/
export class GroundPrimitive {
  constructor(options?: {
    geometryInstances?: any[] | GeometryInstance;
    appearance?: Appearance;
    show?: boolean;
    vertexCacheOptimize?: boolean;
    interleave?: boolean;
    compressVertices?: boolean;
    releaseGeometryInstances?: boolean;
    allowPicking?: boolean;
    asynchronous?: boolean;
    classificationType?: ClassificationType;
    debugShowBoundingVolume?: boolean;
    debugShowShadowVolume?: boolean;
  });
  /**
   * The {@link Appearance} used to shade this primitive. Each geometry
   * instance is shaded with the same appearance.  Some appearances, like
   * {@link PerInstanceColorAppearance} allow giving each instance unique
   * properties.
   */
  appearance: Appearance;
  /**
   * The geometry instances rendered with this primitive.  This may
   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
   * is <code>true</code> when the primitive is constructed.
   * <p>
   * Changing this property after the primitive is rendered has no effect.
   * </p>
   */
  readonly geometryInstances: any[] | GeometryInstance;
  /**
   * Determines if the primitive will be shown.  This affects all geometry
   * instances in the primitive.
   */
  show: boolean;
  /**
   * Determines whether terrain, 3D Tiles or both will be classified.
   */
  classificationType: ClassificationType;
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the bounding sphere for each draw command in the primitive.
   * </p>
   */
  debugShowBoundingVolume: boolean;
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the shadow volume for each geometry in the primitive.
   * </p>
   */
  debugShowShadowVolume: boolean;
  /**
   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
   */
  readonly vertexCacheOptimize: boolean;
  /**
   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
   */
  readonly interleave: boolean;
  /**
   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
   */
  readonly releaseGeometryInstances: boolean;
  /**
   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
   */
  readonly allowPicking: boolean;
  /**
   * Determines if the geometry instances will be created and batched on a web worker.
   */
  readonly asynchronous: boolean;
  /**
   * When <code>true</code>, geometry vertices are compressed, which will save memory.
   */
  readonly compressVertices: boolean;
  /**
   * Determines if the primitive is complete and ready to render.  If this property is
   * true, the primitive will be rendered the next time that {@link GroundPrimitive#update}
   * is called.
   */
  readonly ready: boolean;
  /**
   * Gets a promise that resolves when the primitive is ready to render.
   */
  readonly readyPromise: Promise<GroundPrimitive>;
  /**
   * Determines if GroundPrimitive rendering is supported.
   * @param scene - The scene.
   * @returns <code>true</code> if GroundPrimitives are supported; otherwise, returns <code>false</code>
   */
  isSupported(scene: Scene): boolean;
  /**
   * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the
   * GroundPrimitive synchronously.
   * @returns A promise that will resolve once the terrain heights have been loaded.
   */
  initializeTerrainHeights(): Promise<void>;
  /**
   * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
   * get the draw commands needed to render this primitive.
   * <p>
   * Do not call this function directly.  This is documented just to
   * list the exceptions that may be propagated when the scene is rendered:
   * </p>
   */
  update(): void;
  /**
   * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
   * @example
   * const attributes = primitive.getGeometryInstanceAttributes('an id');
   * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
   * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
   * @param id - The id of the {@link GeometryInstance}.
   * @returns The typed array in the attribute's format or undefined if the is no instance with id.
   */
  getGeometryInstanceAttributes(id: any): any;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <p>
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * </p>
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <p>
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * </p>
   * @example
   * e = e && e.destroy();
   */
  destroy(): void;
  /**
   * Checks if the given Scene supports materials on GroundPrimitives.
   * Materials on GroundPrimitives require support for the WEBGL_depth_texture extension.
   * @param scene - The current scene.
   * @returns Whether or not the current scene supports materials on GroundPrimitives.
   */
  supportsMaterials(scene: Scene): boolean;
}

/**
* Represents the position relative to the terrain.
*/
export enum HeightReference {
  /**
   * The position is absolute.
   */
  NONE = 0,
  /**
   * The position is clamped to the terrain.
   */
  CLAMP_TO_GROUND = 1,
  /**
   * The position height is the height above the terrain.
   */
  RELATIVE_TO_GROUND = 2
}

/**
* The horizontal location of an origin relative to an object, e.g., a {@link Billboard}
* or {@link Label}.  For example, setting the horizontal origin to <code>LEFT</code>
* or <code>RIGHT</code> will display a billboard to the left or right (in screen space)
* of the anchor position.
* <br /><br />
* <div align='center'>
* <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />
* </div>
*/
export enum HorizontalOrigin {
  /**
   * The origin is at the horizontal center of the object.
   */
  CENTER = 0,
  /**
   * The origin is on the left side of the object.
   */
  LEFT = 1,
  /**
   * The origin is on the right side of the object.
   */
  RIGHT = -1
}

/**
 * An imagery layer that displays tiled image data from a single imagery provider
 * on a {@link Globe}.
 * @param imageryProvider - The imagery provider to use.
 * @param [options] - Object with the following properties:
 * @param [options.rectangle = imageryProvider.rectangle] - The rectangle of the layer.  This rectangle
 *        can limit the visible portion of the imagery provider.
 * @param [options.alpha = 1.0] - The alpha blending value of this layer, from 0.0 to 1.0.
 *                          This can either be a simple number or a function with the signature
 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
 *                          current frame state, this layer, and the x, y, and level coordinates of the
 *                          imagery tile for which the alpha is required, and it is expected to return
 *                          the alpha value to use for the tile.
 * @param [options.nightAlpha = 1.0] - The alpha blending value of this layer on the night side of the globe, from 0.0 to 1.0.
 *                          This can either be a simple number or a function with the signature
 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
 *                          current frame state, this layer, and the x, y, and level coordinates of the
 *                          imagery tile for which the alpha is required, and it is expected to return
 *                          the alpha value to use for the tile. This only takes effect when <code>enableLighting</code> is <code>true</code>.
 * @param [options.dayAlpha = 1.0] - The alpha blending value of this layer on the day side of the globe, from 0.0 to 1.0.
 *                          This can either be a simple number or a function with the signature
 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
 *                          current frame state, this layer, and the x, y, and level coordinates of the
 *                          imagery tile for which the alpha is required, and it is expected to return
 *                          the alpha value to use for the tile. This only takes effect when <code>enableLighting</code> is <code>true</code>.
 * @param [options.brightness = 1.0] - The brightness of this layer.  1.0 uses the unmodified imagery
 *                          color.  Less than 1.0 makes the imagery darker while greater than 1.0 makes it brighter.
 *                          This can either be a simple number or a function with the signature
 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
 *                          current frame state, this layer, and the x, y, and level coordinates of the
 *                          imagery tile for which the brightness is required, and it is expected to return
 *                          the brightness value to use for the tile.  The function is executed for every
 *                          frame and for every tile, so it must be fast.
 * @param [options.contrast = 1.0] - The contrast of this layer.  1.0 uses the unmodified imagery color.
 *                          Less than 1.0 reduces the contrast while greater than 1.0 increases it.
 *                          This can either be a simple number or a function with the signature
 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
 *                          current frame state, this layer, and the x, y, and level coordinates of the
 *                          imagery tile for which the contrast is required, and it is expected to return
 *                          the contrast value to use for the tile.  The function is executed for every
 *                          frame and for every tile, so it must be fast.
 * @param [options.hue = 0.0] - The hue of this layer.  0.0 uses the unmodified imagery color.
 *                          This can either be a simple number or a function with the signature
 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
 *                          current frame state, this layer, and the x, y, and level coordinates
 *                          of the imagery tile for which the hue is required, and it is expected to return
 *                          the contrast value to use for the tile.  The function is executed for every
 *                          frame and for every tile, so it must be fast.
 * @param [options.saturation = 1.0] - The saturation of this layer.  1.0 uses the unmodified imagery color.
 *                          Less than 1.0 reduces the saturation while greater than 1.0 increases it.
 *                          This can either be a simple number or a function with the signature
 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
 *                          current frame state, this layer, and the x, y, and level coordinates
 *                          of the imagery tile for which the saturation is required, and it is expected to return
 *                          the contrast value to use for the tile.  The function is executed for every
 *                          frame and for every tile, so it must be fast.
 * @param [options.gamma = 1.0] - The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.
 *                          This can either be a simple number or a function with the signature
 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
 *                          current frame state, this layer, and the x, y, and level coordinates of the
 *                          imagery tile for which the gamma is required, and it is expected to return
 *                          the gamma value to use for the tile.  The function is executed for every
 *                          frame and for every tile, so it must be fast.
 * @param [options.splitDirection = SplitDirection.NONE] - The {@link SplitDirection} split to apply to this layer.
 * @param [options.minificationFilter = TextureMinificationFilter.LINEAR] - The
 *                                    texture minification filter to apply to this layer. Possible values
 *                                    are <code>TextureMinificationFilter.LINEAR</code> and
 *                                    <code>TextureMinificationFilter.NEAREST</code>.
 * @param [options.magnificationFilter = TextureMagnificationFilter.LINEAR] - The
 *                                     texture minification filter to apply to this layer. Possible values
 *                                     are <code>TextureMagnificationFilter.LINEAR</code> and
 *                                     <code>TextureMagnificationFilter.NEAREST</code>.
 * @param [options.show = true] - True if the layer is shown; otherwise, false.
 * @param [options.maximumAnisotropy = maximum supported] - The maximum anisotropy level to use
 *        for texture filtering.  If this parameter is not specified, the maximum anisotropy supported
 *        by the WebGL stack will be used.  Larger values make the imagery look better in horizon
 *        views.
 * @param [options.minimumTerrainLevel] - The minimum terrain level-of-detail at which to show this imagery layer,
 *                 or undefined to show it at all levels.  Level zero is the least-detailed level.
 * @param [options.maximumTerrainLevel] - The maximum terrain level-of-detail at which to show this imagery layer,
 *                 or undefined to show it at all levels.  Level zero is the least-detailed level.
 * @param [options.cutoutRectangle] - Cartographic rectangle for cutting out a portion of this ImageryLayer.
 * @param [options.colorToAlpha] - Color to be used as alpha.
 * @param [options.colorToAlphaThreshold = 0.004] - Threshold for color-to-alpha.
 */
export class ImageryLayer {
  constructor(imageryProvider: ImageryProvider, options?: {
    rectangle?: Rectangle;
    alpha?: number | ((...params: any[]) => any);
    nightAlpha?: number | ((...params: any[]) => any);
    dayAlpha?: number | ((...params: any[]) => any);
    brightness?: number | ((...params: any[]) => any);
    contrast?: number | ((...params: any[]) => any);
    hue?: number | ((...params: any[]) => any);
    saturation?: number | ((...params: any[]) => any);
    gamma?: number | ((...params: any[]) => any);
    splitDirection?: SplitDirection | ((...params: any[]) => any);
    minificationFilter?: TextureMinificationFilter;
    magnificationFilter?: TextureMagnificationFilter;
    show?: boolean;
    maximumAnisotropy?: number;
    minimumTerrainLevel?: number;
    maximumTerrainLevel?: number;
    cutoutRectangle?: Rectangle;
    colorToAlpha?: Color;
    colorToAlphaThreshold?: number;
  });
  /**
   * The alpha blending value of this layer, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  alpha: number;
  /**
   * The alpha blending value of this layer on the night side of the globe, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque. This only takes effect when {@link Globe#enableLighting} is <code>true</code>.
   */
  nightAlpha: number;
  /**
   * The alpha blending value of this layer on the day side of the globe, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque. This only takes effect when {@link Globe#enableLighting} is <code>true</code>.
   */
  dayAlpha: number;
  /**
   * The brightness of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0
   * makes the imagery darker while greater than 1.0 makes it brighter.
   */
  brightness: number;
  /**
   * The contrast of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces
   * the contrast while greater than 1.0 increases it.
   */
  contrast: number;
  /**
   * The hue of this layer in radians. 0.0 uses the unmodified imagery color.
   */
  hue: number;
  /**
   * The saturation of this layer. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the
   * saturation while greater than 1.0 increases it.
   */
  saturation: number;
  /**
   * The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.
   */
  gamma: number;
  /**
   * The {@link SplitDirection} to apply to this layer.
   */
  splitDirection: SplitDirection;
  /**
   * The {@link TextureMinificationFilter} to apply to this layer.
   * Possible values are {@link TextureMinificationFilter.LINEAR} (the default)
   * and {@link TextureMinificationFilter.NEAREST}.
   *
   * To take effect, this property must be set immediately after adding the imagery layer.
   * Once a texture is loaded it won't be possible to change the texture filter used.
   */
  minificationFilter: TextureMinificationFilter;
  /**
   * The {@link TextureMagnificationFilter} to apply to this layer.
   * Possible values are {@link TextureMagnificationFilter.LINEAR} (the default)
   * and {@link TextureMagnificationFilter.NEAREST}.
   *
   * To take effect, this property must be set immediately after adding the imagery layer.
   * Once a texture is loaded it won't be possible to change the texture filter used.
   */
  magnificationFilter: TextureMagnificationFilter;
  /**
   * Determines if this layer is shown.
   */
  show: boolean;
  /**
   * Rectangle cutout in this layer of imagery.
   */
  cutoutRectangle: Rectangle;
  /**
   * Color value that should be set to transparent.
   */
  colorToAlpha: Color;
  /**
   * Normalized (0-1) threshold for color-to-alpha.
   */
  colorToAlphaThreshold: number;
  /**
   * Gets the imagery provider for this layer.
   */
  readonly imageryProvider: ImageryProvider;
  /**
   * Gets the rectangle of this layer.  If this rectangle is smaller than the rectangle of the
   * {@link ImageryProvider}, only a portion of the imagery provider is shown.
   */
  readonly rectangle: Rectangle;
  /**
   * This value is used as the default brightness for the imagery layer if one is not provided during construction
   * or by the imagery provider. This value does not modify the brightness of the imagery.
   */
  DEFAULT_BRIGHTNESS: number;
  /**
   * This value is used as the default contrast for the imagery layer if one is not provided during construction
   * or by the imagery provider. This value does not modify the contrast of the imagery.
   */
  DEFAULT_CONTRAST: number;
  /**
   * This value is used as the default hue for the imagery layer if one is not provided during construction
   * or by the imagery provider. This value does not modify the hue of the imagery.
   */
  DEFAULT_HUE: number;
  /**
   * This value is used as the default saturation for the imagery layer if one is not provided during construction
   * or by the imagery provider. This value does not modify the saturation of the imagery.
   */
  DEFAULT_SATURATION: number;
  /**
   * This value is used as the default gamma for the imagery layer if one is not provided during construction
   * or by the imagery provider. This value does not modify the gamma of the imagery.
   */
  DEFAULT_GAMMA: number;
  /**
   * This value is used as the default split for the imagery layer if one is not provided during construction
   * or by the imagery provider.
   */
  DEFAULT_SPLIT: SplitDirection;
  /**
   * This value is used as the default texture minification filter for the imagery layer if one is not provided
   * during construction or by the imagery provider.
   */
  DEFAULT_MINIFICATION_FILTER: TextureMinificationFilter;
  /**
   * This value is used as the default texture magnification filter for the imagery layer if one is not provided
   * during construction or by the imagery provider.
   */
  DEFAULT_MAGNIFICATION_FILTER: TextureMagnificationFilter;
  /**
   * This value is used as the default threshold for color-to-alpha if one is not provided
   * during construction or by the imagery provider.
   */
  DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD: number;
  /**
   * Gets a value indicating whether this layer is the base layer in the
   * {@link ImageryLayerCollection}.  The base layer is the one that underlies all
   * others.  It is special in that it is treated as if it has global rectangle, even if
   * it actually does not, by stretching the texels at the edges over the entire
   * globe.
   * @returns true if this is the base layer; otherwise, false.
   */
  isBaseLayer(): boolean;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * imageryLayer = imageryLayer && imageryLayer.destroy();
   */
  destroy(): void;
  /**
   * Computes the intersection of this layer's rectangle with the imagery provider's availability rectangle,
   * producing the overall bounds of imagery that can be produced by this layer.
   * @example
   * // Zoom to an imagery layer.
   * imageryLayer.getViewableRectangle().then(function (rectangle) {
   *     return camera.flyTo({
   *         destination: rectangle
   *     });
   * });
   * @returns A promise to a rectangle which defines the overall bounds of imagery that can be produced by this layer.
   */
  getViewableRectangle(): Promise<Rectangle>;
}

/**
* An ordered collection of imagery layers.
*/
type ImageryLayerCollection = {
  /**
   * An event that is raised when a layer is added to the collection.  Event handlers are passed the layer that
   * was added and the index at which it was added.
   */
  layerAdded: Event;
  /**
   * An event that is raised when a layer is removed from the collection.  Event handlers are passed the layer that
   * was removed and the index from which it was removed.
   */
  layerRemoved: Event;
  /**
   * An event that is raised when a layer changes position in the collection.  Event handlers are passed the layer that
   * was moved, its new index after the move, and its old index prior to the move.
   */
  layerMoved: Event;
  /**
   * An event that is raised when a layer is shown or hidden by setting the
   * {@link ImageryLayer#show} property.  Event handlers are passed a reference to this layer,
   * the index of the layer in the collection, and a flag that is true if the layer is now
   * shown or false if it is now hidden.
   */
  layerShownOrHidden: Event;
  /**
   * Gets the number of layers in this collection.
   */
  length: number;
  /**
   * Adds a layer to the collection.
   * @param layer - the layer to add.
   * @param [index] - the index to add the layer at.  If omitted, the layer will
   *                         be added on top of all existing layers.
   */
  add(layer: ImageryLayer, index?: number): void;
  /**
   * 用给定的ImageryProvider创建一个新层，并将其添加到集合中.
   * @param imageryProvider - 图像提供程序创建一个新层.
   * @param [index] - 添加图层的索引。如果省略，该层将添加到所有现有层的顶部.
   * @returns 新创建的图层.
   */
  addImageryProvider(imageryProvider: ImageryProvider, index?: number): ImageryLayer;
  /**
   * Removes a layer from this collection, if present.
   * @param layer - The layer to remove.
   * @param [destroy = true] - whether to destroy the layers in addition to removing them.
   * @returns true if the layer was in the collection and was removed,
   *                    false if the layer was not in the collection.
   */
  remove(layer: ImageryLayer, destroy?: boolean): boolean;
  /**
   * Removes all layers from this collection.
   * @param [destroy = true] - whether to destroy the layers in addition to removing them.
   */
  removeAll(destroy?: boolean): void;
  /**
   * Checks to see if the collection contains a given layer.
   * @param layer - the layer to check for.
   * @returns true if the collection contains the layer, false otherwise.
   */
  contains(layer: ImageryLayer): boolean;
  /**
   * Determines the index of a given layer in the collection.
   * @param layer - The layer to find the index of.
   * @returns The index of the layer in the collection, or -1 if the layer does not exist in the collection.
   */
  indexOf(layer: ImageryLayer): number;
  /**
   * Gets a layer by index from the collection.
   * @param index - the index to retrieve.
   * @returns The imagery layer at the given index.
   */
  get(index: number): ImageryLayer;
  /**
   * Raises a layer up one position in the collection.
   * @param layer - the layer to move.
   */
  raise(layer: ImageryLayer): void;
  /**
   * Lowers a layer down one position in the collection.
   * @param layer - the layer to move.
   */
  lower(layer: ImageryLayer): void;
  /**
   * Raises a layer to the top of the collection.
   * @param layer - the layer to move.
   */
  raiseToTop(layer: ImageryLayer): void;
  /**
   * Lowers a layer to the bottom of the collection.
   * @param layer - the layer to move.
   */
  lowerToBottom(layer: ImageryLayer): void;
  /**
   * Determines the imagery layers that are intersected by a pick ray. To compute a pick ray from a
   * location on the screen, use {@link Camera.getPickRay}.
   * @param ray - The ray to test for intersection.
   * @param scene - The scene.
   * @returns An array that includes all of
   *                                 the layers that are intersected by a given pick ray. Undefined if
   *                                 no layers are selected.
   */
  pickImageryLayers(ray: Ray, scene: Scene): ImageryLayer[] | undefined;
  /**
   * Asynchronously determines the imagery layer features that are intersected by a pick ray.  The intersected imagery
   * layer features are found by invoking {@link ImageryProvider#pickFeatures} for each imagery layer tile intersected
   * by the pick ray.  To compute a pick ray from a location on the screen, use {@link Camera.getPickRay}.
   * @example
   * const pickRay = viewer.camera.getPickRay(windowPosition);
   * const featuresPromise = viewer.imageryLayers.pickImageryLayerFeatures(pickRay, viewer.scene);
   * if (!Cesium.defined(featuresPromise)) {
   *     console.log('No features picked.');
   * } else {
   *     Promise.resolve(featuresPromise).then(function(features) {
   *         // This function is called asynchronously when the list if picked features is available.
   *         console.log('Number of features: ' + features.length);
   *         if (features.length > 0) {
   *             console.log('First feature name: ' + features[0].name);
   *         }
   *     });
   * }
   * @param ray - The ray to test for intersection.
   * @param scene - The scene.
   * @returns A promise that resolves to an array of features intersected by the pick ray.
   *                                             If it can be quickly determined that no features are intersected (for example,
   *                                             because no active imagery providers support {@link ImageryProvider#pickFeatures}
   *                                             or because the pick ray does not intersect the surface), this function will
   *                                             return undefined.
   */
  pickImageryLayerFeatures(ray: Ray, scene: Scene): Promise<ImageryLayerFeatureInfo[]> | undefined;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns true if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by all layers in this collection.  Explicitly destroying this
   * object allows for deterministic release of WebGL resources, instead of relying on the garbage
   * collector.
   * <br /><br />
   * Once this object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * layerCollection = layerCollection && layerCollection.destroy();
   */
  destroy(): void;
}

/**
 * A Label draws viewport-aligned text positioned in the 3D scene.  This constructor
 * should not be used directly, instead create labels by calling {@link LabelCollection#add}.
 */
export class Label {
  constructor();
  /**
   * Determines if this label will be shown.  Use this to hide or show a label, instead
   * of removing it and re-adding it to the collection.
   */
  show: boolean;
  /**
   * Gets or sets the Cartesian position of this label.
   */
  position: Cartesian3;
  /**
   * Gets or sets the height reference of this billboard.
   */
  heightReference: HeightReference;
  /**
   * Gets or sets the text of this label.
   */
  text: string;
  /**
   * Gets or sets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.
   */
  font: string;
  /**
   * Gets or sets the fill color of this label.
   */
  fillColor: Color;
  /**
   * Gets or sets the outline color of this label.
   */
  outlineColor: Color;
  /**
   * Gets or sets the outline width of this label.
   */
  outlineWidth: number;
  /**
   * Determines if a background behind this label will be shown.
   */
  showBackground: boolean;
  /**
   * Gets or sets the background color of this label.
   */
  backgroundColor: Color;
  /**
   * Gets or sets the background padding, in pixels, of this label.  The <code>x</code> value
   * controls horizontal padding, and the <code>y</code> value controls vertical padding.
   */
  backgroundPadding: Cartesian2;
  /**
   * Gets or sets the style of this label.
   */
  style: LabelStyle;
  /**
   * Gets or sets the pixel offset in screen space from the origin of this label.  This is commonly used
   * to align multiple labels and billboards at the same position, e.g., an image and text.  The
   * screen space origin is the top, left corner of the canvas; <code>x</code> increases from
   * left to right, and <code>y</code> increases from top to bottom.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
   * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
   * </tr></table>
   * The label's origin is indicated by the yellow point.
   * </div>
   */
  pixelOffset: Cartesian2;
  /**
   * Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.
   * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's translucency remains clamped to the nearest bound.  If undefined,
   * translucencyByDistance will be disabled.
   * @example
   * // Example 1.
   * // Set a label's translucencyByDistance to 1.0 when the
   * // camera is 1500 meters from the label and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * text.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
   * @example
   * // Example 2.
   * // disable translucency by distance
   * text.translucencyByDistance = undefined;
   */
  translucencyByDistance: NearFarScalar;
  /**
   * Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.
   * A label's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's pixel offset scaling remains clamped to the nearest bound.  If undefined,
   * pixelOffsetScaleByDistance will be disabled.
   * @example
   * // Example 1.
   * // Set a label's pixel offset scale to 0.0 when the
   * // camera is 1500 meters from the label and scale pixel offset to 10.0 pixels
   * // in the y direction the camera distance approaches 8.0e6 meters.
   * text.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);
   * text.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);
   * @example
   * // Example 2.
   * // disable pixel offset by distance
   * text.pixelOffsetScaleByDistance = undefined;
   */
  pixelOffsetScaleByDistance: NearFarScalar;
  /**
   * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.
   * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,
   * scaleByDistance will be disabled.
   * @example
   * // Example 1.
   * // Set a label's scaleByDistance to scale by 1.5 when the
   * // camera is 1500 meters from the label and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * label.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);
   * @example
   * // Example 2.
   * // disable scaling by distance
   * label.scaleByDistance = undefined;
   */
  scaleByDistance: NearFarScalar;
  /**
   * Gets and sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed
   * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
   * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
   * which is typically meters.
   * <br /><br />
   * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to
   * arrange a label above its corresponding 3D model.
   * <br /><br />
   * Below, the label is positioned at the center of the Earth but an eye offset makes it always
   * appear on top of the Earth regardless of the viewer's or Earth's orientation.
   * <br /><br />
   * <div align='center'>
   * <table border='0' cellpadding='5'><tr>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
   * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
   * </tr></table>
   * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
   * </div>
   */
  eyeOffset: Cartesian3;
  /**
   * Gets or sets the horizontal origin of this label, which determines if the label is drawn
   * to the left, center, or right of its anchor position.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />
   * </div>
   * @example
   * // Use a top, right origin
   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;
   */
  horizontalOrigin: HorizontalOrigin;
  /**
   * Gets or sets the vertical origin of this label, which determines if the label is
   * to the above, below, or at the center of its anchor position.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />
   * </div>
   * @example
   * // Use a top, right origin
   * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
   * l.verticalOrigin = Cesium.VerticalOrigin.TOP;
   */
  verticalOrigin: VerticalOrigin;
  /**
   * Gets or sets the uniform scale that is multiplied with the label's size in pixels.
   * A scale of <code>1.0</code> does not change the size of the label; a scale greater than
   * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks
   * the label.
   * <br /><br />
   * Applying a large scale value may pixelate the label.  To make text larger without pixelation,
   * use a larger font size when calling {@link Label#font} instead.
   * <br /><br />
   * <div align='center'>
   * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>
   * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
   * and <code>2.0</code>.
   * </div>
   */
  scale: number;
  /**
   * Gets the total scale of the label, which is the label's scale multiplied by the computed relative size
   * of the desired font compared to the generated glyph size.
   */
  totalScale: number;
  /**
   * Gets or sets the condition specifying at what distance from the camera that this label will be displayed.
   */
  distanceDisplayCondition: DistanceDisplayCondition;
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   */
  disableDepthTestDistance: number;
  /**
   * Gets or sets the user-defined value returned when the label is picked.
   */
  id: any;
  /**
   * Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.
   * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from
   * left to right, and <code>y</code> increases from top to bottom.
   * @example
   * console.log(l.computeScreenSpacePosition(scene).toString());
   * @param scene - The scene the label is in.
   * @param [result] - The object onto which to store the result.
   * @returns The screen-space position of the label.
   */
  computeScreenSpacePosition(scene: Scene, result?: Cartesian2): Cartesian2;
  /**
   * Determines if this label equals another label.  Labels are equal if all their properties
   * are equal.  Labels in different collections can be equal.
   * @param other - The label to compare for equality.
   * @returns <code>true</code> if the labels are equal; otherwise, <code>false</code>.
   */
  equals(other: Label): boolean;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Determines whether or not run the algorithm, that match the text of the label to right-to-left languages
   * @example
   * // Example 1.
   * // Set a label's rightToLeft before init
   * Cesium.Label.enableRightToLeftDetection = true;
   * const myLabelEntity = viewer.entities.add({
   *   label: {
   *     id: 'my label',
   *     text: 'זה טקסט בעברית \n ועכשיו יורדים שורה',
   *   }
   * });
   * @example
   * // Example 2.
   * const myLabelEntity = viewer.entities.add({
   *   label: {
   *     id: 'my label',
   *     text: 'English text'
   *   }
   * });
   * // Set a label's rightToLeft after init
   * Cesium.Label.enableRightToLeftDetection = true;
   * myLabelEntity.text = 'טקסט חדש';
   */
  enableRightToLeftDetection: boolean;
}

/**
* A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.
* Each label can have a different font, color, scale, etc.
* <br /><br />
* <div align='center'>
* <img src='Images/Label.png' width='400' height='300' /><br />
* Example labels
* </div>
* <br /><br />
* Labels are added and removed from the collection using {@link LabelCollection#add}
* and {@link LabelCollection#remove}.
* @example
* // Create a label collection with two labels
* const labels = scene.primitives.add(new Cesium.LabelCollection());
* labels.add({
*   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),
*   text : 'A label'
* });
* labels.add({
*   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),
*   text : 'Another label'
* });
* @param [options] - Object with the following properties:
* @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms each label from model to world coordinates.
* @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
* @param [options.scene] - Must be passed in for labels that use the height reference property or will be depth tested against the globe.
* @param [options.blendOption = BlendOption.OPAQUE_AND_TRANSLUCENT] - The label blending option. The default
* is used for rendering both opaque and translucent labels. However, if either all of the labels are completely opaque or all are completely translucent,
* setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.
* @param [options.show = true] - Determines if the labels in the collection will be shown.
*/
export class LabelCollection {
  constructor(options?: {
    modelMatrix?: Matrix4;
    debugShowBoundingVolume?: boolean;
    scene?: Scene;
    blendOption?: BlendOption;
    show?: boolean;
  });
  /**
   * Determines if labels in this collection will be shown.
   */
  show: boolean;
  /**
   * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.
   * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
   * Local reference frames can be used by providing a different transformation matrix, like that returned
   * by {@link Transforms.eastNorthUpToFixedFrame}.
   * @example
   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
   * labels.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
   * labels.add({
   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0),
   *   text     : 'Center'
   * });
   * labels.add({
   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0),
   *   text     : 'East'
   * });
   * labels.add({
   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0),
   *   text     : 'North'
   * });
   * labels.add({
   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0),
   *   text     : 'Up'
   * });
   */
  modelMatrix: Matrix4;
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the bounding sphere for each draw command in the primitive.
   * </p>
   */
  debugShowBoundingVolume: boolean;
  /**
   * The label blending option. The default is used for rendering both opaque and translucent labels.
   * However, if either all of the labels are completely opaque or all are completely translucent,
   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve
   * performance by up to 2x.
   */
  blendOption: BlendOption;
  /**
   * Returns the number of labels in this collection.  This is commonly used with
   * {@link LabelCollection#get} to iterate over all the labels
   * in the collection.
   */
  length: number;
  /**
   * Creates and adds a label with the specified initial properties to the collection.
   * The added label is returned so it can be modified or removed from the collection later.
   * @example
   * // Example 1:  Add a label, specifying all the default values.
   * const l = labels.add({
   *   show : true,
   *   position : Cesium.Cartesian3.ZERO,
   *   text : '',
   *   font : '30px sans-serif',
   *   fillColor : Cesium.Color.WHITE,
   *   outlineColor : Cesium.Color.BLACK,
   *   outlineWidth : 1.0,
   *   showBackground : false,
   *   backgroundColor : new Cesium.Color(0.165, 0.165, 0.165, 0.8),
   *   backgroundPadding : new Cesium.Cartesian2(7, 5),
   *   style : Cesium.LabelStyle.FILL,
   *   pixelOffset : Cesium.Cartesian2.ZERO,
   *   eyeOffset : Cesium.Cartesian3.ZERO,
   *   horizontalOrigin : Cesium.HorizontalOrigin.LEFT,
   *   verticalOrigin : Cesium.VerticalOrigin.BASELINE,
   *   scale : 1.0,
   *   translucencyByDistance : undefined,
   *   pixelOffsetScaleByDistance : undefined,
   *   heightReference : HeightReference.NONE,
   *   distanceDisplayCondition : undefined
   * });
   * @example
   * // Example 2:  Specify only the label's cartographic position,
   * // text, and font.
   * const l = labels.add({
   *   position : Cesium.Cartesian3.fromRadians(longitude, latitude, height),
   *   text : 'Hello World',
   *   font : '24px Helvetica',
   * });
   * @param [options] - A template describing the label's properties as shown in Example 1.
   * @returns The label that was added to the collection.
   */
  add(options?: any): Label;
  /**
   * Removes a label from the collection.  Once removed, a label is no longer usable.
   * @example
   * const l = labels.add(...);
   * labels.remove(l);  // Returns true
   * @param label - The label to remove.
   * @returns <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.
   */
  remove(label: Label): boolean;
  /**
   * Removes all labels from the collection.
   * @example
   * labels.add(...);
   * labels.add(...);
   * labels.removeAll();
   */
  removeAll(): void;
  /**
   * Check whether this collection contains a given label.
   * @param label - The label to check for.
   * @returns true if this collection contains the label, false otherwise.
   */
  contains(label: Label): boolean;
  /**
   * Returns the label in the collection at the specified index.  Indices are zero-based
   * and increase as labels are added.  Removing a label shifts all labels after
   * it to the left, changing their indices.  This function is commonly used with
   * {@link LabelCollection#length} to iterate over all the labels
   * in the collection.
   * @example
   * // Toggle the show property of every label in the collection
   * const len = labels.length;
   * for (let i = 0; i < len; ++i) {
   *   const l = billboards.get(i);
   *   l.show = !l.show;
   * }
   * @param index - The zero-based index of the billboard.
   * @returns The label at the specified index.
   */
  get(index: number): Label;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * labels = labels && labels.destroy();
   */
  destroy(): void;
}

/**
* Describes how to draw a label.
*/
export enum LabelStyle {
  /**
   * Fill the text of the label, but do not outline.
   */
  FILL = 0,
  /**
   * Outline the text of the label, but do not fill.
   */
  OUTLINE = 1,
  /**
   * Fill and outline the text of the label.
   */
  FILL_AND_OUTLINE = 2
}

/**
 * Describes how the map will operate in 2D.
 */
export enum MapMode2D {
  /**
   * The 2D map can be rotated about the z axis.
   */
  ROTATE = 0,
  /**
   * The 2D map can be scrolled infinitely in the horizontal direction.
   */
  INFINITE_SCROLL = 1
}

/**
 * A Material defines surface appearance through a combination of diffuse, specular,
 * normal, emission, and alpha components. These values are specified using a
 * JSON schema called Fabric which gets parsed and assembled into glsl shader code
 * behind-the-scenes.
 * <br /><br />
 * <style type="text/css">
 *  #materialDescriptions code {
 *      font-weight: normal;
 *      font-family: Consolas, 'Lucida Console', Monaco, monospace;
 *      color: #A35A00;
 *  }
 *  #materialDescriptions ul, #materialDescriptions ul ul {
 *      list-style-type: none;
 *  }
 *  #materialDescriptions ul ul {
 *      margin-bottom: 10px;
 *  }
 *  #materialDescriptions ul ul li {
 *      font-weight: normal;
 *      color: #000000;
 *      text-indent: -2em;
 *      margin-left: 2em;
 *  }
 *  #materialDescriptions ul li {
 *      font-weight: bold;
 *      color: #0053CF;
 *  }
 * </style>
 *
 * Base material types and their uniforms:
 * <div id='materialDescriptions'>
 * <ul>
 *  <li>Color</li>
 *  <ul>
 *      <li><code>color</code>:  rgba color object.</li>
 *  </ul>
 *  <li>Image</li>
 *  <ul>
 *      <li><code>image</code>:  path to image.</li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 *  </ul>
 *  <li>DiffuseMap</li>
 *  <ul>
 *      <li><code>image</code>:  path to image.</li>
 *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels.</li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 *  </ul>
 *  <li>AlphaMap</li>
 *  <ul>
 *      <li><code>image</code>:  path to image.</li>
 *      <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 *  </ul>
 *  <li>SpecularMap</li>
 *  <ul>
 *      <li><code>image</code>: path to image.</li>
 *      <li><code>channel</code>: One character string containing r, g, b, or a for selecting the desired image channel. </li>
 *      <li><code>repeat</code>: Object with x and y values specifying the number of times to repeat the image.</li>
 *  </ul>
 *  <li>EmissionMap</li>
 *  <ul>
 *      <li><code>image</code>:  path to image.</li>
 *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 *  </ul>
 *  <li>BumpMap</li>
 *  <ul>
 *      <li><code>image</code>:  path to image.</li>
 *      <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 *      <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>
 *  </ul>
 *  <li>NormalMap</li>
 *  <ul>
 *      <li><code>image</code>:  path to image.</li>
 *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 *      <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>
 *  </ul>
 *  <li>Grid</li>
 *  <ul>
 *      <li><code>color</code>:  rgba color object for the whole material.</li>
 *      <li><code>cellAlpha</code>: Alpha value for the cells between grid lines.  This will be combined with color.alpha.</li>
 *      <li><code>lineCount</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>
 *      <li><code>lineThickness</code>:  Object with x and y values specifying the thickness of grid lines (in pixels where available).</li>
 *      <li><code>lineOffset</code>:  Object with x and y values specifying the offset of grid lines (range is 0 to 1).</li>
 *  </ul>
 *  <li>Stripe</li>
 *  <ul>
 *      <li><code>horizontal</code>:  Boolean that determines if the stripes are horizontal or vertical.</li>
 *      <li><code>evenColor</code>:  rgba color object for the stripe's first color.</li>
 *      <li><code>oddColor</code>:  rgba color object for the stripe's second color.</li>
 *      <li><code>offset</code>:  Number that controls at which point into the pattern to begin drawing; with 0.0 being the beginning of the even color, 1.0 the beginning of the odd color, 2.0 being the even color again, and any multiple or fractional values being in between.</li>
 *      <li><code>repeat</code>:  Number that controls the total number of stripes, half light and half dark.</li>
 *  </ul>
 *  <li>Checkerboard</li>
 *  <ul>
 *      <li><code>lightColor</code>:  rgba color object for the checkerboard's light alternating color.</li>
 *      <li><code>darkColor</code>: rgba color object for the checkerboard's dark alternating color.</li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>
 *  </ul>
 *  <li>Dot</li>
 *  <ul>
 *      <li><code>lightColor</code>:  rgba color object for the dot color.</li>
 *      <li><code>darkColor</code>:  rgba color object for the background color.</li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows of dots respectively.</li>
 *  </ul>
 *  <li>Water</li>
 *  <ul>
 *      <li><code>baseWaterColor</code>:  rgba color object base color of the water.</li>
 *      <li><code>blendColor</code>:  rgba color object used when blending from water to non-water areas.</li>
 *      <li><code>specularMap</code>:  Single channel texture used to indicate areas of water.</li>
 *      <li><code>normalMap</code>:  Normal map for water normal perturbation.</li>
 *      <li><code>frequency</code>:  Number that controls the number of waves.</li>
 *      <li><code>animationSpeed</code>:  Number that controls the animations speed of the water.</li>
 *      <li><code>amplitude</code>:  Number that controls the amplitude of water waves.</li>
 *      <li><code>specularIntensity</code>:  Number that controls the intensity of specular reflections.</li>
 *  </ul>
 *  <li>RimLighting</li>
 *  <ul>
 *      <li><code>color</code>:  diffuse color and alpha.</li>
 *      <li><code>rimColor</code>:  diffuse color and alpha of the rim.</li>
 *      <li><code>width</code>:  Number that determines the rim's width.</li>
 *  </ul>
 *  <li>Fade</li>
 *  <ul>
 *      <li><code>fadeInColor</code>: diffuse color and alpha at <code>time</code></li>
 *      <li><code>fadeOutColor</code>: diffuse color and alpha at <code>maximumDistance</code> from <code>time</code></li>
 *      <li><code>maximumDistance</code>: Number between 0.0 and 1.0 where the <code>fadeInColor</code> becomes the <code>fadeOutColor</code>. A value of 0.0 gives the entire material a color of <code>fadeOutColor</code> and a value of 1.0 gives the the entire material a color of <code>fadeInColor</code></li>
 *      <li><code>repeat</code>: true if the fade should wrap around the texture coodinates.</li>
 *      <li><code>fadeDirection</code>: Object with x and y values specifying if the fade should be in the x and y directions.</li>
 *      <li><code>time</code>: Object with x and y values between 0.0 and 1.0 of the <code>fadeInColor</code> position</li>
 *  </ul>
 *  <li>PolylineArrow</li>
 *  <ul>
 *      <li><code>color</code>: diffuse color and alpha.</li>
 *  </ul>
 *  <li>PolylineDash</li>
 *  <ul>
 *      <li><code>color</code>: color for the line.</li>
 *      <li><code>gapColor</code>: color for the gaps in the line.</li>
 *      <li><code>dashLength</code>: Dash length in pixels.</li>
 *      <li><code>dashPattern</code>: The 16 bit stipple pattern for the line..</li>
 *  </ul>
 *  <li>PolylineGlow</li>
 *  <ul>
 *      <li><code>color</code>: color and maximum alpha for the glow on the line.</li>
 *      <li><code>glowPower</code>: strength of the glow, as a percentage of the total line width (less than 1.0).</li>
 *      <li><code>taperPower</code>: strength of the tapering effect, as a percentage of the total line length.  If 1.0 or higher, no taper effect is used.</li>
 *  </ul>
 *  <li>PolylineOutline</li>
 *  <ul>
 *      <li><code>color</code>: diffuse color and alpha for the interior of the line.</li>
 *      <li><code>outlineColor</code>: diffuse color and alpha for the outline.</li>
 *      <li><code>outlineWidth</code>: width of the outline in pixels.</li>
 *  </ul>
 *  <li>ElevationContour</li>
 *  <ul>
 *      <li><code>color</code>: color and alpha for the contour line.</li>
 *      <li><code>spacing</code>: spacing for contour lines in meters.</li>
 *      <li><code>width</code>: Number specifying the width of the grid lines in pixels.</li>
 *  </ul>
 *  <li>ElevationRamp</li>
 *  <ul>
 *      <li><code>image</code>: color ramp image to use for coloring the terrain.</li>
 *      <li><code>minimumHeight</code>: minimum height for the ramp.</li>
 *      <li><code>maximumHeight</code>: maximum height for the ramp.</li>
 *  </ul>
 *  <li>SlopeRamp</li>
 *  <ul>
 *      <li><code>image</code>: color ramp image to use for coloring the terrain by slope.</li>
 *  </ul>
 *  <li>AspectRamp</li>
 *  <ul>
 *      <li><code>image</code>: color ramp image to use for color the terrain by aspect.</li>
 *  </ul>
 *  <li>ElevationBand</li>
 *  <ul>
 *      <li><code>heights</code>: image of heights sorted from lowest to highest.</li>
 *      <li><code>colors</code>: image of colors at the corresponding heights.</li>
 * </ul>
 * </ul>
 * </ul>
 * </div>
 * @example
 * // Create a color material with fromType:
 * polygon.material = Cesium.Material.fromType('Color');
 * polygon.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);
 *
 * // Create the default material:
 * polygon.material = new Cesium.Material();
 *
 * // Create a color material with full Fabric notation:
 * polygon.material = new Cesium.Material({
 *     fabric : {
 *         type : 'Color',
 *         uniforms : {
 *             color : new Cesium.Color(1.0, 1.0, 0.0, 1.0)
 *         }
 *     }
 * });
 * @param [options] - Object with the following properties:
 * @param [options.strict = false] - Throws errors for issues that would normally be ignored, including unused uniforms or materials.
 * @param [options.translucent = true] - When <code>true</code> or a function that returns <code>true</code>, the geometry
 *                           with this material is expected to appear translucent.
 * @param [options.minificationFilter = TextureMinificationFilter.LINEAR] - The {@link TextureMinificationFilter} to apply to this material's textures.
 * @param [options.magnificationFilter = TextureMagnificationFilter.LINEAR] - The {@link TextureMagnificationFilter} to apply to this material's textures.
 * @param options.fabric - The fabric JSON used to generate the material.
 */
export class Material {
  constructor(options?: {
    strict?: boolean;
    translucent?: boolean | ((...params: any[]) => any);
    minificationFilter?: TextureMinificationFilter;
    magnificationFilter?: TextureMagnificationFilter;
    fabric: any;
  });
  /**
   * The material type. Can be an existing type or a new type. If no type is specified in fabric, type is a GUID.
   */
  type: string;
  /**
   * The glsl shader source for this material.
   */
  shaderSource: string;
  /**
   * Maps sub-material names to Material objects.
   */
  materials: any;
  /**
   * Maps uniform names to their values.
   */
  uniforms: any;
  /**
   * When <code>true</code> or a function that returns <code>true</code>,
   * the geometry is expected to appear translucent.
   */
  translucent: boolean | ((...params: any[]) => any);
  /**
   * Creates a new material using an existing material type.
   * <br /><br />
   * Shorthand for: new Material({fabric : {type : type}});
   * @example
   * const material = Cesium.Material.fromType('Color', {
   *     color : new Cesium.Color(1.0, 0.0, 0.0, 1.0)
   * });
   * @param type - The base material type.
   * @param [uniforms] - Overrides for the default uniforms.
   * @returns New material object.
   */
  fromType(type: string, uniforms?: any): Material;
  /**
   * Gets whether or not this material is translucent.
   * @returns <code>true</code> if this material is translucent, <code>false</code> otherwise.
   */
  isTranslucent(): boolean;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * material = material && material.destroy();
   */
  destroy(): void;
  /**
   * Gets or sets the default texture uniform value.
   */
  DefaultImageId: string;
  /**
   * Gets or sets the default cube map texture uniform value.
   */
  DefaultCubeMapId: string;
  /**
   * Gets the name of the color material.
   */
  readonly ColorType: string;
  /**
   * Gets the name of the image material.
   */
  readonly ImageType: string;
  /**
   * Gets the name of the diffuce map material.
   */
  readonly DiffuseMapType: string;
  /**
   * Gets the name of the alpha map material.
   */
  readonly AlphaMapType: string;
  /**
   * Gets the name of the specular map material.
   */
  readonly SpecularMapType: string;
  /**
   * Gets the name of the emmision map material.
   */
  readonly EmissionMapType: string;
  /**
   * Gets the name of the bump map material.
   */
  readonly BumpMapType: string;
  /**
   * Gets the name of the normal map material.
   */
  readonly NormalMapType: string;
  /**
   * Gets the name of the grid material.
   */
  readonly GridType: string;
  /**
   * Gets the name of the stripe material.
   */
  readonly StripeType: string;
  /**
   * Gets the name of the checkerboard material.
   */
  readonly CheckerboardType: string;
  /**
   * Gets the name of the dot material.
   */
  readonly DotType: string;
  /**
   * Gets the name of the water material.
   */
  readonly WaterType: string;
  /**
   * Gets the name of the rim lighting material.
   */
  readonly RimLightingType: string;
  /**
   * Gets the name of the fade material.
   */
  readonly FadeType: string;
  /**
   * Gets the name of the polyline arrow material.
   */
  readonly PolylineArrowType: string;
  /**
   * Gets the name of the polyline glow material.
   */
  readonly PolylineDashType: string;
  /**
   * Gets the name of the polyline glow material.
   */
  readonly PolylineGlowType: string;
  /**
   * Gets the name of the polyline outline material.
   */
  readonly PolylineOutlineType: string;
  /**
   * Gets the name of the elevation contour material.
   */
  readonly ElevationContourType: string;
  /**
   * Gets the name of the elevation contour material.
   */
  readonly ElevationRampType: string;
  /**
   * Gets the name of the slope ramp material.
   */
  readonly SlopeRampMaterialType: string;
  /**
   * Gets the name of the aspect ramp material.
   */
  readonly AspectRampMaterialType: string;
  /**
   * Gets the name of the elevation band material.
   */
  readonly ElevationBandType: string;
}

/**
* An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)
* that supports shading with materials.
* @example
* const primitive = new Cesium.Primitive({
*   geometryInstances : new Cesium.GeometryInstance({
*     geometry : new Cesium.WallGeometry({
*             materialSupport :  Cesium.MaterialAppearance.MaterialSupport.BASIC.vertexFormat,
*       // ...
*     })
*   }),
*   appearance : new Cesium.MaterialAppearance({
*     material : Cesium.Material.fromType('Color'),
*     faceForward : true
*   })
*
* });
* @param [options] - Object with the following properties:
* @param [options.flat = false] - When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.
* @param [options.faceForward = !options.closed] - When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.
* @param [options.translucent = true] - When <code>true</code>, the geometry is expected to appear translucent so {@link MaterialAppearance#renderState} has alpha blending enabled.
* @param [options.closed = false] - When <code>true</code>, the geometry is expected to be closed so {@link MaterialAppearance#renderState} has backface culling enabled.
* @param [options.materialSupport = MaterialAppearance.MaterialSupport.TEXTURED] - The type of materials that will be supported.
* @param [options.material = Material.ColorType] - The material used to determine the fragment color.
* @param [options.vertexShaderSource] - Optional GLSL vertex shader source to override the default vertex shader.
* @param [options.fragmentShaderSource] - Optional GLSL fragment shader source to override the default fragment shader.
* @param [options.renderState] - Optional render state to override the default render state.
*/
export class MaterialAppearance {
  constructor(options?: {
    flat?: boolean;
    faceForward?: boolean;
    translucent?: boolean;
    closed?: boolean;
    materialSupport?: MaterialAppearance.MaterialSupportType;
    material?: Material;
    vertexShaderSource?: string;
    fragmentShaderSource?: string;
    renderState?: any;
  });
  /**
   * The material used to determine the fragment color.  Unlike other {@link MaterialAppearance}
   * properties, this is not read-only, so an appearance's material can change on the fly.
   */
  material: Material;
  /**
   * When <code>true</code>, the geometry is expected to appear translucent.
   */
  translucent: boolean;
  /**
   * The GLSL source code for the vertex shader.
   */
  readonly vertexShaderSource: string;
  /**
   * The GLSL source code for the fragment shader.  The full fragment shader
   * source is built procedurally taking into account {@link MaterialAppearance#material},
   * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.
   * Use {@link MaterialAppearance#getFragmentShaderSource} to get the full source.
   */
  readonly fragmentShaderSource: string;
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   * <p>
   * The render state can be explicitly defined when constructing a {@link MaterialAppearance}
   * instance, or it is set implicitly via {@link MaterialAppearance#translucent}
   * and {@link MaterialAppearance#closed}.
   * </p>
   */
  readonly renderState: any;
  /**
   * When <code>true</code>, the geometry is expected to be closed so
   * {@link MaterialAppearance#renderState} has backface culling enabled.
   * If the viewer enters the geometry, it will not be visible.
   */
  readonly closed: boolean;
  /**
   * The type of materials supported by this instance.  This impacts the required
   * {@link VertexFormat} and the complexity of the vertex and fragment shaders.
   */
  readonly materialSupport: MaterialAppearance.MaterialSupportType;
  /**
   * The {@link VertexFormat} that this appearance instance is compatible with.
   * A geometry can have more vertex attributes and still be compatible - at a
   * potential performance cost - but it can't have less.
   */
  readonly vertexFormat: VertexFormat;
  /**
   * When <code>true</code>, flat shading is used in the fragment shader,
   * which means lighting is not taking into account.
   */
  readonly flat: boolean;
  /**
   * When <code>true</code>, the fragment shader flips the surface normal
   * as needed to ensure that the normal faces the viewer to avoid
   * dark spots.  This is useful when both sides of a geometry should be
   * shaded like {@link WallGeometry}.
   */
  readonly faceForward: boolean;
  /**
   * Procedurally creates the full GLSL fragment shader source.  For {@link MaterialAppearance},
   * this is derived from {@link MaterialAppearance#fragmentShaderSource}, {@link MaterialAppearance#material},
   * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.
   * @returns The full GLSL fragment shader source.
   */
  getFragmentShaderSource(): string;
  /**
   * Determines if the geometry is translucent based on {@link MaterialAppearance#translucent} and {@link Material#isTranslucent}.
   * @returns <code>true</code> if the appearance is translucent.
   */
  isTranslucent(): boolean;
  /**
   * Creates a render state.  This is not the final render state instance; instead,
   * it can contain a subset of render state properties identical to the render state
   * created in the context.
   * @returns The render state.
   */
  getRenderState(): any;
}

export namespace MaterialAppearance {
  type MaterialSupportType = {
    vertexFormat: VertexFormat;
    vertexShaderSource: string;
    fragmentShaderSource: string;
  };
  /**
   * Determines the type of {@link Material} that is supported by a
   * {@link MaterialAppearance} instance.  This is a trade-off between
   * flexibility (a wide array of materials) and memory/performance
   * (required vertex format and GLSL shader complexity.
   */
  namespace MaterialSupport {
    /**
     * Only basic materials, which require just <code>position</code> and
     * <code>normal</code> vertex attributes, are supported.
     */
    const BASIC: MaterialAppearance.MaterialSupportType;
    /**
     * Materials with textures, which require <code>position</code>,
     * <code>normal</code>, and <code>st</code> vertex attributes,
     * are supported.  The vast majority of materials fall into this category.
     */
    const TEXTURED: MaterialAppearance.MaterialSupportType;
    /**
     * All materials, including those that work in tangent space, are supported.
     * This requires <code>position</code>, <code>normal</code>, <code>st</code>,
     * <code>tangent</code>, and <code>bitangent</code> vertex attributes.
     */
    const ALL: MaterialAppearance.MaterialSupportType;
  }
}

/**
 * Draws the Moon in 3D.
 * @example
 * scene.moon = new Cesium.Moon();
 * @param [options] - Object with the following properties:
 * @param [options.show = true] - Determines whether the moon will be rendered.
 * @param [options.textureUrl = buildModuleUrl('Assets/Textures/moonSmall.jpg')] - The moon texture.
 * @param [options.ellipsoid = Ellipsoid.MOON] - The moon ellipsoid.
 * @param [options.onlySunLighting = true] - Use the sun as the only light source.
 */
export class Moon {
  constructor(options?: {
    show?: boolean;
    textureUrl?: string;
    ellipsoid?: Ellipsoid;
    onlySunLighting?: boolean;
  });
  /**
   * Determines if the moon will be shown.
   */
  show: boolean;
  /**
   * The moon texture.
   */
  textureUrl: string;
  /**
   * Use the sun as the only light source.
   */
  onlySunLighting: boolean;
  /**
   * Get the ellipsoid that defines the shape of the moon.
   */
  readonly ellipsoid: Ellipsoid;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * moon = moon && moon.destroy();
   */
  destroy(): void;
}

/**
 * A particle emitted by a {@link ParticleSystem}.
 * @param options - An object with the following properties:
 * @param [options.mass = 1.0] - The mass of the particle in kilograms.
 * @param [options.position = Cartesian3.ZERO] - The initial position of the particle in world coordinates.
 * @param [options.velocity = Cartesian3.ZERO] - The velocity vector of the particle in world coordinates.
 * @param [options.life = Number.MAX_VALUE] - The life of the particle in seconds.
 * @param [options.image] - The URI, HTMLImageElement, or HTMLCanvasElement to use for the billboard.
 * @param [options.startColor = Color.WHITE] - The color of a particle when it is born.
 * @param [options.endColor = Color.WHITE] - The color of a particle when it dies.
 * @param [options.startScale = 1.0] - The scale of the particle when it is born.
 * @param [options.endScale = 1.0] - The scale of the particle when it dies.
 * @param [options.imageSize = new Cartesian2(1.0, 1.0)] - The dimensions, width by height, to scale the particle image in pixels.
 */
export class Particle {
  constructor(options: {
    mass?: number;
    position?: Cartesian3;
    velocity?: Cartesian3;
    life?: number;
    image?: any;
    startColor?: Color;
    endColor?: Color;
    startScale?: number;
    endScale?: number;
    imageSize?: Cartesian2;
  });
  /**
   * The mass of the particle in kilograms.
   */
  mass: number;
  /**
   * The positon of the particle in world coordinates.
   */
  position: Cartesian3;
  /**
   * The velocity of the particle in world coordinates.
   */
  velocity: Cartesian3;
  /**
   * The life of the particle in seconds.
   */
  life: number;
  /**
   * The image to use for the particle.
   */
  image: any;
  /**
   * The color of the particle when it is born.
   */
  startColor: Color;
  /**
   * The color of the particle when it dies.
   */
  endColor: Color;
  /**
   * the scale of the particle when it is born.
   */
  startScale: number;
  /**
   * The scale of the particle when it dies.
   */
  endScale: number;
  /**
   * The dimensions, width by height, to scale the particle image in pixels.
   */
  imageSize: Cartesian2;
  /**
   * Gets the age of the particle in seconds.
   */
  age: number;
  /**
   * Gets the age normalized to a value in the range [0.0, 1.0].
   */
  normalizedAge: number;
}

/**
 * A ParticleSystem manages the updating and display of a collection of particles.
 * @param [options] - Object with the following properties:
 * @param [options.show = true] - Whether to display the particle system.
 * @param [options.updateCallback] - The callback function to be called each frame to update a particle.
 * @param [options.emitter = new CircleEmitter(0.5)] - The particle emitter for this system.
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms the particle system from model to world coordinates.
 * @param [options.emitterModelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms the particle system emitter within the particle systems local coordinate system.
 * @param [options.emissionRate = 5] - The number of particles to emit per second.
 * @param [options.bursts] - An array of {@link ParticleBurst}, emitting bursts of particles at periodic times.
 * @param [options.loop = true] - Whether the particle system should loop its bursts when it is complete.
 * @param [options.scale = 1.0] - Sets the scale to apply to the image of the particle for the duration of its particleLife.
 * @param [options.startScale] - The initial scale to apply to the image of the particle at the beginning of its life.
 * @param [options.endScale] - The final scale to apply to the image of the particle at the end of its life.
 * @param [options.color = Color.WHITE] - Sets the color of a particle for the duration of its particleLife.
 * @param [options.startColor] - The color of the particle at the beginning of its life.
 * @param [options.endColor] - The color of the particle at the end of its life.
 * @param [options.image] - The URI, HTMLImageElement, or HTMLCanvasElement to use for the billboard.
 * @param [options.imageSize = new Cartesian2(1.0, 1.0)] - If set, overrides the minimumImageSize and maximumImageSize inputs that scale the particle image's dimensions in pixels.
 * @param [options.minimumImageSize] - Sets the minimum bound, width by height, above which to randomly scale the particle image's dimensions in pixels.
 * @param [options.maximumImageSize] - Sets the maximum bound, width by height, below which to randomly scale the particle image's dimensions in pixels.
 * @param [options.sizeInMeters] - Sets if the size of particles is in meters or pixels. <code>true</code> to size the particles in meters; otherwise, the size is in pixels.
 * @param [options.speed = 1.0] - If set, overrides the minimumSpeed and maximumSpeed inputs with this value.
 * @param [options.minimumSpeed] - Sets the minimum bound in meters per second above which a particle's actual speed will be randomly chosen.
 * @param [options.maximumSpeed] - Sets the maximum bound in meters per second below which a particle's actual speed will be randomly chosen.
 * @param [options.lifetime = Number.MAX_VALUE] - How long the particle system will emit particles, in seconds.
 * @param [options.particleLife = 5.0] - If set, overrides the minimumParticleLife and maximumParticleLife inputs with this value.
 * @param [options.minimumParticleLife] - Sets the minimum bound in seconds for the possible duration of a particle's life above which a particle's actual life will be randomly chosen.
 * @param [options.maximumParticleLife] - Sets the maximum bound in seconds for the possible duration of a particle's life below which a particle's actual life will be randomly chosen.
 * @param [options.mass = 1.0] - Sets the minimum and maximum mass of particles in kilograms.
 * @param [options.minimumMass] - Sets the minimum bound for the mass of a particle in kilograms. A particle's actual mass will be chosen as a random amount above this value.
 * @param [options.maximumMass] - Sets the maximum mass of particles in kilograms. A particle's actual mass will be chosen as a random amount below this value.
 */
export class ParticleSystem {
  constructor(options?: {
    show?: boolean;
    updateCallback?: ParticleSystem.updateCallback;
    emitter?: ParticleEmitter;
    modelMatrix?: Matrix4;
    emitterModelMatrix?: Matrix4;
    emissionRate?: number;
    bursts?: ParticleBurst[];
    loop?: boolean;
    scale?: number;
    startScale?: number;
    endScale?: number;
    color?: Color;
    startColor?: Color;
    endColor?: Color;
    image?: any;
    imageSize?: Cartesian2;
    minimumImageSize?: Cartesian2;
    maximumImageSize?: Cartesian2;
    sizeInMeters?: boolean;
    speed?: number;
    minimumSpeed?: number;
    maximumSpeed?: number;
    lifetime?: number;
    particleLife?: number;
    minimumParticleLife?: number;
    maximumParticleLife?: number;
    mass?: number;
    minimumMass?: number;
    maximumMass?: number;
  });
  /**
   * Whether to display the particle system.
   */
  show: boolean;
  /**
   * An array of force callbacks. The callback is passed a {@link Particle} and the difference from the last time
   */
  updateCallback: ParticleSystem.updateCallback;
  /**
   * Whether the particle system should loop it's bursts when it is complete.
   */
  loop: boolean;
  /**
   * The URI, HTMLImageElement, or HTMLCanvasElement to use for the billboard.
   */
  image: any;
  /**
   * The particle emitter for this
   */
  emitter: ParticleEmitter;
  /**
   * An array of {@link ParticleBurst}, emitting bursts of particles at periodic times.
   */
  bursts: ParticleBurst[];
  /**
   * The 4x4 transformation matrix that transforms the particle system from model to world coordinates.
   */
  modelMatrix: Matrix4;
  /**
   * The 4x4 transformation matrix that transforms the particle system emitter within the particle systems local coordinate system.
   */
  emitterModelMatrix: Matrix4;
  /**
   * The color of the particle at the beginning of its life.
   */
  startColor: Color;
  /**
   * The color of the particle at the end of its life.
   */
  endColor: Color;
  /**
   * The initial scale to apply to the image of the particle at the beginning of its life.
   */
  startScale: number;
  /**
   * The final scale to apply to the image of the particle at the end of its life.
   */
  endScale: number;
  /**
   * The number of particles to emit per second.
   */
  emissionRate: number;
  /**
   * Sets the minimum bound in meters per second above which a particle's actual speed will be randomly chosen.
   */
  minimumSpeed: number;
  /**
   * Sets the maximum bound in meters per second below which a particle's actual speed will be randomly chosen.
   */
  maximumSpeed: number;
  /**
   * Sets the minimum bound in seconds for the possible duration of a particle's life above which a particle's actual life will be randomly chosen.
   */
  minimumParticleLife: number;
  /**
   * Sets the maximum bound in seconds for the possible duration of a particle's life below which a particle's actual life will be randomly chosen.
   */
  maximumParticleLife: number;
  /**
   * Sets the minimum mass of particles in kilograms.
   */
  minimumMass: number;
  /**
   * Sets the maximum mass of particles in kilograms.
   */
  maximumMass: number;
  /**
   * Sets the minimum bound, width by height, above which to randomly scale the particle image's dimensions in pixels.
   */
  minimumImageSize: Cartesian2;
  /**
   * Sets the maximum bound, width by height, below which to randomly scale the particle image's dimensions in pixels.
   */
  maximumImageSize: Cartesian2;
  /**
   * Gets or sets if the particle size is in meters or pixels. <code>true</code> to size particles in meters; otherwise, the size is in pixels.
   */
  sizeInMeters: boolean;
  /**
   * How long the particle system will emit particles, in seconds.
   */
  lifetime: number;
  /**
   * Fires an event when the particle system has reached the end of its lifetime.
   */
  complete: Event;
  /**
   * When <code>true</code>, the particle system has reached the end of its lifetime; <code>false</code> otherwise.
   */
  isComplete: boolean;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   */
  destroy(): void;
}

export namespace ParticleSystem {
  /**
   * A function used to modify attributes of the particle at each time step. This can include force modifications,
   * color, sizing, etc.
   * @example
   * function applyGravity(particle, dt) {
   *    const position = particle.position;
   *    const gravityVector = Cesium.Cartesian3.normalize(position, new Cesium.Cartesian3());
   *    Cesium.Cartesian3.multiplyByScalar(gravityVector, GRAVITATIONAL_CONSTANT * dt, gravityVector);
   *    particle.velocity = Cesium.Cartesian3.add(particle.velocity, gravityVector, particle.velocity);
   * }
   * @param particle - The particle being updated.
   * @param dt - The time in seconds since the last update.
   */
  type updateCallback = (particle: Particle, dt: number) => void;
}

/**
* An appearance for {@link GeometryInstance} instances with color attributes.
* This allows several geometry instances, each with a different color, to
* be drawn with the same {@link Primitive} as shown in the second example below.
* @example
* // A solid white line segment
* const primitive = new Cesium.Primitive({
*   geometryInstances : new Cesium.GeometryInstance({
*     geometry : new Cesium.SimplePolylineGeometry({
*       positions : Cesium.Cartesian3.fromDegreesArray([
*         0.0, 0.0,
*         5.0, 0.0
*       ])
*     }),
*     attributes : {
*       color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0))
*     }
*   }),
*   appearance : new Cesium.PerInstanceColorAppearance({
*     flat : true,
*     translucent : false
*   })
* });
*
* // Two rectangles in a primitive, each with a different color
* const instance = new Cesium.GeometryInstance({
*   geometry : new Cesium.RectangleGeometry({
*     rectangle : Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0)
*   }),
*   attributes : {
*     color : new Cesium.ColorGeometryInstanceAttribute(1.0, 0.0, 0.0, 0.5)
*   }
* });
*
* const anotherInstance = new Cesium.GeometryInstance({
*   geometry : new Cesium.RectangleGeometry({
*     rectangle : Cesium.Rectangle.fromDegrees(0.0, 40.0, 10.0, 50.0)
*   }),
*   attributes : {
*     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 0.0, 1.0, 0.5)
*   }
* });
*
* const rectanglePrimitive = new Cesium.Primitive({
*   geometryInstances : [instance, anotherInstance],
*   appearance : new Cesium.PerInstanceColorAppearance()
* });
* @param [options] - Object with the following properties:
* @param [options.flat = false] - When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.
* @param [options.faceForward = !options.closed] - When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.
* @param [options.translucent = true] - When <code>true</code>, the geometry is expected to appear translucent so {@link PerInstanceColorAppearance#renderState} has alpha blending enabled.
* @param [options.closed = false] - When <code>true</code>, the geometry is expected to be closed so {@link PerInstanceColorAppearance#renderState} has backface culling enabled.
* @param [options.vertexShaderSource] - Optional GLSL vertex shader source to override the default vertex shader.
* @param [options.fragmentShaderSource] - Optional GLSL fragment shader source to override the default fragment shader.
* @param [options.renderState] - Optional render state to override the default render state.
*/
export class PerInstanceColorAppearance {
  constructor(options?: {
    flat?: boolean;
    faceForward?: boolean;
    translucent?: boolean;
    closed?: boolean;
    vertexShaderSource?: string;
    fragmentShaderSource?: string;
    renderState?: any;
  });
  /**
   * This property is part of the {@link Appearance} interface, but is not
   * used by {@link PerInstanceColorAppearance} since a fully custom fragment shader is used.
   */
  material: Material;
  /**
   * When <code>true</code>, the geometry is expected to appear translucent so
   * {@link PerInstanceColorAppearance#renderState} has alpha blending enabled.
   */
  translucent: boolean;
  /**
   * The GLSL source code for the vertex shader.
   */
  readonly vertexShaderSource: string;
  /**
   * The GLSL source code for the fragment shader.
   */
  readonly fragmentShaderSource: string;
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   * <p>
   * The render state can be explicitly defined when constructing a {@link PerInstanceColorAppearance}
   * instance, or it is set implicitly via {@link PerInstanceColorAppearance#translucent}
   * and {@link PerInstanceColorAppearance#closed}.
   * </p>
   */
  readonly renderState: any;
  /**
   * When <code>true</code>, the geometry is expected to be closed so
   * {@link PerInstanceColorAppearance#renderState} has backface culling enabled.
   * If the viewer enters the geometry, it will not be visible.
   */
  readonly closed: boolean;
  /**
   * The {@link VertexFormat} that this appearance instance is compatible with.
   * A geometry can have more vertex attributes and still be compatible - at a
   * potential performance cost - but it can't have less.
   */
  readonly vertexFormat: VertexFormat;
  /**
   * When <code>true</code>, flat shading is used in the fragment shader,
   * which means lighting is not taking into account.
   */
  readonly flat: boolean;
  /**
   * When <code>true</code>, the fragment shader flips the surface normal
   * as needed to ensure that the normal faces the viewer to avoid
   * dark spots.  This is useful when both sides of a geometry should be
   * shaded like {@link WallGeometry}.
   */
  readonly faceForward: boolean;
  /**
   * The {@link VertexFormat} that all {@link PerInstanceColorAppearance} instances
   * are compatible with.  This requires only <code>position</code> and <code>normal</code>
   * attributes.
   */
  readonly VERTEX_FORMAT: VertexFormat;
  /**
   * The {@link VertexFormat} that all {@link PerInstanceColorAppearance} instances
   * are compatible with when {@link PerInstanceColorAppearance#flat} is <code>true</code>.
   * This requires only a <code>position</code> attribute.
   */
  readonly FLAT_VERTEX_FORMAT: VertexFormat;
  /**
   * Procedurally creates the full GLSL fragment shader source.  For {@link PerInstanceColorAppearance},
   * this is derived from {@link PerInstanceColorAppearance#fragmentShaderSource}, {@link PerInstanceColorAppearance#flat},
   * and {@link PerInstanceColorAppearance#faceForward}.
   * @returns The full GLSL fragment shader source.
   */
  getFragmentShaderSource(): string;
  /**
   * Determines if the geometry is translucent based on {@link PerInstanceColorAppearance#translucent}.
   * @returns <code>true</code> if the appearance is translucent.
   */
  isTranslucent(): boolean;
  /**
   * Creates a render state.  This is not the final render state instance; instead,
   * it can contain a subset of render state properties identical to the render state
   * created in the context.
   * @returns The render state.
   */
  getRenderState(): any;
}

/**
* Options for performing point attenuation based on geometric error when rendering
* point clouds using 3D Tiles.
* @param [options] - Object with the following properties:
* @param [options.attenuation = false] - Perform point attenuation based on geometric error.
* @param [options.geometricErrorScale = 1.0] - Scale to be applied to each tile's geometric error.
* @param [options.maximumAttenuation] - Maximum attenuation in pixels. Defaults to the Cesium3DTileset's maximumScreenSpaceError.
* @param [options.baseResolution] - Average base resolution for the dataset in meters. Substitute for Geometric Error when not available.
* @param [options.eyeDomeLighting = true] - When true, use eye dome lighting when drawing with point attenuation.
* @param [options.eyeDomeLightingStrength = 1.0] - Increasing this value increases contrast on slopes and edges.
* @param [options.eyeDomeLightingRadius = 1.0] - Increase the thickness of contours from eye dome lighting.
* @param [options.backFaceCulling = false] - Determines whether back-facing points are hidden. This option works only if data has normals included.
* @param [options.normalShading = true] - Determines whether a point cloud that contains normals is shaded by the scene's light source.
*/
export class PointCloudShading {
  constructor(options?: {
    attenuation?: boolean;
    geometricErrorScale?: number;
    maximumAttenuation?: number;
    baseResolution?: number;
    eyeDomeLighting?: boolean;
    eyeDomeLightingStrength?: number;
    eyeDomeLightingRadius?: number;
    backFaceCulling?: boolean;
    normalShading?: boolean;
  });
  /**
   * Perform point attenuation based on geometric error.
   */
  attenuation: boolean;
  /**
   * Scale to be applied to the geometric error before computing attenuation.
   */
  geometricErrorScale: number;
  /**
   * Maximum point attenuation in pixels. If undefined, the Cesium3DTileset's maximumScreenSpaceError will be used.
   */
  maximumAttenuation: number;
  /**
   * Average base resolution for the dataset in meters.
   * Used in place of geometric error when geometric error is 0.
   * If undefined, an approximation will be computed for each tile that has geometric error of 0.
   */
  baseResolution: number;
  /**
   * Use eye dome lighting when drawing with point attenuation
   * Requires support for EXT_frag_depth, OES_texture_float, and WEBGL_draw_buffers extensions in WebGL 1.0,
   * otherwise eye dome lighting is ignored.
   */
  eyeDomeLighting: boolean;
  /**
   * Eye dome lighting strength (apparent contrast)
   */
  eyeDomeLightingStrength: number;
  /**
   * Thickness of contours from eye dome lighting
   */
  eyeDomeLightingRadius: number;
  /**
   * Determines whether back-facing points are hidden.
   * This option works only if data has normals included.
   */
  backFaceCulling: boolean;
  /**
   * Determines whether a point cloud that contains normals is shaded by the scene's light source.
   */
  normalShading: boolean;
  /**
   * Determines if point cloud shading is supported.
   * @param scene - The scene.
   * @returns <code>true</code> if point cloud shading is supported; otherwise, returns <code>false</code>
   */
  isSupported(scene: Scene): boolean;
}

/**
* A graphical point positioned in the 3D scene, that is created
* and rendered using a {@link PointPrimitiveCollection}.  A point is created and its initial
* properties are set by calling {@link PointPrimitiveCollection#add}.
*/
export class PointPrimitive {
  constructor();
  /**
   * Determines if this point will be shown.  Use this to hide or show a point, instead
   * of removing it and re-adding it to the collection.
   */
  show: boolean;
  /**
   * Gets or sets the Cartesian position of this point.
   */
  position: Cartesian3;
  /**
   * Gets or sets near and far scaling properties of a point based on the point's distance from the camera.
   * A point's scale will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the point's scale remains clamped to the nearest bound.  This scale
   * multiplies the pixelSize and outlineWidth to affect the total size of the point.  If undefined,
   * scaleByDistance will be disabled.
   * @example
   * // Example 1.
   * // Set a pointPrimitive's scaleByDistance to scale to 15 when the
   * // camera is 1500 meters from the pointPrimitive and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * p.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 15, 8.0e6, 0.0);
   * @example
   * // Example 2.
   * // disable scaling by distance
   * p.scaleByDistance = undefined;
   */
  scaleByDistance: NearFarScalar;
  /**
   * Gets or sets near and far translucency properties of a point based on the point's distance from the camera.
   * A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and
   * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
   * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
   * Outside of these ranges the point's translucency remains clamped to the nearest bound.  If undefined,
   * translucencyByDistance will be disabled.
   * @example
   * // Example 1.
   * // Set a point's translucency to 1.0 when the
   * // camera is 1500 meters from the point and disappear as
   * // the camera distance approaches 8.0e6 meters.
   * p.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
   * @example
   * // Example 2.
   * // disable translucency by distance
   * p.translucencyByDistance = undefined;
   */
  translucencyByDistance: NearFarScalar;
  /**
   * Gets or sets the inner size of the point in pixels.
   */
  pixelSize: number;
  /**
   * Gets or sets the inner color of the point.
   * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
   * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
   * (no intensity) to <code>1.0</code> (full intensity).
   * @example
   * // Example 1. Assign yellow.
   * p.color = Cesium.Color.YELLOW;
   * @example
   * // Example 2. Make a pointPrimitive 50% translucent.
   * p.color = new Cesium.Color(1.0, 1.0, 1.0, 0.5);
   */
  color: Color;
  /**
   * Gets or sets the outline color of the point.
   */
  outlineColor: Color;
  /**
   * Gets or sets the outline width in pixels.  This width adds to pixelSize,
   * increasing the total size of the point.
   */
  outlineWidth: number;
  /**
   * Gets or sets the condition specifying at what distance from the camera that this point will be displayed.
   */
  distanceDisplayCondition: DistanceDisplayCondition;
  /**
   * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
   * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
   */
  disableDepthTestDistance: number;
  /**
   * Gets or sets the user-defined value returned when the point is picked.
   */
  id: any;
  /**
   * Computes the screen-space position of the point's origin.
   * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from
   * left to right, and <code>y</code> increases from top to bottom.
   * @example
   * console.log(p.computeScreenSpacePosition(scene).toString());
   * @param scene - The scene.
   * @param [result] - The object onto which to store the result.
   * @returns The screen-space position of the point.
   */
  computeScreenSpacePosition(scene: Scene, result?: Cartesian2): Cartesian2;
  /**
   * Determines if this point equals another point.  Points are equal if all their properties
   * are equal.  Points in different collections can be equal.
   * @param other - The point to compare for equality.
   * @returns <code>true</code> if the points are equal; otherwise, <code>false</code>.
   */
  equals(other: PointPrimitive): boolean;
}

/**
* A renderable collection of points.
* <br /><br />
* Points are added and removed from the collection using {@link PointPrimitiveCollection#add}
* and {@link PointPrimitiveCollection#remove}.
* @example
* // Create a pointPrimitive collection with two points
* const points = scene.primitives.add(new Cesium.PointPrimitiveCollection());
* points.add({
*   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),
*   color : Cesium.Color.YELLOW
* });
* points.add({
*   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),
*   color : Cesium.Color.CYAN
* });
* @param [options] - Object with the following properties:
* @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms each point from model to world coordinates.
* @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
* @param [options.blendOption = BlendOption.OPAQUE_AND_TRANSLUCENT] - The point blending option. The default
* is used for rendering both opaque and translucent points. However, if either all of the points are completely opaque or all are completely translucent,
* setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.
* @param [options.show = true] - Determines if the primitives in the collection will be shown.
*/
export class PointPrimitiveCollection {
  constructor(options?: {
    modelMatrix?: Matrix4;
    debugShowBoundingVolume?: boolean;
    blendOption?: BlendOption;
    show?: boolean;
  });
  /**
   * Determines if primitives in this collection will be shown.
   */
  show: boolean;
  /**
   * The 4x4 transformation matrix that transforms each point in this collection from model to world coordinates.
   * When this is the identity matrix, the pointPrimitives are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
   * Local reference frames can be used by providing a different transformation matrix, like that returned
   * by {@link Transforms.eastNorthUpToFixedFrame}.
   * @example
   * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
   * pointPrimitives.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
   * pointPrimitives.add({
   *   color : Cesium.Color.ORANGE,
   *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center
   * });
   * pointPrimitives.add({
   *   color : Cesium.Color.YELLOW,
   *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east
   * });
   * pointPrimitives.add({
   *   color : Cesium.Color.GREEN,
   *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north
   * });
   * pointPrimitives.add({
   *   color : Cesium.Color.CYAN,
   *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up
   * });
   */
  modelMatrix: Matrix4;
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the bounding sphere for each draw command in the primitive.
   * </p>
   */
  debugShowBoundingVolume: boolean;
  /**
   * The point blending option. The default is used for rendering both opaque and translucent points.
   * However, if either all of the points are completely opaque or all are completely translucent,
   * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve
   * performance by up to 2x.
   */
  blendOption: BlendOption;
  /**
   * Returns the number of points in this collection.  This is commonly used with
   * {@link PointPrimitiveCollection#get} to iterate over all the points
   * in the collection.
   */
  length: number;
  /**
   * Creates and adds a point with the specified initial properties to the collection.
   * The added point is returned so it can be modified or removed from the collection later.
   * @example
   * // Example 1:  Add a point, specifying all the default values.
   * const p = pointPrimitives.add({
   *   show : true,
   *   position : Cesium.Cartesian3.ZERO,
   *   pixelSize : 10.0,
   *   color : Cesium.Color.WHITE,
   *   outlineColor : Cesium.Color.TRANSPARENT,
   *   outlineWidth : 0.0,
   *   id : undefined
   * });
   * @example
   * // Example 2:  Specify only the point's cartographic position.
   * const p = pointPrimitives.add({
   *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)
   * });
   * @param [options] - A template describing the point's properties as shown in Example 1.
   * @returns The point that was added to the collection.
   */
  add(options?: any): PointPrimitive;
  /**
   * Removes a point from the collection.
   * @example
   * const p = pointPrimitives.add(...);
   * pointPrimitives.remove(p);  // Returns true
   * @param pointPrimitive - The point to remove.
   * @returns <code>true</code> if the point was removed; <code>false</code> if the point was not found in the collection.
   */
  remove(pointPrimitive: PointPrimitive): boolean;
  /**
   * Removes all points from the collection.
   * @example
   * pointPrimitives.add(...);
   * pointPrimitives.add(...);
   * pointPrimitives.removeAll();
   */
  removeAll(): void;
  /**
   * Check whether this collection contains a given point.
   * @param [pointPrimitive] - The point to check for.
   * @returns true if this collection contains the point, false otherwise.
   */
  contains(pointPrimitive?: PointPrimitive): boolean;
  /**
   * Returns the point in the collection at the specified index.  Indices are zero-based
   * and increase as points are added.  Removing a point shifts all points after
   * it to the left, changing their indices.  This function is commonly used with
   * {@link PointPrimitiveCollection#length} to iterate over all the points
   * in the collection.
   * @example
   * // Toggle the show property of every point in the collection
   * const len = pointPrimitives.length;
   * for (let i = 0; i < len; ++i) {
   *   const p = pointPrimitives.get(i);
   *   p.show = !p.show;
   * }
   * @param index - The zero-based index of the point.
   * @returns The point at the specified index.
   */
  get(index: number): PointPrimitive;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * pointPrimitives = pointPrimitives && pointPrimitives.destroy();
   */
  destroy(): void;
}

/**
* A renderable polyline. Create this by calling {@link PolylineCollection#add}
* @param options - Object with the following properties:
* @param [options.show = true] - <code>true</code> if this polyline will be shown; otherwise, <code>false</code>.
* @param [options.width = 1.0] - The width of the polyline in pixels.
* @param [options.loop = false] - Whether a line segment will be added between the last and first line positions to make this line a loop.
* @param [options.material = Material.ColorType] - The material.
* @param [options.positions] - The positions.
* @param [options.id] - The user-defined object to be returned when this polyline is picked.
* @param [options.distanceDisplayCondition] - The condition specifying at what distance from the camera that this polyline will be displayed.
* @param polylineCollection - The renderable polyline collection.
*/
export class Polyline {
  constructor(options: {
    show?: boolean;
    width?: number;
    loop?: boolean;
    material?: Material;
    positions?: Cartesian3[];
    id?: any;
    distanceDisplayCondition?: DistanceDisplayCondition;
  }, polylineCollection: PolylineCollection);
  /**
   * Determines if this polyline will be shown.  Use this to hide or show a polyline, instead
   * of removing it and re-adding it to the collection.
   */
  show: boolean;
  /**
   * Gets or sets the positions of the polyline.
   * @example
   * polyline.positions = Cesium.Cartesian3.fromDegreesArray([
   *     0.0, 0.0,
   *     10.0, 0.0,
   *     0.0, 20.0
   * ]);
   */
  positions: Cartesian3[];
  /**
   * Gets or sets the surface appearance of the polyline. 
   */
  material: Material;
  /**
   * Gets or sets the width of the polyline.
   */
  width: number;
  /**
   * Gets or sets whether a line segment will be added between the first and last polyline positions.
   */
  loop: boolean;
  /**
   * Gets or sets the user-defined value returned when the polyline is picked.
   */
  id: any;
  /**
   * Gets or sets the condition specifying at what distance from the camera that this polyline will be displayed.
   */
  distanceDisplayCondition: DistanceDisplayCondition;
}

/**
* A renderable collection of polylines.
* <br /><br />
* <div align="center">
* <img src="Images/Polyline.png" width="400" height="300" /><br />
* Example polylines
* </div>
* <br /><br />
* Polylines are added and removed from the collection using {@link PolylineCollection#add}
* and {@link PolylineCollection#remove}.
* @example
* // Create a polyline collection with two polylines
* const polylines = new Cesium.PolylineCollection();
* polylines.add({
*   positions : Cesium.Cartesian3.fromDegreesArray([
*     -75.10, 39.57,
*     -77.02, 38.53,
*     -80.50, 35.14,
*     -80.12, 25.46]),
*   width : 2
* });
*
* polylines.add({
*   positions : Cesium.Cartesian3.fromDegreesArray([
*     -73.10, 37.57,
*     -75.02, 36.53,
*     -78.50, 33.14,
*     -78.12, 23.46]),
*   width : 4
* });
* @param [options] - Object with the following properties:
* @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms each polyline from model to world coordinates.
* @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
* @param [options.show = true] - Determines if the polylines in the collection will be shown.
*/
export class PolylineCollection {
  constructor(options?: {
    modelMatrix?: Matrix4;
    debugShowBoundingVolume?: boolean;
    show?: boolean;
  });
  /**
   * Determines if polylines in this collection will be shown.
   */
  show: boolean;
  /**
   * The 4x4 transformation matrix that transforms each polyline in this collection from model to world coordinates.
   * When this is the identity matrix, the polylines are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
   * Local reference frames can be used by providing a different transformation matrix, like that returned
   * by {@link Transforms.eastNorthUpToFixedFrame}.
   */
  modelMatrix: Matrix4;
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the bounding sphere for each draw command in the primitive.
   * </p>
   */
  debugShowBoundingVolume: boolean;
  /**
   * Returns the number of polylines in this collection.  This is commonly used with
   * {@link PolylineCollection#get} to iterate over all the polylines
   * in the collection.
   */
  length: number;
  /**
   * Creates and adds a polyline with the specified initial properties to the collection.
   * The added polyline is returned so it can be modified or removed from the collection later.
   * @example
   * // Example 1:  Add a polyline, specifying all the default values.
   * const p = polylines.add({
   *   show : true,
   *   positions : ellipsoid.cartographicArrayToCartesianArray([
   *            Cesium.Cartographic.fromDegrees(-75.10, 39.57),
   *            Cesium.Cartographic.fromDegrees(-77.02, 38.53)]),
   *   width : 1
   * });
   * @param [options] - A template describing the polyline's properties as shown in Example 1.
   * @returns The polyline that was added to the collection.
   */
  add(options?: any): Polyline;
  /**
   * Removes a polyline from the collection.
   * @example
   * const p = polylines.add(...);
   * polylines.remove(p);  // Returns true
   * @param polyline - The polyline to remove.
   * @returns <code>true</code> if the polyline was removed; <code>false</code> if the polyline was not found in the collection.
   */
  remove(polyline: Polyline): boolean;
  /**
   * Removes all polylines from the collection.
   * @example
   * polylines.add(...);
   * polylines.add(...);
   * polylines.removeAll();
   */
  removeAll(): void;
  /**
   * Determines if this collection contains the specified polyline.
   * @param polyline - The polyline to check for.
   * @returns true if this collection contains the polyline, false otherwise.
   */
  contains(polyline: Polyline): boolean;
  /**
   * Returns the polyline in the collection at the specified index.  Indices are zero-based
   * and increase as polylines are added.  Removing a polyline shifts all polylines after
   * it to the left, changing their indices.  This function is commonly used with
   * {@link PolylineCollection#length} to iterate over all the polylines
   * in the collection.
   * @example
   * // Toggle the show property of every polyline in the collection
   * const len = polylines.length;
   * for (let i = 0; i < len; ++i) {
   *   const p = polylines.get(i);
   *   p.show = !p.show;
   * }
   * @param index - The zero-based index of the polyline.
   * @returns The polyline at the specified index.
   */
  get(index: number): Polyline;
  /**
   * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
   * get the draw commands needed to render this primitive.
   * <p>
   * Do not call this function directly.  This is documented just to
   * list the exceptions that may be propagated when the scene is rendered:
   * </p>
   */
  update(): void;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * polylines = polylines && polylines.destroy();
   */
  destroy(): void;
}

/**
* An appearance for {@link GeometryInstance} instances with color attributes and
* {@link PolylineGeometry} or {@link GroundPolylineGeometry}.
* This allows several geometry instances, each with a different color, to
* be drawn with the same {@link Primitive}.
* @example
* // A solid white line segment
* const primitive = new Cesium.Primitive({
*   geometryInstances : new Cesium.GeometryInstance({
*     geometry : new Cesium.PolylineGeometry({
*       positions : Cesium.Cartesian3.fromDegreesArray([
*         0.0, 0.0,
*         5.0, 0.0
*       ]),
*       width : 10.0,
*       vertexFormat : Cesium.PolylineColorAppearance.VERTEX_FORMAT
*     }),
*     attributes : {
*       color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0))
*     }
*   }),
*   appearance : new Cesium.PolylineColorAppearance({
*     translucent : false
*   })
* });
* @param [options] - Object with the following properties:
* @param [options.translucent = true] - When <code>true</code>, the geometry is expected to appear translucent so {@link PolylineColorAppearance#renderState} has alpha blending enabled.
* @param [options.vertexShaderSource] - Optional GLSL vertex shader source to override the default vertex shader.
* @param [options.fragmentShaderSource] - Optional GLSL fragment shader source to override the default fragment shader.
* @param [options.renderState] - Optional render state to override the default render state.
*/
export class PolylineColorAppearance {
  constructor(options?: {
    translucent?: boolean;
    vertexShaderSource?: string;
    fragmentShaderSource?: string;
    renderState?: any;
  });
  /**
   * This property is part of the {@link Appearance} interface, but is not
   * used by {@link PolylineColorAppearance} since a fully custom fragment shader is used.
   */
  material: Material;
  /**
   * When <code>true</code>, the geometry is expected to appear translucent so
   * {@link PolylineColorAppearance#renderState} has alpha blending enabled.
   */
  translucent: boolean;
  /**
   * The GLSL source code for the vertex shader.
   */
  readonly vertexShaderSource: string;
  /**
   * The GLSL source code for the fragment shader.
   */
  readonly fragmentShaderSource: string;
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   * <p>
   * The render state can be explicitly defined when constructing a {@link PolylineColorAppearance}
   * instance, or it is set implicitly via {@link PolylineColorAppearance#translucent}.
   * </p>
   */
  readonly renderState: any;
  /**
   * When <code>true</code>, the geometry is expected to be closed so
   * {@link PolylineColorAppearance#renderState} has backface culling enabled.
   * This is always <code>false</code> for <code>PolylineColorAppearance</code>.
   */
  readonly closed: boolean;
  /**
   * The {@link VertexFormat} that this appearance instance is compatible with.
   * A geometry can have more vertex attributes and still be compatible - at a
   * potential performance cost - but it can't have less.
   */
  readonly vertexFormat: VertexFormat;
  /**
   * The {@link VertexFormat} that all {@link PolylineColorAppearance} instances
   * are compatible with. This requires only a <code>position</code> attribute.
   */
  readonly VERTEX_FORMAT: VertexFormat;
  /**
   * Procedurally creates the full GLSL fragment shader source.
   * @returns The full GLSL fragment shader source.
   */
  getFragmentShaderSource(): string;
  /**
   * Determines if the geometry is translucent based on {@link PolylineColorAppearance#translucent}.
   * @returns <code>true</code> if the appearance is translucent.
   */
  isTranslucent(): boolean;
  /**
   * Creates a render state.  This is not the final render state instance; instead,
   * it can contain a subset of render state properties identical to the render state
   * created in the context.
   * @returns The render state.
   */
  getRenderState(): any;
}

/**
* An appearance for {@link PolylineGeometry} that supports shading with materials.
* @example
* const primitive = new Cesium.Primitive({
*   geometryInstances : new Cesium.GeometryInstance({
*     geometry : new Cesium.PolylineGeometry({
*       positions : Cesium.Cartesian3.fromDegreesArray([
*         0.0, 0.0,
*         5.0, 0.0
*       ]),
*       width : 10.0,
*       vertexFormat : Cesium.PolylineMaterialAppearance.VERTEX_FORMAT
*     })
*   }),
*   appearance : new Cesium.PolylineMaterialAppearance({
*     material : Cesium.Material.fromType('Color')
*   })
* });
* @param [options] - Object with the following properties:
* @param [options.translucent = true] - When <code>true</code>, the geometry is expected to appear translucent so {@link PolylineMaterialAppearance#renderState} has alpha blending enabled.
* @param [options.material = Material.ColorType] - The material used to determine the fragment color.
* @param [options.vertexShaderSource] - Optional GLSL vertex shader source to override the default vertex shader.
* @param [options.fragmentShaderSource] - Optional GLSL fragment shader source to override the default fragment shader.
* @param [options.renderState] - Optional render state to override the default render state.
*/
export class PolylineMaterialAppearance {
  constructor(options?: {
    translucent?: boolean;
    material?: Material;
    vertexShaderSource?: string;
    fragmentShaderSource?: string;
    renderState?: any;
  });
  /**
   * The material used to determine the fragment color.  Unlike other {@link PolylineMaterialAppearance}
   * properties, this is not read-only, so an appearance's material can change on the fly.
   */
  material: Material;
  /**
   * When <code>true</code>, the geometry is expected to appear translucent so
   * {@link PolylineMaterialAppearance#renderState} has alpha blending enabled.
   */
  translucent: boolean;
  /**
   * The GLSL source code for the vertex shader.
   */
  readonly vertexShaderSource: string;
  /**
   * The GLSL source code for the fragment shader.
   */
  readonly fragmentShaderSource: string;
  /**
   * The WebGL fixed-function state to use when rendering the geometry.
   * <p>
   * The render state can be explicitly defined when constructing a {@link PolylineMaterialAppearance}
   * instance, or it is set implicitly via {@link PolylineMaterialAppearance#translucent}
   * and {@link PolylineMaterialAppearance#closed}.
   * </p>
   */
  readonly renderState: any;
  /**
   * When <code>true</code>, the geometry is expected to be closed so
   * {@link PolylineMaterialAppearance#renderState} has backface culling enabled.
   * This is always <code>false</code> for <code>PolylineMaterialAppearance</code>.
   */
  readonly closed: boolean;
  /**
   * The {@link VertexFormat} that this appearance instance is compatible with.
   * A geometry can have more vertex attributes and still be compatible - at a
   * potential performance cost - but it can't have less.
   */
  readonly vertexFormat: VertexFormat;
  /**
   * The {@link VertexFormat} that all {@link PolylineMaterialAppearance} instances
   * are compatible with. This requires <code>position</code> and <code>st</code> attributes.
   */
  readonly VERTEX_FORMAT: VertexFormat;
  /**
   * Procedurally creates the full GLSL fragment shader source.  For {@link PolylineMaterialAppearance},
   * this is derived from {@link PolylineMaterialAppearance#fragmentShaderSource} and {@link PolylineMaterialAppearance#material}.
   * @returns The full GLSL fragment shader source.
   */
  getFragmentShaderSource(): string;
  /**
   * Determines if the geometry is translucent based on {@link PolylineMaterialAppearance#translucent} and {@link Material#isTranslucent}.
   * @returns <code>true</code> if the appearance is translucent.
   */
  isTranslucent(): boolean;
  /**
   * Creates a render state.  This is not the final render state instance; instead,
   * it can contain a subset of render state properties identical to the render state
   * created in the context.
   * @returns The render state.
   */
  getRenderState(): any;
}

/**
* Runs a post-process stage on either the texture rendered by the scene or the output of a previous post-process stage.
* @example
* // Simple stage to change the color
* const fs =
*     'uniform sampler2D colorTexture;\n' +
*     'varying vec2 v_textureCoordinates;\n' +
*     'uniform float scale;\n' +
*     'uniform vec3 offset;\n' +
*     'void main() {\n' +
*     '    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n' +
*     '    gl_FragColor = vec4(color.rgb * scale + offset, 1.0);\n' +
*     '}\n';
* scene.postProcessStages.add(new Cesium.PostProcessStage({
*     fragmentShader : fs,
*     uniforms : {
*         scale : 1.1,
*         offset : function() {
*             return new Cesium.Cartesian3(0.1, 0.2, 0.3);
*         }
*     }
* }));
* @example
* // Simple stage to change the color of what is selected.
* // If czm_selected returns true, the current fragment belongs to geometry in the selected array.
* const fs =
*     'uniform sampler2D colorTexture;\n' +
*     'varying vec2 v_textureCoordinates;\n' +
*     'uniform vec4 highlight;\n' +
*     'void main() {\n' +
*     '    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n' +
*     '    if (czm_selected()) {\n' +
*     '        vec3 highlighted = highlight.a * highlight.rgb + (1.0 - highlight.a) * color.rgb;\n' +
*     '        gl_FragColor = vec4(highlighted, 1.0);\n' +
*     '    } else { \n' +
*     '        gl_FragColor = color;\n' +
*     '    }\n' +
*     '}\n';
* const stage = scene.postProcessStages.add(new Cesium.PostProcessStage({
*     fragmentShader : fs,
*     uniforms : {
*         highlight : function() {
*             return new Cesium.Color(1.0, 0.0, 0.0, 0.5);
*         }
*     }
* }));
* stage.selected = [Cesium3DTileFeature];
* @param options - An object with the following properties:
* @param options.fragmentShader - The fragment shader to use. The default <code>sampler2D</code> uniforms are <code>colorTexture</code> and <code>depthTexture</code>. The color texture is the output of rendering the scene or the previous stage. The depth texture is the output from rendering the scene. The shader should contain one or both uniforms. There is also a <code>vec2</code> varying named <code>v_textureCoordinates</code> that can be used to sample the textures.
* @param [options.uniforms] - An object whose properties will be used to set the shaders uniforms. The properties can be constant values or a function. A constant value can also be a URI, data URI, or HTML element to use as a texture.
* @param [options.textureScale = 1.0] - A number in the range (0.0, 1.0] used to scale the texture dimensions. A scale of 1.0 will render this post-process stage  to a texture the size of the viewport.
* @param [options.forcePowerOfTwo = false] - Whether or not to force the texture dimensions to be both equal powers of two. The power of two will be the next power of two of the minimum of the dimensions.
* @param [options.sampleMode = PostProcessStageSampleMode.NEAREST] - How to sample the input color texture.
* @param [options.pixelFormat = PixelFormat.RGBA] - The color pixel format of the output texture.
* @param [options.pixelDatatype = PixelDatatype.UNSIGNED_BYTE] - The pixel data type of the output texture.
* @param [options.clearColor = Color.BLACK] - The color to clear the output texture to.
* @param [options.scissorRectangle] - The rectangle to use for the scissor test.
* @param [options.name = createGuid()] - The unique name of this post-process stage for reference by other stages in a composite. If a name is not supplied, a GUID will be generated.
*/
export class PostProcessStage {
  constructor(options: {
    fragmentShader: string;
    uniforms?: any;
    textureScale?: number;
    forcePowerOfTwo?: boolean;
    sampleMode?: PostProcessStageSampleMode;
    pixelFormat?: PixelFormat;
    pixelDatatype?: PixelDatatype;
    clearColor?: Color;
    scissorRectangle?: BoundingRectangle;
    name?: string;
  });
  /**
   * Whether or not to execute this post-process stage when ready.
   */
  enabled: boolean;
  /**
   * Determines if this post-process stage is ready to be executed. A stage is only executed when both <code>ready</code>
   * and {@link PostProcessStage#enabled} are <code>true</code>. A stage will not be ready while it is waiting on textures
   * to load.
   */
  readonly ready: boolean;
  /**
   * The unique name of this post-process stage for reference by other stages in a {@link PostProcessStageComposite}.
   */
  readonly name: string;
  /**
   * The fragment shader to use when execute this post-process stage.
   * <p>
   * The shader must contain a sampler uniform declaration for <code>colorTexture</code>, <code>depthTexture</code>,
   * or both.
   * </p>
   * <p>
   * The shader must contain a <code>vec2</code> varying declaration for <code>v_textureCoordinates</code> for sampling
   * the texture uniforms.
   * </p>
   */
  readonly fragmentShader: string;
  /**
   * An object whose properties are used to set the uniforms of the fragment shader.
   * <p>
   * The object property values can be either a constant or a function. The function will be called
   * each frame before the post-process stage is executed.
   * </p>
   * <p>
   * A constant value can also be a URI to an image, a data URI, or an HTML element that can be used as a texture, such as HTMLImageElement or HTMLCanvasElement.
   * </p>
   * <p>
   * If this post-process stage is part of a {@link PostProcessStageComposite} that does not execute in series, the constant value can also be
   * the name of another stage in a composite. This will set the uniform to the output texture the stage with that name.
   * </p>
   */
  readonly uniforms: any;
  /**
   * A number in the range (0.0, 1.0] used to scale the output texture dimensions. A scale of 1.0 will render this post-process stage to a texture the size of the viewport.
   */
  readonly textureScale: number;
  /**
   * Whether or not to force the output texture dimensions to be both equal powers of two. The power of two will be the next power of two of the minimum of the dimensions.
   */
  readonly forcePowerOfTwo: number;
  /**
   * How to sample the input color texture.
   */
  readonly sampleMode: PostProcessStageSampleMode;
  /**
   * The color pixel format of the output texture.
   */
  readonly pixelFormat: PixelFormat;
  /**
   * The pixel data type of the output texture.
   */
  readonly pixelDatatype: PixelDatatype;
  /**
   * The color to clear the output texture to.
   */
  readonly clearColor: Color;
  /**
   * The {@link BoundingRectangle} to use for the scissor test. A default bounding rectangle will disable the scissor test.
   */
  readonly scissorRectangle: BoundingRectangle;
  /**
   * The features selected for applying the post-process.
   * <p>
   * In the fragment shader, use <code>czm_selected</code> to determine whether or not to apply the post-process
   * stage to that fragment. For example:
   * <code>
   * if (czm_selected(v_textureCoordinates)) {
   *     // apply post-process stage
   * } else {
   *     gl_FragColor = texture2D(colorTexture, v_textureCordinates);
   * }
   * </code>
   * </p>
   */
  selected: any[];
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <p>
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * </p>
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <p>
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * </p>
   */
  destroy(): void;
}

/**
* A collection of {@link PostProcessStage}s and/or {@link PostProcessStageComposite}s.
* <p>
* The input texture for each post-process stage is the texture rendered to by the scene or the texture rendered
* to by the previous stage in the collection.
* </p>
* <p>
* If the ambient occlusion or bloom stages are enabled, they will execute before all other stages.
* </p>
* <p>
* If the FXAA stage is enabled, it will execute after all other stages.
* </p>
*/
export class PostProcessStageCollection {
  constructor();
  /**
   * Determines if all of the post-process stages in the collection are ready to be executed.
   */
  readonly ready: boolean;
  /**
   * A post-process stage for Fast Approximate Anti-aliasing.
   * <p>
   * When enabled, this stage will execute after all others.
   * </p>
   */
  readonly fxaa: PostProcessStage;
  /**
   * A post-process stage that applies Horizon-based Ambient Occlusion (HBAO) to the input texture.
   * <p>
   * Ambient occlusion simulates shadows from ambient light. These shadows would always be present when the
   * surface receives light and regardless of the light's position.
   * </p>
   * <p>
   * The uniforms have the following properties: <code>intensity</code>, <code>bias</code>, <code>lengthCap</code>,
   * <code>stepSize</code>, <code>frustumLength</code>, <code>ambientOcclusionOnly</code>,
   * <code>delta</code>, <code>sigma</code>, and <code>blurStepSize</code>.
   * </p>
   * <ul>
   * <li><code>intensity</code> is a scalar value used to lighten or darken the shadows exponentially. Higher values make the shadows darker. The default value is <code>3.0</code>.</li>
   *
   * <li><code>bias</code> is a scalar value representing an angle in radians. If the dot product between the normal of the sample and the vector to the camera is less than this value,
   * sampling stops in the current direction. This is used to remove shadows from near planar edges. The default value is <code>0.1</code>.</li>
   *
   * <li><code>lengthCap</code> is a scalar value representing a length in meters. If the distance from the current sample to first sample is greater than this value,
   * sampling stops in the current direction. The default value is <code>0.26</code>.</li>
   *
   * <li><code>stepSize</code> is a scalar value indicating the distance to the next texel sample in the current direction. The default value is <code>1.95</code>.</li>
   *
   * <li><code>frustumLength</code> is a scalar value in meters. If the current fragment has a distance from the camera greater than this value, ambient occlusion is not computed for the fragment.
   * The default value is <code>1000.0</code>.</li>
   *
   * <li><code>ambientOcclusionOnly</code> is a boolean value. When <code>true</code>, only the shadows generated are written to the output. When <code>false</code>, the input texture is modulated
   * with the ambient occlusion. This is a useful debug option for seeing the effects of changing the uniform values. The default value is <code>false</code>.</li>
   * </ul>
   * <p>
   * <code>delta</code>, <code>sigma</code>, and <code>blurStepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.
   * The blur is applied to the shadows generated from the image to make them smoother.
   * </p>
   * <p>
   * When enabled, this stage will execute before all others.
   * </p>
   */
  readonly ambientOcclusion: PostProcessStageComposite;
  /**
   * A post-process stage for a bloom effect.
   * <p>
   * A bloom effect adds glow effect, makes bright areas brighter, and dark areas darker.
   * </p>
   * <p>
   * This stage has the following uniforms: <code>contrast</code>, <code>brightness</code>, <code>glowOnly</code>,
   * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.
   * </p>
   * <ul>
   * <li><code>contrast</code> is a scalar value in the range [-255.0, 255.0] and affects the contract of the effect. The default value is <code>128.0</code>.</li>
   *
   * <li><code>brightness</code> is a scalar value. The input texture RGB value is converted to hue, saturation, and brightness (HSB) then this value is
   * added to the brightness. The default value is <code>-0.3</code>.</li>
   *
   * <li><code>glowOnly</code> is a boolean value. When <code>true</code>, only the glow effect will be shown. When <code>false</code>, the glow will be added to the input texture.
   * The default value is <code>false</code>. This is a debug option for viewing the effects when changing the other uniform values.</li>
   * </ul>
   * <p>
   * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.
   * The blur is applied to the shadows generated from the image to make them smoother.
   * </p>
   * <p>
   * When enabled, this stage will execute before all others.
   * </p>
   */
  readonly bloom: PostProcessStageComposite;
  /**
   * The number of post-process stages in this collection.
   */
  readonly length: number;
  /**
   * Adds the post-process stage to the collection.
   * @param stage - The post-process stage to add to the collection.
   * @returns The post-process stage that was added to the collection.
   */
  add(stage: PostProcessStage | PostProcessStageComposite): PostProcessStage | PostProcessStageComposite;
  /**
   * Removes a post-process stage from the collection and destroys it.
   * @param stage - The post-process stage to remove from the collection.
   * @returns Whether the post-process stage was removed.
   */
  remove(stage: PostProcessStage | PostProcessStageComposite): boolean;
  /**
   * Returns whether the collection contains a post-process stage.
   * @param stage - The post-process stage.
   * @returns Whether the collection contains the post-process stage.
   */
  contains(stage: PostProcessStage | PostProcessStageComposite): boolean;
  /**
   * Gets the post-process stage at <code>index</code>.
   * @param index - The index of the post-process stage.
   * @returns The post-process stage at index.
   */
  get(index: number): PostProcessStage | PostProcessStageComposite;
  /**
   * Removes all post-process stages from the collection and destroys them.
   */
  removeAll(): void;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <p>
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * </p>
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <p>
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * </p>
   */
  destroy(): void;
}

/**
* A collection of {@link PostProcessStage}s or other post-process composite stages that execute together logically.
* <p>
* All stages are executed in the order of the array. The input texture changes based on the value of <code>inputPreviousStageTexture</code>.
* If <code>inputPreviousStageTexture</code> is <code>true</code>, the input to each stage is the output texture rendered to by the scene or of the stage that executed before it.
* If <code>inputPreviousStageTexture</code> is <code>false</code>, the input texture is the same for each stage in the composite. The input texture is the texture rendered to by the scene
* or the output texture of the previous stage.
* </p>
* @example
* // Example 1: separable blur filter
* // The input to blurXDirection is the texture rendered to by the scene or the output of the previous stage.
* // The input to blurYDirection is the texture rendered to by blurXDirection.
* scene.postProcessStages.add(new Cesium.PostProcessStageComposite({
*     stages : [blurXDirection, blurYDirection]
* }));
* @example
* // Example 2: referencing the output of another post-process stage
* scene.postProcessStages.add(new Cesium.PostProcessStageComposite({
*     inputPreviousStageTexture : false,
*     stages : [
*         // The same as Example 1.
*         new Cesium.PostProcessStageComposite({
*             inputPreviousStageTexture : true
*             stages : [blurXDirection, blurYDirection],
*             name : 'blur'
*         }),
*         // The input texture for this stage is the same input texture to blurXDirection since inputPreviousStageTexture is false
*         new Cesium.PostProcessStage({
*             fragmentShader : compositeShader,
*             uniforms : {
*                 blurTexture : 'blur' // The output of the composite with name 'blur' (the texture that blurYDirection rendered to).
*             }
*         })
*     ]
* });
* @example
* // Example 3: create a uniform alias
* const uniforms = {};
* Cesium.defineProperties(uniforms, {
*     filterSize : {
*         get : function() {
*             return blurXDirection.uniforms.filterSize;
*         },
*         set : function(value) {
*             blurXDirection.uniforms.filterSize = blurYDirection.uniforms.filterSize = value;
*         }
*     }
* });
* scene.postProcessStages.add(new Cesium.PostProcessStageComposite({
*     stages : [blurXDirection, blurYDirection],
*     uniforms : uniforms
* }));
* @param options - An object with the following properties:
* @param options.stages - An array of {@link PostProcessStage}s or composites to be executed in order.
* @param [options.inputPreviousStageTexture = true] - Whether to execute each post-process stage where the input to one stage is the output of the previous. Otherwise, the input to each contained stage is the output of the stage that executed before the composite.
* @param [options.name = createGuid()] - The unique name of this post-process stage for reference by other composites. If a name is not supplied, a GUID will be generated.
* @param [options.uniforms] - An alias to the uniforms of post-process stages.
*/
export class PostProcessStageComposite {
  constructor(options: {
    stages: any[];
    inputPreviousStageTexture?: boolean;
    name?: string;
    uniforms?: any;
  });
  /**
   * Determines if this post-process stage is ready to be executed.
   */
  readonly ready: boolean;
  /**
   * The unique name of this post-process stage for reference by other stages in a PostProcessStageComposite.
   */
  readonly name: string;
  /**
   * Whether or not to execute this post-process stage when ready.
   */
  enabled: boolean;
  /**
   * An alias to the uniform values of the post-process stages. May be <code>undefined</code>; in which case, get each stage to set uniform values.
   */
  uniforms: any;
  /**
   * All post-process stages are executed in the order of the array. The input texture changes based on the value of <code>inputPreviousStageTexture</code>.
   * If <code>inputPreviousStageTexture</code> is <code>true</code>, the input to each stage is the output texture rendered to by the scene or of the stage that executed before it.
   * If <code>inputPreviousStageTexture</code> is <code>false</code>, the input texture is the same for each stage in the composite. The input texture is the texture rendered to by the scene
   * or the output texture of the previous stage.
   */
  readonly inputPreviousStageTexture: boolean;
  /**
   * The number of post-process stages in this composite.
   */
  readonly length: number;
  /**
   * The features selected for applying the post-process.
   */
  selected: any[];
  /**
   * Gets the post-process stage at <code>index</code>
   * @param index - The index of the post-process stage or composite.
   * @returns The post-process stage or composite at index.
   */
  get(index: number): PostProcessStage | PostProcessStageComposite;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <p>
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * </p>
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <p>
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * </p>
   */
  destroy(): void;
}

/**
* Contains functions for creating common post-process stages.
*/
export namespace PostProcessStageLibrary {
  /**
   * Creates a post-process stage that applies a Gaussian blur to the input texture. This stage is usually applied in conjunction with another stage.
   * <p>
   * This stage has the following uniforms: <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.
   * </p>
   * <p>
   * <code>delta</code> and <code>sigma</code> are used to compute the weights of a Gaussian filter. The equation is <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>.
   * The default value for <code>delta</code> is <code>1.0</code>. The default value for <code>sigma</code> is <code>2.0</code>.
   * <code>stepSize</code> is the distance to the next texel. The default is <code>1.0</code>.
   * </p>
   * @returns A post-process stage that applies a Gaussian blur to the input texture.
   */
  function createBlurStage(): PostProcessStageComposite;
  /**
   * Creates a post-process stage that applies a depth of field effect.
   * <p>
   * Depth of field simulates camera focus. Objects in the scene that are in focus
   * will be clear whereas objects not in focus will be blurred.
   * </p>
   * <p>
   * This stage has the following uniforms: <code>focalDistance</code>, <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.
   * </p>
   * <p>
   * <code>focalDistance</code> is the distance in meters from the camera to set the camera focus.
   * </p>
   * <p>
   * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.
   * The blur is applied to the areas out of focus.
   * </p>
   * @returns A post-process stage that applies a depth of field effect.
   */
  function createDepthOfFieldStage(): PostProcessStageComposite;
  /**
   * Whether or not a depth of field stage is supported.
   * <p>
   * This stage requires the WEBGL_depth_texture extension.
   * </p>
   * @param scene - The scene.
   * @returns Whether this post process stage is supported.
   */
  function isDepthOfFieldSupported(scene: Scene): boolean;
  /**
   * Creates a post-process stage that detects edges.
   * <p>
   * Writes the color to the output texture with alpha set to 1.0 when it is on an edge.
   * </p>
   * <p>
   * This stage has the following uniforms: <code>color</code> and <code>length</code>
   * </p>
   * <ul>
   * <li><code>color</code> is the color of the highlighted edge. The default is {@link Color#BLACK}.</li>
   * <li><code>length</code> is the length of the edges in pixels. The default is <code>0.5</code>.</li>
   * </ul>
   * <p>
   * This stage is not supported in 2D.
   * </p>
   * @example
   * // multiple silhouette effects
   * const yellowEdge = Cesium.PostProcessLibrary.createEdgeDetectionStage();
   * yellowEdge.uniforms.color = Cesium.Color.YELLOW;
   * yellowEdge.selected = [feature0];
   *
   * const greenEdge = Cesium.PostProcessLibrary.createEdgeDetectionStage();
   * greenEdge.uniforms.color = Cesium.Color.LIME;
   * greenEdge.selected = [feature1];
   *
   * // draw edges around feature0 and feature1
   * postProcessStages.add(Cesium.PostProcessLibrary.createSilhouetteStage([yellowEdge, greenEdge]);
   * @returns A post-process stage that applies an edge detection effect.
   */
  function createEdgeDetectionStage(): PostProcessStage;
  /**
   * Whether or not an edge detection stage is supported.
   * <p>
   * This stage requires the WEBGL_depth_texture extension.
   * </p>
   * @param scene - The scene.
   * @returns Whether this post process stage is supported.
   */
  function isEdgeDetectionSupported(scene: Scene): boolean;
  /**
   * Creates a post-process stage that applies a silhouette effect.
   * <p>
   * A silhouette effect composites the color from the edge detection pass with input color texture.
   * </p>
   * <p>
   * This stage has the following uniforms when <code>edgeDetectionStages</code> is <code>undefined</code>: <code>color</code> and <code>length</code>
   * </p>
   * <p>
   * <code>color</code> is the color of the highlighted edge. The default is {@link Color#BLACK}.
   * <code>length</code> is the length of the edges in pixels. The default is <code>0.5</code>.
   * </p>
   * @param [edgeDetectionStages] - An array of edge detection post process stages.
   * @returns A post-process stage that applies a silhouette effect.
   */
  function createSilhouetteStage(edgeDetectionStages?: PostProcessStage[]): PostProcessStageComposite;
  /**
   * Whether or not a silhouette stage is supported.
   * <p>
   * This stage requires the WEBGL_depth_texture extension.
   * </p>
   * @param scene - The scene.
   * @returns Whether this post process stage is supported.
   */
  function isSilhouetteSupported(scene: Scene): boolean;
  /**
   * Whether or not an ambient occlusion stage is supported.
   * <p>
   * This stage requires the WEBGL_depth_texture extension.
   * </p>
   * @param scene - The scene.
   * @returns Whether this post process stage is supported.
   */
  function isAmbientOcclusionSupported(scene: Scene): boolean;
  /**
   * Creates a post-process stage that renders the input texture with black and white gradations.
   * <p>
   * This stage has one uniform value, <code>gradations</code>, which scales the luminance of each pixel.
   * </p>
   * @returns A post-process stage that renders the input texture with black and white gradations.
   */
  function createBlackAndWhiteStage(): PostProcessStage;
  /**
   * Creates a post-process stage that saturates the input texture.
   * <p>
   * This stage has one uniform value, <code>brightness</code>, which scales the saturation of each pixel.
   * </p>
   * @returns A post-process stage that saturates the input texture.
   */
  function createBrightnessStage(): PostProcessStage;
  /**
   * Creates a post-process stage that adds a night vision effect to the input texture.
   * @returns A post-process stage that adds a night vision effect to the input texture.
   */
  function createNightVisionStage(): PostProcessStage;
  /**
   * Creates a post-process stage that applies an effect simulating light flaring a camera lens.
   * <p>
   * This stage has the following uniforms: <code>dirtTexture</code>, <code>starTexture</code>, <code>intensity</code>, <code>distortion</code>, <code>ghostDispersal</code>,
   * <code>haloWidth</code>, <code>dirtAmount</code>, and <code>earthRadius</code>.
   * <ul>
   * <li><code>dirtTexture</code> is a texture sampled to simulate dirt on the lens.</li>
   * <li><code>starTexture</code> is the texture sampled for the star pattern of the flare.</li>
   * <li><code>intensity</code> is a scalar multiplied by the result of the lens flare. The default value is <code>2.0</code>.</li>
   * <li><code>distortion</code> is a scalar value that affects the chromatic effect distortion. The default value is <code>10.0</code>.</li>
   * <li><code>ghostDispersal</code> is a scalar indicating how far the halo effect is from the center of the texture. The default value is <code>0.4</code>.</li>
   * <li><code>haloWidth</code> is a scalar representing the width of the halo  from the ghost dispersal. The default value is <code>0.4</code>.</li>
   * <li><code>dirtAmount</code> is a scalar representing the amount of dirt on the lens. The default value is <code>0.4</code>.</li>
   * <li><code>earthRadius</code> is the maximum radius of the earth. The default value is <code>Ellipsoid.WGS84.maximumRadius</code>.</li>
   * </ul>
   * </p>
   * @returns A post-process stage for applying a lens flare effect.
   */
  function createLensFlareStage(): PostProcessStage;
}

/**
* Determines how input texture to a {@link PostProcessStage} is sampled.
*/
export enum PostProcessStageSampleMode {
  /**
   * Samples the texture by returning the closest texel.
   */
  NEAREST = 0,
  /**
   * Samples the texture through bi-linear interpolation of the four nearest texels.
   */
  LINEAR = 1
}

/**
* A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}
* as shown in example 1 below, or from an array of instances, even if the geometry is from different
* geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.
* <p>
* A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including
* {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
* and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
* and match most of them and add a new geometry or appearance independently of each other.
* </p>
* <p>
* Combining multiple instances into one primitive is called batching, and significantly improves performance for  data.
* Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using
* per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.
* </p>
* <p>
* {@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples
* show geometry that will be created on a web worker by using the descriptions of the geometry. The third example
* shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.
* </p>
* @example
* // 1. Draw a translucent ellipse on the surface with a checkerboard pattern
* const instance = new Cesium.GeometryInstance({
*   geometry : new Cesium.EllipseGeometry({
*       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),
*       semiMinorAxis : 500000.0,
*       semiMajorAxis : 1000000.0,
*       rotation : Cesium.Math.PI_OVER_FOUR,
*       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST
*   }),
*   id : 'object returned when this instance is picked and to get/set per-instance attributes'
* });
* scene.primitives.add(new Cesium.Primitive({
*   geometryInstances : instance,
*   appearance : new Cesium.EllipsoidSurfaceAppearance({
*     material : Cesium.Material.fromType('Checkerboard')
*   })
* }));
* @example
* // 2. Draw different instances each with a unique color
* const rectangleInstance = new Cesium.GeometryInstance({
*   geometry : new Cesium.RectangleGeometry({
*     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0),
*     vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
*   }),
*   id : 'rectangle',
*   attributes : {
*     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)
*   }
* });
* const ellipsoidInstance = new Cesium.GeometryInstance({
*   geometry : new Cesium.EllipsoidGeometry({
*     radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),
*     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL
*   }),
*   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
*     Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),
*   id : 'ellipsoid',
*   attributes : {
*     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)
*   }
* });
* scene.primitives.add(new Cesium.Primitive({
*   geometryInstances : [rectangleInstance, ellipsoidInstance],
*   appearance : new Cesium.PerInstanceColorAppearance()
* }));
* @example
* // 3. Create the geometry on the main thread.
* scene.primitives.add(new Cesium.Primitive({
*   geometryInstances : new Cesium.GeometryInstance({
*     geometry : Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({
*       radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),
*       vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL
*     })),
*     modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
*       Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),
*     id : 'ellipsoid',
*     attributes : {
*       color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)
*     }
*   }),
*   appearance : new Cesium.PerInstanceColorAppearance(),
*   asynchronous : false
* }));
* @param [options] - Object with the following properties:
* @param [options.geometryInstances] - The geometry instances - or a single geometry instance - to render.
* @param [options.appearance] - The appearance used to render the primitive.
* @param [options.depthFailAppearance] - The appearance used to shade this primitive when it fails the depth test.
* @param [options.show = true] - Determines if this primitive will be shown.
* @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.
* @param [options.vertexCacheOptimize = false] - When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
* @param [options.interleave = false] - When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
* @param [options.compressVertices = true] - When <code>true</code>, the geometry vertices are compressed, which will save memory.
* @param [options.releaseGeometryInstances = true] - When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
* @param [options.allowPicking = true] - When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
* @param [options.cull = true] - When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume.  Set this to <code>false</code> for a small performance gain if you are manually culling the primitive.
* @param [options.asynchronous = true] - Determines if the primitive will be created asynchronously or block until ready.
* @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
* @param [options.shadows = ShadowMode.DISABLED] - Determines whether this primitive casts or receives shadows from light sources.
*/
export class Primitive {
  constructor(options?: {
    geometryInstances?: GeometryInstance[] | GeometryInstance;
    appearance?: Appearance;
    depthFailAppearance?: Appearance;
    show?: boolean;
    modelMatrix?: Matrix4;
    vertexCacheOptimize?: boolean;
    interleave?: boolean;
    compressVertices?: boolean;
    releaseGeometryInstances?: boolean;
    allowPicking?: boolean;
    cull?: boolean;
    asynchronous?: boolean;
    debugShowBoundingVolume?: boolean;
    shadows?: ShadowMode;
  });
  /**
   * The geometry instances rendered with this primitive.  This may
   * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
   * is <code>true</code> when the primitive is constructed.
   * <p>
   * Changing this property after the primitive is rendered has no effect.
   * </p>
   */
  readonly geometryInstances: GeometryInstance[] | GeometryInstance;
  /**
   * The {@link Appearance} used to shade this primitive. Each geometry
   * instance is shaded with the same appearance.  Some appearances, like
   * {@link PerInstanceColorAppearance} allow giving each instance unique
   * properties.
   */
  appearance: Appearance;
  /**
   * The {@link Appearance} used to shade this primitive when it fails the depth test. Each geometry
   * instance is shaded with the same appearance.  Some appearances, like
   * {@link PerInstanceColorAppearance} allow giving each instance unique
   * properties.
   *
   * <p>
   * When using an appearance that requires a color attribute, like PerInstanceColorAppearance,
   * add a depthFailColor per-instance attribute instead.
   * </p>
   *
   * <p>
   * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,
   * there may be artifacts.
   * </p>
   */
  depthFailAppearance: Appearance;
  /**
   * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.
   * When this is the identity matrix, the primitive is drawn in world coordinates, i.e., Earth's WGS84 coordinates.
   * Local reference frames can be used by providing a different transformation matrix, like that returned
   * by {@link Transforms.eastNorthUpToFixedFrame}.
   *
   * <p>
   * This property is only supported in 3D mode.
   * </p>
   * @example
   * const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);
   * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);
   */
  modelMatrix: Matrix4;
  /**
   * Determines if the primitive will be shown.  This affects all geometry
   * instances in the primitive.
   */
  show: boolean;
  /**
   * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands
   * based on their bounding volume.  Set this to <code>false</code> for a small performance gain
   * if you are manually culling the primitive.
   */
  cull: boolean;
  /**
   * This property is for debugging only; it is not for production use nor is it optimized.
   * <p>
   * Draws the bounding sphere for each draw command in the primitive.
   * </p>
   */
  debugShowBoundingVolume: boolean;
  /**
   * Determines whether this primitive casts or receives shadows from light sources.
   */
  shadows: ShadowMode;
  /**
   * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
   */
  readonly vertexCacheOptimize: boolean;
  /**
   * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
   */
  readonly interleave: boolean;
  /**
   * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
   */
  readonly releaseGeometryInstances: boolean;
  /**
   * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *
   */
  readonly allowPicking: boolean;
  /**
   * Determines if the geometry instances will be created and batched on a web worker.
   */
  readonly asynchronous: boolean;
  /**
   * When <code>true</code>, geometry vertices are compressed, which will save memory.
   */
  readonly compressVertices: boolean;
  /**
   * Determines if the primitive is complete and ready to render.  If this property is
   * true, the primitive will be rendered the next time that {@link Primitive#update}
   * is called.
   */
  readonly ready: boolean;
  /**
   * Gets a promise that resolves when the primitive is ready to render.
   */
  readonly readyPromise: Promise<Primitive>;
  /**
   * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
   * get the draw commands needed to render this primitive.
   * <p>
   * Do not call this function directly.  This is documented just to
   * list the exceptions that may be propagated when the scene is rendered:
   * </p>
   */
  update(): void;
  /**
   * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
   * @example
   * const attributes = primitive.getGeometryInstanceAttributes('an id');
   * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
   * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
   * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);
   * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);
   * @param id - The id of the {@link GeometryInstance}.
   * @returns The typed array in the attribute's format or undefined if the is no instance with id.
   */
  getGeometryInstanceAttributes(id: any): any;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <p>
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * </p>
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <p>
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * </p>
   * @example
   * e = e && e.destroy();
   */
  destroy(): void;
}

/**
* A collection of primitives.  This is most often used with {@link Scene#primitives},
* but <code>PrimitiveCollection</code> is also a primitive itself so collections can
* be added to collections forming a hierarchy.
* @example
* const billboards = new Cesium.BillboardCollection();
* const labels = new Cesium.LabelCollection();
*
* const collection = new Cesium.PrimitiveCollection();
* collection.add(billboards);
*
* scene.primitives.add(collection);  // Add collection
* scene.primitives.add(labels);      // Add regular primitive
* @param [options] - Object with the following properties:
* @param [options.show = true] - Determines if the primitives in the collection will be shown.
* @param [options.destroyPrimitives = true] - Determines if primitives in the collection are destroyed when they are removed.
*/
export class PrimitiveCollection {
  constructor(options?: {
    show?: boolean;
    destroyPrimitives?: boolean;
  });
  /**
   * Determines if primitives in this collection will be shown.
   */
  show: boolean;
  /**
   * Determines if primitives in the collection are destroyed when they are removed by
   * {@link PrimitiveCollection#destroy} or  {@link PrimitiveCollection#remove} or implicitly
   * by {@link PrimitiveCollection#removeAll}.
   * @example
   * // Example 1. Primitives are destroyed by default.
   * const primitives = new Cesium.PrimitiveCollection();
   * const labels = primitives.add(new Cesium.LabelCollection());
   * primitives = primitives.destroy();
   * const b = labels.isDestroyed(); // true
   * @example
   * // Example 2. Do not destroy primitives in a collection.
   * const primitives = new Cesium.PrimitiveCollection();
   * primitives.destroyPrimitives = false;
   * const labels = primitives.add(new Cesium.LabelCollection());
   * primitives = primitives.destroy();
   * const b = labels.isDestroyed(); // false
   * labels = labels.destroy();    // explicitly destroy
   */
  destroyPrimitives: boolean;
  /**
   * Gets the number of primitives in the collection.
   */
  readonly length: number;
  /**
   * Adds a primitive to the collection.
   * @example
   * const billboards = scene.primitives.add(new Cesium.BillboardCollection());
   * @param primitive - The primitive to add.
   * @param [index] - The index to add the layer at.  If omitted, the primitive will be added at the bottom of all existing primitives.
   * @returns The primitive added to the collection.
   */
  add(primitive: any, index?: number): any;
  /**
   * Removes a primitive from the collection.
   * @example
   * const billboards = scene.primitives.add(new Cesium.BillboardCollection());
   * scene.primitives.remove(billboards);  // Returns true
   * @param [primitive] - The primitive to remove.
   * @returns <code>true</code> if the primitive was removed; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.
   */
  remove(primitive?: any): boolean;
  /**
   * Removes all primitives in the collection.
   */
  removeAll(): void;
  /**
   * Determines if this collection contains a primitive.
   * @param [primitive] - The primitive to check for.
   * @returns <code>true</code> if the primitive is in the collection; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.
   */
  contains(primitive?: any): boolean;
  /**
   * Raises a primitive "up one" in the collection.  If all primitives in the collection are drawn
   * on the globe surface, this visually moves the primitive up one.
   * @param [primitive] - The primitive to raise.
   */
  raise(primitive?: any): void;
  /**
   * Raises a primitive to the "top" of the collection.  If all primitives in the collection are drawn
   * on the globe surface, this visually moves the primitive to the top.
   * @param [primitive] - The primitive to raise the top.
   */
  raiseToTop(primitive?: any): void;
  /**
   * Lowers a primitive "down one" in the collection.  If all primitives in the collection are drawn
   * on the globe surface, this visually moves the primitive down one.
   * @param [primitive] - The primitive to lower.
   */
  lower(primitive?: any): void;
  /**
   * Lowers a primitive to the "bottom" of the collection.  If all primitives in the collection are drawn
   * on the globe surface, this visually moves the primitive to the bottom.
   * @param [primitive] - The primitive to lower to the bottom.
   */
  lowerToBottom(primitive?: any): void;
  /**
   * Returns the primitive in the collection at the specified index.
   * @example
   * // Toggle the show property of every primitive in the collection.
   * const primitives = scene.primitives;
   * const length = primitives.length;
   * for (let i = 0; i < length; ++i) {
   *   const p = primitives.get(i);
   *   p.show = !p.show;
   * }
   * @param index - The zero-based index of the primitive to return.
   * @returns The primitive at the <code>index</code>.
   */
  get(index: number): any;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns True if this object was destroyed; otherwise, false.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this
   * collection allows for deterministic release of WebGL resources, instead of relying on the garbage
   * collector to destroy this collection.
   * <br /><br />
   * Since destroying a collection destroys all the contained primitives, only destroy a collection
   * when you are sure no other code is still using any of the contained primitives.
   * <br /><br />
   * Once this collection is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * primitives = primitives && primitives.destroy();
   */
  destroy(): void;
}

/**
* The container for all 3D graphical objects and state in a Cesium virtual scene.  Generally,
* a scene is not created directly; instead, it is implicitly created by {@link CesiumWidget}.
* <p>
* <em><code>contextOptions</code> parameter details:</em>
* </p>
* <p>
* The default values are:
* <code>
* {
*   webgl : {
*     alpha : false,
*     depth : true,
*     stencil : false,
*     antialias : true,
*     powerPreference: 'high-performance',
*     premultipliedAlpha : true,
*     preserveDrawingBuffer : false,
*     failIfMajorPerformanceCaveat : false
*   },
*   allowTextureFilterAnisotropic : true
* }
* </code>
* </p>
* <p>
* The <code>webgl</code> property corresponds to the {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}
* object used to create the WebGL context.
* </p>
* <p>
* <code>webgl.alpha</code> defaults to false, which can improve performance compared to the standard WebGL default
* of true.  If an application needs to composite Cesium above other HTML elements using alpha-blending, set
* <code>webgl.alpha</code> to true.
* </p>
* <p>
* The other <code>webgl</code> properties match the WebGL defaults for {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}.
* </p>
* <p>
* <code>allowTextureFilterAnisotropic</code> defaults to true, which enables anisotropic texture filtering when the
* WebGL extension is supported.  Setting this to false will improve performance, but hurt visual quality, especially for horizon views.
* </p>
* @example
* // Create scene without anisotropic texture filtering
* const scene = new Cesium.Scene({
*   canvas : canvas,
*   contextOptions : {
*     allowTextureFilterAnisotropic : false
*   }
* });
* @param options - Object with the following properties:
* @param options.canvas - The HTML canvas element to create the scene for.
* @param [options.contextOptions] - Context and WebGL creation properties.  See details above.
* @param [options.creditContainer] - The HTML element in which the credits will be displayed.
* @param [options.creditViewport] - The HTML element in which to display the credit popup.  If not specified, the viewport will be a added as a sibling of the canvas.
* @param [options.mapProjection = new GeographicProjection()] - The map projection to use in 2D and Columbus View modes.
* @param [options.orderIndependentTranslucency = true] - If true and the configuration supports it, use order independent translucency.
* @param [options.scene3DOnly = false] - If true, optimizes memory use and performance for 3D mode but disables the ability to use 2D or Columbus View.
* @param [options.shadows = false] - Determines if shadows are cast by light sources.
* @param [options.mapMode2D = MapMode2D.INFINITE_SCROLL] - Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
* @param [options.requestRenderMode = false] - If true, rendering a frame will only occur when needed as determined by changes within the scene. Enabling improves performance of the application.
* @param [options.maximumRenderTimeChange = 0.0] - If requestRenderMode is true, this value defines the maximum change in simulation time allowed before a render is requested.
* @param [depthPlaneEllipsoidOffset = 0.0] - Adjust the DepthPlane to address rendering artefacts below ellipsoid zero elevation.
* @param [options.msaaSamples = 1] - If provided, this value controls the rate of multisample antialiasing. Typical multisampling rates are 2, 4, and sometimes 8 samples per pixel. Higher sampling rates of MSAA may impact performance in exchange for improved visual quality. This value only applies to WebGL2 contexts that support multisample render targets.
*/
export class Scene {
  constructor(options: {
    canvas: HTMLCanvasElement;
    contextOptions?: any;
    creditContainer?: Element;
    creditViewport?: Element;
    mapProjection?: MapProjection;
    orderIndependentTranslucency?: boolean;
    scene3DOnly?: boolean;
    shadows?: boolean;
    mapMode2D?: MapMode2D;
    requestRenderMode?: boolean;
    maximumRenderTimeChange?: number;
    msaaSamples?: number;
  }, depthPlaneEllipsoidOffset?: number);
  /**
   * Exceptions occurring in <code>render</code> are always caught in order to raise the
   * <code>renderError</code> event.  If this property is true, the error is rethrown
   * after the event is raised.  If this property is false, the <code>render</code> function
   * returns normally after raising the event.
   */
  rethrowRenderErrors: boolean;
  /**
   * Determines whether or not to instantly complete the
   * scene transition animation on user input.
   */
  completeMorphOnUserInput: boolean;
  /**
   * The event fired at the beginning of a scene transition.
   */
  morphStart: Event;
  /**
   * The event fired at the completion of a scene transition.
   */
  morphComplete: Event;
  /**
   * The {@link SkyBox} used to draw the stars.
   */
  skyBox: SkyBox;
  /**
   * The sky atmosphere drawn around the globe.
   */
  skyAtmosphere: SkyAtmosphere;
  /**
   * The {@link Sun}.
   */
  sun: Sun;
  /**
   * Uses a bloom filter on the sun when enabled.
   */
  sunBloom: boolean;
  /**
   * The {@link Moon}
   */
  moon: Moon;
  /**
   * The background color, which is only visible if there is no sky box, i.e., {@link Scene#skyBox} is undefined.
   */
  backgroundColor: Color;
  /**
   * The current morph transition time between 2D/Columbus View and 3D,
   * with 0.0 being 2D or Columbus View and 1.0 being 3D.
   */
  morphTime: number;
  /**
   * The far-to-near ratio of the multi-frustum when using a normal depth buffer.
   * <p>
   * This value is used to create the near and far values for each frustum of the multi-frustum. It is only used
   * when {@link Scene#logarithmicDepthBuffer} is <code>false</code>. When <code>logarithmicDepthBuffer</code> is
   * <code>true</code>, use {@link Scene#logarithmicDepthFarToNearRatio}.
   * </p>
   */
  farToNearRatio: number;
  /**
   * The far-to-near ratio of the multi-frustum when using a logarithmic depth buffer.
   * <p>
   * This value is used to create the near and far values for each frustum of the multi-frustum. It is only used
   * when {@link Scene#logarithmicDepthBuffer} is <code>true</code>. When <code>logarithmicDepthBuffer</code> is
   * <code>false</code>, use {@link Scene#farToNearRatio}.
   * </p>
   */
  logarithmicDepthFarToNearRatio: number;
  /**
   * Determines the uniform depth size in meters of each frustum of the multifrustum in 2D. If a primitive or model close
   * to the surface shows z-fighting, decreasing this will eliminate the artifact, but decrease performance. On the
   * other hand, increasing this will increase performance but may cause z-fighting among primitives close to the surface.
   */
  nearToFarDistance2D: number;
  /**
   * This property is for debugging only; it is not for production use.
   * <p>
   * A function that determines what commands are executed.  As shown in the examples below,
   * the function receives the command's <code>owner</code> as an argument, and returns a boolean indicating if the
   * command should be executed.
   * </p>
   * <p>
   * The default is <code>undefined</code>, indicating that all commands are executed.
   * </p>
   * @example
   * // Do not execute any commands.
   * scene.debugCommandFilter = function(command) {
   *     return false;
   * };
   *
   * // Execute only the billboard's commands.  That is, only draw the billboard.
   * const billboards = new Cesium.BillboardCollection();
   * scene.debugCommandFilter = function(command) {
   *     return command.owner === billboards;
   * };
   */
  debugCommandFilter: (...params: any[]) => any;
  /**
   * This property is for debugging only; it is not for production use.
   * <p>
   * When <code>true</code>, commands are randomly shaded.  This is useful
   * for performance analysis to see what parts of a scene or model are
   * command-dense and could benefit from batching.
   * </p>
   */
  debugShowCommands: boolean;
  /**
   * This property is for debugging only; it is not for production use.
   * <p>
   * When <code>true</code>, commands are shaded based on the frustums they
   * overlap.  Commands in the closest frustum are tinted red, commands in
   * the next closest are green, and commands in the farthest frustum are
   * blue.  If a command overlaps more than one frustum, the color components
   * are combined, e.g., a command overlapping the first two frustums is tinted
   * yellow.
   * </p>
   */
  debugShowFrustums: boolean;
  /**
   * This property is for debugging only; it is not for production use.
   * <p>
   * Displays frames per second and time between frames.
   * </p>
   */
  debugShowFramesPerSecond: boolean;
  /**
   * This property is for debugging only; it is not for production use.
   * <p>
   * Indicates which frustum will have depth information displayed.
   * </p>
   */
  debugShowDepthFrustum: number;
  /**
   * This property is for debugging only; it is not for production use.
   * <p>
   * When <code>true</code>, draws outlines to show the boundaries of the camera frustums
   * </p>
   */
  debugShowFrustumPlanes: boolean;
  /**
   * When <code>true</code>, enables picking using the depth buffer.
   */
  useDepthPicking: boolean;
  /**
   * When <code>true</code>, enables picking translucent geometry using the depth buffer. Note that {@link Scene#useDepthPicking} must also be true for enabling this to work.
   *
   * <p>
   * There is a decrease in performance when enabled. There are extra draw calls to write depth for
   * translucent geometry.
   * </p>
   * @example
   * // picking the position of a translucent primitive
   * viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {
   *      const pickedFeature = viewer.scene.pick(movement.position);
   *      if (!Cesium.defined(pickedFeature)) {
   *          // nothing picked
   *          return;
   *      }
   *      const worldPosition = viewer.scene.pickPosition(movement.position);
   * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
   */
  pickTranslucentDepth: boolean;
  /**
   * Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional
   * performance improvements by rendering less geometry and dispatching less terrain requests.
   */
  fog: Fog;
  /**
   * The shadow map for the scene's light source. When enabled, models, primitives, and the globe may cast and receive shadows.
   */
  shadowMap: ShadowMap;
  /**
   * When <code>false</code>, 3D Tiles will render normally. When <code>true</code>, classified 3D Tile geometry will render normally and
   * unclassified 3D Tile geometry will render with the color multiplied by {@link Scene#invertClassificationColor}.
   */
  invertClassification: boolean;
  /**
   * The highlight color of unclassified 3D Tile geometry when {@link Scene#invertClassification} is <code>true</code>.
   * <p>When the color's alpha is less than 1.0, the unclassified portions of the 3D Tiles will not blend correctly with the classified positions of the 3D Tiles.</p>
   * <p>Also, when the color's alpha is less than 1.0, the WEBGL_depth_texture and EXT_frag_depth WebGL extensions must be supported.</p>
   */
  invertClassificationColor: Color;
  /**
   * The focal length for use when with cardboard or WebVR.
   */
  focalLength: number;
  /**
   * The eye separation distance in meters for use with cardboard or WebVR.
   */
  eyeSeparation: number;
  /**
   * Post processing effects applied to the final render.
   */
  postProcessStages: PostProcessStageCollection;
  /**
   * When <code>true</code>, rendering a frame will only occur when needed as determined by changes within the scene.
   * Enabling improves performance of the application, but requires using {@link Scene#requestRender}
   * to render a new frame explicitly in this mode. This will be necessary in many cases after making changes
   * to the scene in other parts of the API.
   */
  requestRenderMode: boolean;
  /**
   * If {@link Scene#requestRenderMode} is <code>true</code>, this value defines the maximum change in
   * simulation time allowed before a render is requested. Lower values increase the number of frames rendered
   * and higher values decrease the number of frames rendered. If <code>undefined</code>, changes to
   * the simulation time will never request a render.
   * This value impacts the rate of rendering for changes in the scene like lighting, entity property updates,
   * and animations.
   */
  maximumRenderTimeChange: number;
  /**
   * The spherical harmonic coefficients for image-based lighting of PBR models.
   */
  sphericalHarmonicCoefficients: Cartesian3[];
  /**
   * The url to the KTX2 file containing the specular environment map and convoluted mipmaps for image-based lighting of PBR models.
   */
  specularEnvironmentMaps: string;
  /**
   * The light source for shading. Defaults to a directional light from the Sun.
   */
  light: Light;
  /**
   * Gets the canvas element to which this scene is bound.
   */
  readonly canvas: HTMLCanvasElement;
  /**
   * The drawingBufferHeight of the underlying GL context.
   */
  readonly drawingBufferHeight: number;
  /**
   * The drawingBufferHeight of the underlying GL context.
   */
  readonly drawingBufferWidth: number;
  /**
   * The maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.
   */
  readonly maximumAliasedLineWidth: number;
  /**
   * The maximum length in pixels of one edge of a cube map, supported by this WebGL implementation.  It will be at least 16.
   */
  readonly maximumCubeMapSize: number;
  /**
   * Returns <code>true</code> if the {@link Scene#pickPosition} function is supported.
   */
  readonly pickPositionSupported: boolean;
  /**
   * Returns <code>true</code> if the {@link Scene#sampleHeight} and {@link Scene#sampleHeightMostDetailed} functions are supported.
   */
  readonly sampleHeightSupported: boolean;
  /**
   * Returns <code>true</code> if the {@link Scene#clampToHeight} and {@link Scene#clampToHeightMostDetailed} functions are supported.
   */
  readonly clampToHeightSupported: boolean;
  /**
   * Returns <code>true</code> if the {@link Scene#invertClassification} is supported.
   */
  readonly invertClassificationSupported: boolean;
  /**
   * Returns <code>true</code> if specular environment maps are supported.
   */
  readonly specularEnvironmentMapsSupported: boolean;
  /**
   * Gets or sets the depth-test ellipsoid.
   */
  globe: Globe;
  /**
   * Gets the collection of primitives.
   */
  readonly primitives: PrimitiveCollection;
  /**
   * Gets the collection of ground primitives.
   */
  readonly groundPrimitives: PrimitiveCollection;
  /**
   * Gets or sets the camera.
   */
  readonly camera: Camera;
  /**
   * Gets the controller for camera input handling.
   */
  readonly screenSpaceCameraController: ScreenSpaceCameraController;
  /**
   * Get the map projection to use in 2D and Columbus View modes.
   */
  readonly mapProjection: MapProjection;
  /**
   * Gets the collection of image layers that will be rendered on the globe.
   */
  readonly imageryLayers: ImageryLayerCollection;
  /**
   * The terrain provider providing surface geometry for the globe.
   */
  terrainProvider: TerrainProvider;
  /**
   * Gets an event that's raised when the terrain provider is changed
   */
  readonly terrainProviderChanged: Event;
  /**
   * Gets the event that will be raised before the scene is updated or rendered.  Subscribers to the event
   * receive the Scene instance as the first parameter and the current time as the second parameter.
   */
  readonly preUpdate: Event;
  /**
   * Gets the event that will be raised immediately after the scene is updated and before the scene is rendered.
   * Subscribers to the event receive the Scene instance as the first parameter and the current time as the second
   * parameter.
   */
  readonly postUpdate: Event;
  /**
   * Gets the event that will be raised when an error is thrown inside the <code>render</code> function.
   * The Scene instance and the thrown error are the only two parameters passed to the event handler.
   * By default, errors are not rethrown after this event is raised, but that can be changed by setting
   * the <code>rethrowRenderErrors</code> property.
   */
  readonly renderError: Event;
  /**
   * Gets the event that will be raised after the scene is updated and immediately before the scene is rendered.
   * Subscribers to the event receive the Scene instance as the first parameter and the current time as the second
   * parameter.
   */
  readonly preRender: Event;
  /**
   * Gets the event that will be raised immediately after the scene is rendered.  Subscribers to the event
   * receive the Scene instance as the first parameter and the current time as the second parameter.
   */
  readonly postRender: Event;
  /**
   * Gets the simulation time when the scene was last rendered. Returns undefined if the scene has not yet been
   * rendered.
   */
  readonly lastRenderTime: JulianDate;
  /**
   * This property is for debugging only; it is not for production use.
   * <p>
   * When {@link Scene.debugShowFrustums} is <code>true</code>, this contains
   * properties with statistics about the number of command execute per frustum.
   * <code>totalCommands</code> is the total number of commands executed, ignoring
   * overlap. <code>commandsInFrustums</code> is an array with the number of times
   * commands are executed redundantly, e.g., how many commands overlap two or
   * three frustums.
   * </p>
   */
  readonly debugFrustumStatistics: any;
  /**
   * Gets whether or not the scene is optimized for 3D only viewing.
   */
  readonly scene3DOnly: boolean;
  /**
   * Gets whether or not the scene has order independent translucency enabled.
   * Note that this only reflects the original construction option, and there are
   * other factors that could prevent OIT from functioning on a given system configuration.
   */
  readonly orderIndependentTranslucency: boolean;
  /**
   * Gets the unique identifier for this scene.
   */
  readonly id: string;
  /**
   * Gets or sets the current mode of the scene.
   */
  mode: SceneMode;
  /**
   * When <code>true</code>, splits the scene into two viewports with steroscopic views for the left and right eyes.
   * Used for cardboard and WebVR.
   */
  useWebVR: boolean;
  /**
   * Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
   */
  readonly mapMode2D: MapMode2D;
  /**
   * Gets or sets the position of the splitter within the viewport.  Valid values are between 0.0 and 1.0.
   */
  splitPosition: number;
  /**
   * The distance from the camera at which to disable the depth test of billboards, labels and points
   * to, for example, prevent clipping against terrain. When set to zero, the depth test should always
   * be applied. When less than zero, the depth test should never be applied. Setting the disableDepthTestDistance
   * property of a billboard, label or point will override this value.
   */
  minimumDisableDepthTestDistance: number;
  /**
   * Whether or not to use a logarithmic depth buffer. Enabling this option will allow for less frustums in the multi-frustum,
   * increasing performance. This property relies on fragmentDepth being supported.
   */
  logarithmicDepthBuffer: boolean;
  /**
   * The value used for gamma correction. This is only used when rendering with high dynamic range.
   */
  gamma: number;
  /**
   * Whether or not to use high dynamic range rendering.
   */
  highDynamicRange: boolean;
  /**
   * Whether or not high dynamic range rendering is supported.
   */
  readonly highDynamicRangeSupported: boolean;
  /**
   * Whether or not the camera is underneath the globe.
   */
  readonly cameraUnderground: boolean;
  /**
   * The sample rate of multisample antialiasing (values greater than 1 enable MSAA).
   */
  msaaSamples: number;
  /**
   * Returns <code>true</code> if the Scene's context supports MSAA.
   */
  readonly msaaSupported: boolean;
  /**
   * Determines if a compressed texture format is supported.
   * @param format - The texture format. May be the name of the format or the WebGL extension name, e.g. s3tc or WEBGL_compressed_texture_s3tc.
   * @returns Whether or not the format is supported.
   */
  getCompressedTextureFormatSupported(format: string): boolean;
  /**
   * Update and render the scene. It is usually not necessary to call this function
   * directly because {@link CesiumWidget} or {@link Viewer} do it automatically.
   * @param [time] - The simulation time at which to render.
   */
  render(time?: JulianDate): void;
  /**
   * Requests a new rendered frame when {@link Scene#requestRenderMode} is set to <code>true</code>.
   * The render rate will not exceed the {@link CesiumWidget#targetFrameRate}.
   */
  requestRender(): void;
  /**
   * Returns an object with a `primitive` property that contains the first (top) primitive in the scene
   * at a particular window coordinate or undefined if nothing is at the location. Other properties may
   * potentially be set depending on the type of primitive and may be used to further identify the picked object.
   * <p>
   * When a feature of a 3D Tiles tileset is picked, <code>pick</code> returns a {@link Cesium3DTileFeature} object.
   * </p>
   * @example
   * // On mouse over, color the feature yellow.
   * handler.setInputAction(function(movement) {
   *     const feature = scene.pick(movement.endPosition);
   *     if (feature instanceof Cesium.Cesium3DTileFeature) {
   *         feature.color = Cesium.Color.YELLOW;
   *     }
   * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
   * @param windowPosition - Window coordinates to perform picking on.
   * @param [width = 3] - Width of the pick rectangle.
   * @param [height = 3] - Height of the pick rectangle.
   * @returns Object containing the picked primitive.
   */
  pick(windowPosition: Cartesian2, width?: number, height?: number): any;
  /**
   * Returns the cartesian position reconstructed from the depth buffer and window position.
   * <p>
   * The position reconstructed from the depth buffer in 2D may be slightly different from those
   * reconstructed in 3D and Columbus view. This is caused by the difference in the distribution
   * of depth values of perspective and orthographic projection.
   * </p>
   * <p>
   * Set {@link Scene#pickTranslucentDepth} to <code>true</code> to include the depth of
   * translucent primitives; otherwise, this essentially picks through translucent primitives.
   * </p>
   * @param windowPosition - Window coordinates to perform picking on.
   * @param [result] - The object on which to restore the result.
   * @returns The cartesian position.
   */
  pickPosition(windowPosition: Cartesian2, result?: Cartesian3): Cartesian3;
  /**
   * Returns a list of objects, each containing a `primitive` property, for all primitives at
   * a particular window coordinate position. Other properties may also be set depending on the
   * type of primitive and may be used to further identify the picked object. The primitives in
   * the list are ordered by their visual order in the scene (front to back).
   * @example
   * const pickedObjects = scene.drillPick(new Cesium.Cartesian2(100.0, 200.0));
   * @param windowPosition - Window coordinates to perform picking on.
   * @param [limit] - If supplied, stop drilling after collecting this many picks.
   * @param [width = 3] - Width of the pick rectangle.
   * @param [height = 3] - Height of the pick rectangle.
   * @returns Array of objects, each containing 1 picked primitives.
   */
  drillPick(windowPosition: Cartesian2, limit?: number, width?: number, height?: number): any[];
  /**
   * Returns the height of scene geometry at the given cartographic position or <code>undefined</code> if there was no
   * scene geometry to sample height from. The height of the input position is ignored. May be used to clamp objects to
   * the globe, 3D Tiles, or primitives in the scene.
   * <p>
   * This function only samples height from globe tiles and 3D Tiles that are rendered in the current view. Samples height
   * from all other primitives regardless of their visibility.
   * </p>
   * @example
   * const position = new Cesium.Cartographic(-1.31968, 0.698874);
   * const height = viewer.scene.sampleHeight(position);
   * console.log(height);
   * @param position - The cartographic position to sample height from.
   * @param [objectsToExclude] - A list of primitives, entities, or 3D Tiles features to not sample height from.
   * @param [width = 0.1] - Width of the intersection volume in meters.
   * @returns The height. This may be <code>undefined</code> if there was no scene geometry to sample height from.
   */
  sampleHeight(position: Cartographic, objectsToExclude?: object[], width?: number): number;
  /**
   * Clamps the given cartesian position to the scene geometry along the geodetic surface normal. Returns the
   * clamped position or <code>undefined</code> if there was no scene geometry to clamp to. May be used to clamp
   * objects to the globe, 3D Tiles, or primitives in the scene.
   * <p>
   * This function only clamps to globe tiles and 3D Tiles that are rendered in the current view. Clamps to
   * all other primitives regardless of their visibility.
   * </p>
   * @example
   * // Clamp an entity to the underlying scene geometry
   * const position = entity.position.getValue(Cesium.JulianDate.now());
   * entity.position = viewer.scene.clampToHeight(position);
   * @param cartesian - The cartesian position.
   * @param [objectsToExclude] - A list of primitives, entities, or 3D Tiles features to not clamp to.
   * @param [width = 0.1] - Width of the intersection volume in meters.
   * @param [result] - An optional object to return the clamped position.
   * @returns The modified result parameter or a new Cartesian3 instance if one was not provided. This may be <code>undefined</code> if there was no scene geometry to clamp to.
   */
  clampToHeight(cartesian: Cartesian3, objectsToExclude?: object[], width?: number, result?: Cartesian3): Cartesian3;
  /**
   * Initiates an asynchronous {@link Scene#sampleHeight} query for an array of {@link Cartographic} positions
   * using the maximum level of detail for 3D Tilesets in the scene. The height of the input positions is ignored.
   * Returns a promise that is resolved when the query completes. Each point height is modified in place.
   * If a height cannot be determined because no geometry can be sampled at that location, or another error occurs,
   * the height is set to undefined.
   * @example
   * const positions = [
   *     new Cesium.Cartographic(-1.31968, 0.69887),
   *     new Cesium.Cartographic(-1.10489, 0.83923)
   * ];
   * const promise = viewer.scene.sampleHeightMostDetailed(positions);
   * promise.then(function(updatedPosition) {
   *     // positions[0].height and positions[1].height have been updated.
   *     // updatedPositions is just a reference to positions.
   * }
   * @param positions - The cartographic positions to update with sampled heights.
   * @param [objectsToExclude] - A list of primitives, entities, or 3D Tiles features to not sample height from.
   * @param [width = 0.1] - Width of the intersection volume in meters.
   * @returns A promise that resolves to the provided list of positions when the query has completed.
   */
  sampleHeightMostDetailed(positions: Cartographic[], objectsToExclude?: object[], width?: number): Promise<Cartographic[]>;
  /**
   * Initiates an asynchronous {@link Scene#clampToHeight} query for an array of {@link Cartesian3} positions
   * using the maximum level of detail for 3D Tilesets in the scene. Returns a promise that is resolved when
   * the query completes. Each position is modified in place. If a position cannot be clamped because no geometry
   * can be sampled at that location, or another error occurs, the element in the array is set to undefined.
   * @example
   * const cartesians = [
   *     entities[0].position.getValue(Cesium.JulianDate.now()),
   *     entities[1].position.getValue(Cesium.JulianDate.now())
   * ];
   * const promise = viewer.scene.clampToHeightMostDetailed(cartesians);
   * promise.then(function(updatedCartesians) {
   *     entities[0].position = updatedCartesians[0];
   *     entities[1].position = updatedCartesians[1];
   * }
   * @param cartesians - The cartesian positions to update with clamped positions.
   * @param [objectsToExclude] - A list of primitives, entities, or 3D Tiles features to not clamp to.
   * @param [width = 0.1] - Width of the intersection volume in meters.
   * @returns A promise that resolves to the provided list of positions when the query has completed.
   */
  clampToHeightMostDetailed(cartesians: Cartesian3[], objectsToExclude?: object[], width?: number): Promise<Cartesian3[]>;
  /**
   * Transforms a position in cartesian coordinates to canvas coordinates.  This is commonly used to place an
   * HTML element at the same screen position as an object in the scene.
   * @example
   * // Output the canvas position of longitude/latitude (0, 0) every time the mouse moves.
   * const scene = widget.scene;
   * const ellipsoid = scene.globe.ellipsoid;
   * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
   * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
   * handler.setInputAction(function(movement) {
   *     console.log(scene.cartesianToCanvasCoordinates(position));
   * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
   * @param position - The position in cartesian coordinates.
   * @param [result] - An optional object to return the input position transformed to canvas coordinates.
   * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.
   */
  cartesianToCanvasCoordinates(position: Cartesian3, result?: Cartesian2): Cartesian2;
  /**
   * Instantly completes an active transition.
   */
  completeMorph(): void;
  /**
   * Asynchronously transitions the scene to 2D.
   * @param [duration = 2.0] - The amount of time, in seconds, for transition animations to complete.
   */
  morphTo2D(duration?: number): void;
  /**
   * Asynchronously transitions the scene to Columbus View.
   * @param [duration = 2.0] - The amount of time, in seconds, for transition animations to complete.
   */
  morphToColumbusView(duration?: number): void;
  /**
   * Asynchronously transitions the scene to 3D.
   * @param [duration = 2.0] - The amount of time, in seconds, for transition animations to complete.
   */
  morphTo3D(duration?: number): void;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * scene = scene && scene.destroy();
   */
  destroy(): void;
}

/**
* Indicates if the scene is viewed in 3D, 2D, or 2.5D Columbus view.
*/
export enum SceneMode {
  /**
   * Morphing between mode, e.g., 3D to 2D.
   */
  MORPHING = 0,
  /**
   * Columbus View mode.  A 2.5D perspective view where the map is laid out
   * flat and objects with non-zero height are drawn above it.
   */
  COLUMBUS_VIEW = 1,
  /**
   * 2D mode.  The map is viewed top-down with an orthographic projection.
   */
  SCENE2D = 2,
  /**
   * 3D mode.  A traditional 3D perspective view of the globe.
   */
  SCENE3D = 3
}

/**
* Functions that do scene-dependent transforms between rendering-related coordinate systems.
*/
export namespace SceneTransforms {
  /**
   * Transforms a position in WGS84 coordinates to window coordinates.  This is commonly used to place an
   * HTML element at the same screen position as an object in the scene.
   * @example
   * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.
   * const scene = widget.scene;
   * const ellipsoid = scene.globe.ellipsoid;
   * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
   * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
   * handler.setInputAction(function(movement) {
   *     console.log(Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position));
   * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
   * @param scene - The scene.
   * @param position - The position in WGS84 (world) coordinates.
   * @param [result] - An optional object to return the input position transformed to window coordinates.
   * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.
   */
  function wgs84ToWindowCoordinates(scene: Scene, position: Cartesian3, result?: Cartesian2): Cartesian2;
  /**
   * Transforms a position in WGS84 coordinates to drawing buffer coordinates.  This may produce different
   * results from SceneTransforms.wgs84ToWindowCoordinates when the browser zoom is not 100%, or on high-DPI displays.
   * @example
   * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.
   * const scene = widget.scene;
   * const ellipsoid = scene.globe.ellipsoid;
   * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
   * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
   * handler.setInputAction(function(movement) {
   *     console.log(Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position));
   * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
   * @param scene - The scene.
   * @param position - The position in WGS84 (world) coordinates.
   * @param [result] - An optional object to return the input position transformed to window coordinates.
   * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.
   */
  function wgs84ToDrawingBufferCoordinates(scene: Scene, position: Cartesian3, result?: Cartesian2): Cartesian2;
}

/**
* Modifies the camera position and orientation based on mouse input to a canvas.
* @param scene - The scene.
*/
export class ScreenSpaceCameraController {
  constructor(scene: Scene);
  /**
   * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,
   * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.
   *
   * NOTE: This setting is for temporary use cases, such as camera flights and
   * drag-selection of regions (see Picking demo).  It is typically set to false at the
   * start of such events, and set true on completion.  To keep inputs disabled
   * past the end of camera flights, you must use the other booleans (enableTranslate,
   * enableZoom, enableRotate, enableTilt, and enableLook).
   */
  enableInputs: boolean;
  /**
   * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.
   * This flag only applies in 2D and Columbus view modes.
   */
  enableTranslate: boolean;
  /**
   * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.
   */
  enableZoom: boolean;
  /**
   * If true, allows the user to rotate the world which translates the user's position.
   * This flag only applies in 2D and 3D.
   */
  enableRotate: boolean;
  /**
   * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.
   * This flag only applies in 3D and Columbus view.
   */
  enableTilt: boolean;
  /**
   * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating
   * or rotating. This flag only applies in 3D and Columbus view modes.
   */
  enableLook: boolean;
  /**
   * A parameter in the range <code>[0, 1)</code> used to determine how long
   * the camera will continue to spin because of inertia.
   * With value of zero, the camera will have no inertia.
   */
  inertiaSpin: number;
  /**
   * A parameter in the range <code>[0, 1)</code> used to determine how long
   * the camera will continue to translate because of inertia.
   * With value of zero, the camera will have no inertia.
   */
  inertiaTranslate: number;
  /**
   * A parameter in the range <code>[0, 1)</code> used to determine how long
   * the camera will continue to zoom because of inertia.
   * With value of zero, the camera will have no inertia.
   */
  inertiaZoom: number;
  /**
   * A parameter in the range <code>[0, 1)</code> used to limit the range
   * of various user inputs to a percentage of the window width/height per animation frame.
   * This helps keep the camera under control in low-frame-rate situations.
   */
  maximumMovementRatio: number;
  /**
   * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.
   */
  bounceAnimationTime: number;
  /**
   * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.
   */
  minimumZoomDistance: number;
  /**
   * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.
   */
  maximumZoomDistance: number;
  /**
   * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.
   * <p>
   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
   * or an array of any of the preceding.
   * </p>
   */
  translateEventTypes: CameraEventType | any[] | undefined;
  /**
   * The input that allows the user to zoom in/out.
   * <p>
   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
   * or an array of any of the preceding.
   * </p>
   */
  zoomEventTypes: CameraEventType | any[] | undefined;
  /**
   * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.
   * <p>
   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
   * or an array of any of the preceding.
   * </p>
   */
  rotateEventTypes: CameraEventType | any[] | undefined;
  /**
   * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.
   * <p>
   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
   * or an array of any of the preceding.
   * </p>
   */
  tiltEventTypes: CameraEventType | any[] | undefined;
  /**
   * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.
   * <p>
   * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
   * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
   * or an array of any of the preceding.
   * </p>
   */
  lookEventTypes: CameraEventType | any[] | undefined;
  /**
   * The minimum height the camera must be before picking the terrain instead of the ellipsoid.
   */
  minimumPickingTerrainHeight: number;
  /**
   * The minimum height the camera must be before testing for collision with terrain.
   */
  minimumCollisionTerrainHeight: number;
  /**
   * The minimum height the camera must be before switching from rotating a track ball to
   * free look when clicks originate on the sky or in space.
   */
  minimumTrackBallHeight: number;
  /**
   * Enables or disables camera collision detection with terrain.
   */
  enableCollisionDetection: boolean;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Removes mouse listeners held by this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * controller = controller && controller.destroy();
   */
  destroy(): void;
}

/**
* Use {@link Viewer#shadowMap} to get the scene's shadow map. Do not construct this directly.
*
* <p>
* The normalOffset bias pushes the shadows forward slightly, and may be disabled
* for applications that require ultra precise shadows.
* </p>
* @param options - An object containing the following properties:
* @param options.lightCamera - A camera representing the light source.
* @param [options.enabled = true] - Whether the shadow map is enabled.
* @param [options.isPointLight = false] - Whether the light source is a point light. Point light shadows do not use cascades.
* @param [options.pointLightRadius = 100.0] - Radius of the point light.
* @param [options.cascadesEnabled = true] - Use multiple shadow maps to cover different partitions of the view frustum.
* @param [options.numberOfCascades = 4] - The number of cascades to use for the shadow map. Supported values are one and four.
* @param [options.maximumDistance = 5000.0] - The maximum distance used for generating cascaded shadows. Lower values improve shadow quality.
* @param [options.size = 2048] - The width and height, in pixels, of each shadow map.
* @param [options.softShadows = false] - Whether percentage-closer-filtering is enabled for producing softer shadows.
* @param [options.darkness = 0.3] - The shadow darkness.
* @param [options.normalOffset = true] - Whether a normal bias is applied to shadows.
* @param [options.fadingEnabled = true] - Whether shadows start to fade out once the light gets closer to the horizon.
*/
export class ShadowMap {
  constructor(options: {
    lightCamera: Camera;
    enabled?: boolean;
    isPointLight?: boolean;
    pointLightRadius?: number;
    cascadesEnabled?: boolean;
    numberOfCascades?: number;
    maximumDistance?: number;
    size?: number;
    softShadows?: boolean;
    darkness?: number;
    normalOffset?: boolean;
    fadingEnabled?: boolean;
  });
  /**
   * Determines the darkness of the shadows.
   */
  darkness: number;
  /**
   * Determines whether shadows start to fade out once the light gets closer to the horizon.
   */
  fadingEnabled: boolean;
  /**
   * Determines the maximum distance of the shadow map. Only applicable for cascaded shadows. Larger distances may result in lower quality shadows.
   */
  maximumDistance: number;
  /**
   * Determines if the shadow map will be shown.
   */
  enabled: boolean;
  /**
   * Determines if a normal bias will be applied to shadows.
   */
  normalOffset: boolean;
  /**
   * Determines if soft shadows are enabled. Uses pcf filtering which requires more texture reads and may hurt performance.
   */
  softShadows: boolean;
  /**
   * The width and height, in pixels, of each shadow map.
   */
  size: number;
}

/**
* Specifies whether the object casts or receives shadows from light sources when
* shadows are enabled.
*/
export enum ShadowMode {
  /**
   * The object does not cast or receive shadows.
   */
  DISABLED = 0,
  /**
   * The object casts and receives shadows.
   */
  ENABLED = 1,
  /**
   * The object casts shadows only.
   */
  CAST_ONLY = 2,
  /**
   * The object receives shadows only.
   */
  RECEIVE_ONLY = 3
}

export namespace SingleTileImageryProvider {
  /**
   * Initialization options for the SingleTileImageryProvider constructor
   * @property url - The url for the tile.
   * @property [rectangle = Rectangle.MAX_VALUE] - The rectangle, in radians, covered by the image.
   * @property [credit] - A credit for the data source, which is displayed on the canvas.
   * @property [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
   */
  type ConstructorOptions = {
    url: Resource | string;
    rectangle?: Rectangle;
    credit?: Credit | string;
    ellipsoid?: Ellipsoid;
  };
}

/**
* Provides a single, top-level imagery tile.  The single image is assumed to use a
* {@link GeographicTilingScheme}.
* @param options - Object describing initialization options
*/
export class SingleTileImageryProvider {
  constructor(options: SingleTileImageryProvider.ConstructorOptions);
  /**
   * The default alpha blending value of this provider, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  defaultAlpha: number | undefined;
  /**
   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  defaultNightAlpha: number | undefined;
  /**
   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  defaultDayAlpha: number | undefined;
  /**
   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0
   * makes the imagery darker while greater than 1.0 makes it brighter.
   */
  defaultBrightness: number | undefined;
  /**
   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces
   * the contrast while greater than 1.0 increases it.
   */
  defaultContrast: number | undefined;
  /**
   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.
   */
  defaultHue: number | undefined;
  /**
   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the
   * saturation while greater than 1.0 increases it.
   */
  defaultSaturation: number | undefined;
  /**
   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.
   */
  defaultGamma: number | undefined;
  /**
   * The default texture minification filter to apply to this provider.
   */
  defaultMinificationFilter: TextureMinificationFilter;
  /**
   * The default texture magnification filter to apply to this provider.
   */
  defaultMagnificationFilter: TextureMagnificationFilter;
  /**
   * Gets the URL of the single, top-level imagery tile.
   */
  readonly url: string;
  /**
   * Gets the proxy used by this provider.
   */
  readonly proxy: Proxy;
  /**
   * Gets the width of each tile, in pixels. This function should
   * not be called before {@link SingleTileImageryProvider#ready} returns true.
   */
  readonly tileWidth: number;
  /**
   * Gets the height of each tile, in pixels.  This function should
   * not be called before {@link SingleTileImageryProvider#ready} returns true.
   */
  readonly tileHeight: number;
  /**
   * Gets the maximum level-of-detail that can be requested.  This function should
   * not be called before {@link SingleTileImageryProvider#ready} returns true.
   */
  readonly maximumLevel: number | undefined;
  /**
   * Gets the minimum level-of-detail that can be requested.  This function should
   * not be called before {@link SingleTileImageryProvider#ready} returns true.
   */
  readonly minimumLevel: number;
  /**
   * Gets the tiling scheme used by this provider.  This function should
   * not be called before {@link SingleTileImageryProvider#ready} returns true.
   */
  readonly tilingScheme: TilingScheme;
  /**
   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
   * not be called before {@link SingleTileImageryProvider#ready} returns true.
   */
  readonly rectangle: Rectangle;
  /**
   * Gets the tile discard policy.  If not undefined, the discard policy is responsible
   * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
   * returns undefined, no tiles are filtered.  This function should
   * not be called before {@link SingleTileImageryProvider#ready} returns true.
   */
  readonly tileDiscardPolicy: TileDiscardPolicy;
  /**
   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
   * are passed an instance of {@link TileProviderError}.
   */
  readonly errorEvent: Event;
  /**
   * Gets a value indicating whether or not the provider is ready for use.
   */
  readonly ready: boolean;
  /**
   * Gets a promise that resolves to true when the provider is ready for use.
   */
  readonly readyPromise: Promise<boolean>;
  /**
   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
   * the source of the imagery.  This function should not be called before {@link SingleTileImageryProvider#ready} returns true.
   */
  readonly credit: Credit;
  /**
   * Gets a value indicating whether or not the images provided by this imagery provider
   * include an alpha channel.  If this property is false, an alpha channel, if present, will
   * be ignored.  If this property is true, any images without an alpha channel will be treated
   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
   * and texture upload time are reduced.
   */
  readonly hasAlphaChannel: boolean;
  /**
   * Gets the credits to be displayed when a given tile is displayed.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level;
   * @returns The credits to be displayed when the tile is displayed.
   */
  getTileCredits(x: number, y: number, level: number): Credit[];
  /**
   * Requests the image for a given tile.  This function should
   * not be called before {@link SingleTileImageryProvider#ready} returns true.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level.
   * @param [request] - The request object. Intended for internal use only.
   * @returns The resolved image
   */
  requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
  /**
   * Picking features is not currently supported by this imagery provider, so this function simply returns
   * undefined.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level.
   * @param longitude - The longitude at which to pick features.
   * @param latitude - The latitude at which to pick features.
   * @returns Undefined since picking is not supported.
   */
  pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): undefined;
}

/**
* An atmosphere drawn around the limb of the provided ellipsoid. Based on
* {@link http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf|Display of The Earth Taking Into Account Atmospheric Scattering}.
* <p>
* This is only supported in 3D. Atmosphere is faded out when morphing to 2D or Columbus view.
* </p>
* @example
* scene.skyAtmosphere = new Cesium.SkyAtmosphere();
* @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid that the atmosphere is drawn around.
*/
export class SkyAtmosphere {
  constructor(ellipsoid?: Ellipsoid);
  /**
   * Determines if the atmosphere is shown.
   */
  show: boolean;
  /**
   * Compute atmosphere per-fragment instead of per-vertex.
   * This produces better looking atmosphere with a slight performance penalty.
   */
  perFragmentAtmosphere: boolean;
  /**
   * The intensity of the light that is used for computing the sky atmosphere color.
   */
  atmosphereLightIntensity: number;
  /**
   * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.
   */
  atmosphereRayleighCoefficient: Cartesian3;
  /**
   * The Mie scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.
   */
  atmosphereMieCoefficient: Cartesian3;
  /**
   * The Rayleigh scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.
   */
  atmosphereRayleighScaleHeight: number;
  /**
   * The Mie scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.
   */
  atmosphereMieScaleHeight: number;
  /**
   * The anisotropy of the medium to consider for Mie scattering.
   * <p>
   * Valid values are between -1.0 and 1.0.
   * </p>
   */
  atmosphereMieAnisotropy: number;
  /**
   * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).
   * A hue shift of 1.0 indicates a complete rotation of the hues available.
   */
  hueShift: number;
  /**
   * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).
   * A saturation shift of -1.0 is monochrome.
   */
  saturationShift: number;
  /**
   * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).
   * A brightness shift of -1.0 is complete darkness, which will let space show through.
   */
  brightnessShift: number;
  /**
   * Gets the ellipsoid the atmosphere is drawn around.
   */
  readonly ellipsoid: Ellipsoid;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();
   */
  destroy(): void;
}

/**
* A sky box around the scene to draw stars.  The sky box is defined using the True Equator Mean Equinox (TEME) axes.
* <p>
* This is only supported in 3D.  The sky box is faded out when morphing to 2D or Columbus view.  The size of
* the sky box must not exceed {@link Scene#maximumCubeMapSize}.
* </p>
* @example
* scene.skyBox = new Cesium.SkyBox({
*   sources : {
*     positiveX : 'skybox_px.png',
*     negativeX : 'skybox_nx.png',
*     positiveY : 'skybox_py.png',
*     negativeY : 'skybox_ny.png',
*     positiveZ : 'skybox_pz.png',
*     negativeZ : 'skybox_nz.png'
*   }
* });
* @param options - Object with the following properties:
* @param [options.sources] - The source URL or <code>Image</code> object for each of the six cube map faces.  See the example below.
* @param [options.show = true] - Determines if this primitive will be shown.
*/
export class SkyBox {
  constructor(options: {
    sources?: any;
    show?: boolean;
  });
  /**
   * The sources used to create the cube map faces: an object
   * with <code>positiveX</code>, <code>negativeX</code>, <code>positiveY</code>,
   * <code>negativeY</code>, <code>positiveZ</code>, and <code>negativeZ</code> properties.
   * These can be either URLs or <code>Image</code> objects.
   */
  sources: any;
  /**
   * Determines if the sky box will be shown.
   */
  show: boolean;
  /**
   * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
   * get the draw commands needed to render this primitive.
   * <p>
   * Do not call this function directly.  This is documented just to
   * list the exceptions that may be propagated when the scene is rendered:
   * </p>
   */
  update(): void;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * skyBox = skyBox && skyBox.destroy();
   */
  destroy(): void;
}

/**
 * The direction to display a primitive or ImageryLayer relative to the {@link Scene#splitPosition}.
 */
export enum SplitDirection {
  /**
   * Display the primitive or ImageryLayer to the left of the {@link Scene#splitPosition}.
   */
  LEFT = -1,
  /**
   * Always display the primitive or ImageryLayer.
   */
  NONE = 0,
  /**
   * Display the primitive or ImageryLayer to the right of the {@link Scene#splitPosition}.
   */
  RIGHT = 1
}

/**
* Determines the function used to compare stencil values for the stencil test.
*/
export enum StencilFunction {
  /**
   * The stencil test never passes.
   */
  NEVER = WebGLConstants.NEVER,
  /**
   * The stencil test passes when the masked reference value is less than the masked stencil value.
   */
  LESS = WebGLConstants.LESS,
  /**
   * The stencil test passes when the masked reference value is equal to the masked stencil value.
   */
  EQUAL = WebGLConstants.EQUAL,
  /**
   * The stencil test passes when the masked reference value is less than or equal to the masked stencil value.
   */
  LESS_OR_EQUAL = WebGLConstants.LEQUAL,
  /**
   * The stencil test passes when the masked reference value is greater than the masked stencil value.
   */
  GREATER = WebGLConstants.GREATER,
  /**
   * The stencil test passes when the masked reference value is not equal to the masked stencil value.
   */
  NOT_EQUAL = WebGLConstants.NOTEQUAL,
  /**
   * The stencil test passes when the masked reference value is greater than or equal to the masked stencil value.
   */
  GREATER_OR_EQUAL = WebGLConstants.GEQUAL,
  /**
   * The stencil test always passes.
   */
  ALWAYS = WebGLConstants.ALWAYS
}

/**
* Determines the action taken based on the result of the stencil test.
*/
export enum StencilOperation {
  /**
   * Sets the stencil buffer value to zero.
   */
  ZERO = WebGLConstants.ZERO,
  /**
   * Does not change the stencil buffer.
   */
  KEEP = WebGLConstants.KEEP,
  /**
   * Replaces the stencil buffer value with the reference value.
   */
  REPLACE = WebGLConstants.REPLACE,
  /**
   * Increments the stencil buffer value, clamping to unsigned byte.
   */
  INCREMENT = WebGLConstants.INCR,
  /**
   * Decrements the stencil buffer value, clamping to zero.
   */
  DECREMENT = WebGLConstants.DECR,
  /**
   * Bitwise inverts the existing stencil buffer value.
   */
  INVERT = WebGLConstants.INVERT,
  /**
   * Increments the stencil buffer value, wrapping to zero when exceeding the unsigned byte range.
   */
  INCREMENT_WRAP = WebGLConstants.INCR_WRAP,
  /**
   * Decrements the stencil buffer value, wrapping to the maximum unsigned byte instead of going below zero.
   */
  DECREMENT_WRAP = WebGLConstants.DECR_WRAP
}

/**
 * Draws a sun billboard.
 * <p>This is only supported in 3D and Columbus view.</p>
 * @example
 * scene.sun = new Cesium.Sun();
 */
export class Sun {
  constructor();
  /**
   * Determines if the sun will be shown.
   */
  show: boolean;
  /**
   * Gets or sets a number that controls how "bright" the Sun's lens flare appears
   * to be.  Zero shows just the Sun's disc without any flare.
   * Use larger values for a more pronounced flare around the Sun.
   */
  glowFactor: number;
  /**
   * Returns true if this object was destroyed; otherwise, false.
   * <br /><br />
   * If this object was destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
   * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
   * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
   * <br /><br />
   * Once an object is destroyed, it should not be used; calling any function other than
   * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
   * assign the return value (<code>undefined</code>) to the object as done in the example.
   * @example
   * sun = sun && sun.destroy();
   *
   *
   */
  destroy(): void;
}

/**
* A directional light source that originates from the Sun.
* @param [options] - Object with the following properties:
* @param [options.color = Color.WHITE] - The light's color.
* @param [options.intensity = 2.0] - The light's intensity.
*/
export class SunLight {
  constructor(options?: {
    color?: Color;
    intensity?: number;
  });
  /**
   * The color of the light.
   */
  color: Color;
  /**
   * The intensity of the light.
   */
  intensity: number;
}

export namespace TileCoordinatesImageryProvider {
  /**
   * Initialization options for the TileCoordinatesImageryProvider constructor
   * @property [tilingScheme = new GeographicTilingScheme()] - The tiling scheme for which to draw tiles.
   * @property [ellipsoid] - The ellipsoid.  If the tilingScheme is specified,
   *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
   *                    parameter is specified, the WGS84 ellipsoid is used.
   * @property [color = Color.YELLOW] - The color to draw the tile box and label.
   * @property [tileWidth = 256] - The width of the tile for level-of-detail selection purposes.
   * @property [tileHeight = 256] - The height of the tile for level-of-detail selection purposes.
   */
  type ConstructorOptions = {
    tilingScheme?: TilingScheme;
    ellipsoid?: Ellipsoid;
    color?: Color;
    tileWidth?: number;
    tileHeight?: number;
  };
}

/**
* An {@link ImageryProvider} that draws a box around every rendered tile in the tiling scheme, and draws
* a label inside it indicating the X, Y, Level coordinates of the tile.  This is mostly useful for
* debugging terrain and imagery rendering problems.
* @param [options] - Object describing initialization options
*/
export class TileCoordinatesImageryProvider {
  constructor(options?: TileCoordinatesImageryProvider.ConstructorOptions);
  /**
   * The default alpha blending value of this provider, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  defaultAlpha: number | undefined;
  /**
   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  defaultNightAlpha: number | undefined;
  /**
   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  defaultDayAlpha: number | undefined;
  /**
   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0
   * makes the imagery darker while greater than 1.0 makes it brighter.
   */
  defaultBrightness: number | undefined;
  /**
   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces
   * the contrast while greater than 1.0 increases it.
   */
  defaultContrast: number | undefined;
  /**
   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.
   */
  defaultHue: number | undefined;
  /**
   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the
   * saturation while greater than 1.0 increases it.
   */
  defaultSaturation: number | undefined;
  /**
   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.
   */
  defaultGamma: number | undefined;
  /**
   * The default texture minification filter to apply to this provider.
   */
  defaultMinificationFilter: TextureMinificationFilter;
  /**
   * The default texture magnification filter to apply to this provider.
   */
  defaultMagnificationFilter: TextureMagnificationFilter;
  /**
   * Gets the proxy used by this provider.
   */
  readonly proxy: Proxy;
  /**
   * Gets the width of each tile, in pixels. This function should
   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
   */
  readonly tileWidth: number;
  /**
   * Gets the height of each tile, in pixels.  This function should
   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
   */
  readonly tileHeight: number;
  /**
   * Gets the maximum level-of-detail that can be requested.  This function should
   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
   */
  readonly maximumLevel: number | undefined;
  /**
   * Gets the minimum level-of-detail that can be requested.  This function should
   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
   */
  readonly minimumLevel: number;
  /**
   * Gets the tiling scheme used by this provider.  This function should
   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
   */
  readonly tilingScheme: TilingScheme;
  /**
   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
   */
  readonly rectangle: Rectangle;
  /**
   * Gets the tile discard policy.  If not undefined, the discard policy is responsible
   * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
   * returns undefined, no tiles are filtered.  This function should
   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
   */
  readonly tileDiscardPolicy: TileDiscardPolicy;
  /**
   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
   * are passed an instance of {@link TileProviderError}.
   */
  readonly errorEvent: Event;
  /**
   * Gets a value indicating whether or not the provider is ready for use.
   */
  readonly ready: boolean;
  /**
   * Gets a promise that resolves to true when the provider is ready for use.
   */
  readonly readyPromise: Promise<boolean>;
  /**
   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
   * the source of the imagery.  This function should not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
   */
  readonly credit: Credit;
  /**
   * Gets a value indicating whether or not the images provided by this imagery provider
   * include an alpha channel.  If this property is false, an alpha channel, if present, will
   * be ignored.  If this property is true, any images without an alpha channel will be treated
   * as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage
   * and texture upload time.
   */
  readonly hasAlphaChannel: boolean;
  /**
   * Gets the credits to be displayed when a given tile is displayed.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level;
   * @returns The credits to be displayed when the tile is displayed.
   */
  getTileCredits(x: number, y: number, level: number): Credit[];
  /**
   * Requests the image for a given tile.  This function should
   * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level.
   * @param [request] - The request object. Intended for internal use only.
   * @returns The resolved image as a Canvas DOM object.
   */
  requestImage(x: number, y: number, level: number, request?: Request): Promise<HTMLCanvasElement>;
  /**
   * Picking features is not currently supported by this imagery provider, so this function simply returns
   * undefined.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level.
   * @param longitude - The longitude at which to pick features.
   * @param latitude - The latitude at which to pick features.
   * @returns Undefined since picking is not supported.
   */
  pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): undefined;
}

/**
 * Provides functionality for ImageryProviders that have time dynamic imagery
 * @param options - Object with the following properties:
 * @param options.clock - A Clock instance that is used when determining the value for the time dimension. Required when <code>options.times</code> is specified.
 * @param options.times - TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.
 * @param options.requestImageFunction - A function that will request imagery tiles.
 * @param options.reloadFunction - A function that will be called when all imagery tiles need to be reloaded.
 */
export class TimeDynamicImagery {
  constructor(options: {
    clock: Clock;
    times: TimeIntervalCollection;
    requestImageFunction: (...params: any[]) => any;
    reloadFunction: (...params: any[]) => any;
  });
  /**
   * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.
   */
  clock: Clock;
  /**
   * Gets or sets a time interval collection.
   */
  times: TimeIntervalCollection;
  /**
   * Gets the current interval.
   */
  currentInterval: TimeInterval;
  /**
   * Gets the tile from the cache if its available.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level.
   * @param [request] - The request object. Intended for internal use only.
   * @returns A promise for the image that will resolve when the image is available, or
   *          undefined if the tile is not in the cache.
   */
  getFromCache(x: number, y: number, level: number, request?: Request): Promise<HTMLImageElement> | undefined;
  /**
   * Checks if the next interval is approaching and will start preload the tile if necessary. Otherwise it will
   * just add the tile to a list to preload when we approach the next interval.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level.
   * @param [request] - The request object. Intended for internal use only.
   */
  checkApproachingInterval(x: number, y: number, level: number, request?: Request): void;
}

/**
 * The vertical location of an origin relative to an object, e.g., a {@link Billboard}
 * or {@link Label}.  For example, setting the vertical origin to <code>TOP</code>
 * or <code>BOTTOM</code> will display a billboard above or below (in screen space)
 * the anchor position.
 * <br /><br />
 * <div align='center'>
 * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />
 * </div>
 */
export enum VerticalOrigin {
  /**
   * The origin is at the vertical center between <code>BASELINE</code> and <code>TOP</code>.
   */
  CENTER = 0,
  /**
   * The origin is at the bottom of the object.
   */
  BOTTOM = 1,
  /**
   * If the object contains text, the origin is at the baseline of the text, else the origin is at the bottom of the object.
   */
  BASELINE = 2,
  /**
   * The origin is at the top of the object.
   */
  TOP = -1
}

export namespace WebMapTileServiceImageryProvider {
  /**
   * Initialization options for the WebMapTileServiceImageryProvider constructor
   * @property url - The base URL for the WMTS GetTile operation (for KVP-encoded requests) or the tile-URL template (for RESTful requests). The tile-URL template should contain the following variables: &#123;style&#125;, &#123;TileMatrixSet&#125;, &#123;TileMatrix&#125;, &#123;TileRow&#125;, &#123;TileCol&#125;. The first two are optional if actual values are hardcoded or not required by the server. The &#123;s&#125; keyword may be used to specify subdomains.
   * @property [format = 'image/jpeg'] - The MIME type for images to retrieve from the server.
   * @property layer - The layer name for WMTS requests.
   * @property style - The style name for WMTS requests.
   * @property tileMatrixSetID - The identifier of the TileMatrixSet to use for WMTS requests.
   * @property [tileMatrixLabels] - A list of identifiers in the TileMatrix to use for WMTS requests, one per TileMatrix level.
   * @property [clock] - A Clock instance that is used when determining the value for the time dimension. Required when `times` is specified.
   * @property [times] - TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.
   * @property [dimensions] - A object containing  dimensions and their values.
   * @property [tileWidth = 256] - The tile width in pixels.
   * @property [tileHeight = 256] - The tile height in pixels.
   * @property [tilingScheme] - The tiling scheme corresponding to the organization of the tiles in the TileMatrixSet.
   * @property [rectangle = Rectangle.MAX_VALUE] - The rectangle covered by the layer.
   * @property [minimumLevel = 0] - The minimum level-of-detail supported by the imagery provider.
   * @property [maximumLevel] - The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
   * @property [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
   * @property [credit] - A credit for the data source, which is displayed on the canvas.
   * @property [subdomains = 'abc'] - The subdomains to use for the <code>{s}</code> placeholder in the URL template.
   *                          If this parameter is a single string, each character in the string is a subdomain.  If it is
   *                          an array, each element in the array is a subdomain.
   */
  type ConstructorOptions = {
    url: Resource | string;
    format?: string;
    layer: string;
    style: string;
    tileMatrixSetID: string;
    tileMatrixLabels?: any[];
    clock?: Clock;
    times?: TimeIntervalCollection;
    dimensions?: any;
    tileWidth?: number;
    tileHeight?: number;
    tilingScheme?: TilingScheme;
    rectangle?: Rectangle;
    minimumLevel?: number;
    maximumLevel?: number;
    ellipsoid?: Ellipsoid;
    credit?: Credit | string;
    subdomains?: string | string[];
  };
}

/**
* Provides tiled imagery served by {@link http://www.opengeospatial.org/standards/wmts|WMTS 1.0.0} compliant servers.
* This provider supports HTTP KVP-encoded and RESTful GetTile requests, but does not yet support the SOAP encoding.
* @example
* // Example 1. USGS shaded relief tiles (KVP)
* const shadedRelief1 = new Cesium.WebMapTileServiceImageryProvider({
*     url : 'http://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/WMTS',
*     layer : 'USGSShadedReliefOnly',
*     style : 'default',
*     format : 'image/jpeg',
*     tileMatrixSetID : 'default028mm',
*     // tileMatrixLabels : ['default028mm:0', 'default028mm:1', 'default028mm:2' ...],
*     maximumLevel: 19,
*     credit : new Cesium.Credit('U. S. Geological Survey')
* });
* viewer.imageryLayers.addImageryProvider(shadedRelief1);
* @example
* // Example 2. USGS shaded relief tiles (RESTful)
* const shadedRelief2 = new Cesium.WebMapTileServiceImageryProvider({
*     url : 'http://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/WMTS/tile/1.0.0/USGSShadedReliefOnly/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpg',
*     layer : 'USGSShadedReliefOnly',
*     style : 'default',
*     format : 'image/jpeg',
*     tileMatrixSetID : 'default028mm',
*     maximumLevel: 19,
*     credit : new Cesium.Credit('U. S. Geological Survey')
* });
* viewer.imageryLayers.addImageryProvider(shadedRelief2);
* @example
* // Example 3. NASA time dynamic weather data (RESTful)
* const times = Cesium.TimeIntervalCollection.fromIso8601({
*     iso8601: '2015-07-30/2017-06-16/P1D',
*     dataCallback: function dataCallback(interval, index) {
*         return {
*             Time: Cesium.JulianDate.toIso8601(interval.start)
*         };
*     }
* });
* const weather = new Cesium.WebMapTileServiceImageryProvider({
*     url : 'https://gibs.earthdata.nasa.gov/wmts/epsg4326/best/AMSR2_Snow_Water_Equivalent/default/{Time}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.png',
*     layer : 'AMSR2_Snow_Water_Equivalent',
*     style : 'default',
*     tileMatrixSetID : '2km',
*     maximumLevel : 5,
*     format : 'image/png',
*     clock: clock,
*     times: times,
*     credit : new Cesium.Credit('NASA Global Imagery Browse Services for EOSDIS')
* });
* viewer.imageryLayers.addImageryProvider(weather);
* @param options - Object describing initialization options
*/
export class WebMapTileServiceImageryProvider {
  constructor(options: WebMapTileServiceImageryProvider.ConstructorOptions);
  /**
   * The default alpha blending value of this provider, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  defaultAlpha: number | undefined;
  /**
   * The default alpha blending value on the night side of the globe of this provider, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  defaultNightAlpha: number | undefined;
  /**
   * The default alpha blending value on the day side of the globe of this provider, with 0.0 representing fully transparent and
   * 1.0 representing fully opaque.
   */
  defaultDayAlpha: number | undefined;
  /**
   * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0
   * makes the imagery darker while greater than 1.0 makes it brighter.
   */
  defaultBrightness: number | undefined;
  /**
   * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces
   * the contrast while greater than 1.0 increases it.
   */
  defaultContrast: number | undefined;
  /**
   * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.
   */
  defaultHue: number | undefined;
  /**
   * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the
   * saturation while greater than 1.0 increases it.
   */
  defaultSaturation: number | undefined;
  /**
   * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.
   */
  defaultGamma: number | undefined;
  /**
   * The default texture minification filter to apply to this provider.
   */
  defaultMinificationFilter: TextureMinificationFilter;
  /**
   * The default texture magnification filter to apply to this provider.
   */
  defaultMagnificationFilter: TextureMagnificationFilter;
  /**
   * Gets the URL of the service hosting the imagery.
   */
  readonly url: string;
  /**
   * Gets the proxy used by this provider.
   */
  readonly proxy: Proxy;
  /**
   * Gets the width of each tile, in pixels. This function should
   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
   */
  readonly tileWidth: number;
  /**
   * Gets the height of each tile, in pixels.  This function should
   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
   */
  readonly tileHeight: number;
  /**
   * Gets the maximum level-of-detail that can be requested.  This function should
   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
   */
  readonly maximumLevel: number | undefined;
  /**
   * Gets the minimum level-of-detail that can be requested.  This function should
   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
   */
  readonly minimumLevel: number;
  /**
   * Gets the tiling scheme used by this provider.  This function should
   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
   */
  readonly tilingScheme: TilingScheme;
  /**
   * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
   */
  readonly rectangle: Rectangle;
  /**
   * Gets the tile discard policy.  If not undefined, the discard policy is responsible
   * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
   * returns undefined, no tiles are filtered.  This function should
   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
   */
  readonly tileDiscardPolicy: TileDiscardPolicy;
  /**
   * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
   * are passed an instance of {@link TileProviderError}.
   */
  readonly errorEvent: Event;
  /**
   * Gets the mime type of images returned by this imagery provider.
   */
  readonly format: string;
  /**
   * Gets a value indicating whether or not the provider is ready for use.
   */
  readonly ready: boolean;
  /**
   * Gets a promise that resolves to true when the provider is ready for use.
   */
  readonly readyPromise: Promise<boolean>;
  /**
   * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
   * the source of the imagery.  This function should not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
   */
  readonly credit: Credit;
  /**
   * Gets a value indicating whether or not the images provided by this imagery provider
   * include an alpha channel.  If this property is false, an alpha channel, if present, will
   * be ignored.  If this property is true, any images without an alpha channel will be treated
   * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
   * and texture upload time are reduced.
   */
  readonly hasAlphaChannel: boolean;
  /**
   * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.
   */
  clock: Clock;
  /**
   * Gets or sets a time interval collection that is used to get time dynamic parameters. The data of each
   * TimeInterval is an object containing the keys and values of the properties that are used during
   * tile requests.
   */
  times: TimeIntervalCollection;
  /**
   * Gets or sets an object that contains  dimensions and their values.
   */
  dimensions: any;
  /**
   * Gets the credits to be displayed when a given tile is displayed.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level;
   * @returns The credits to be displayed when the tile is displayed.
   */
  getTileCredits(x: number, y: number, level: number): Credit[];
  /**
   * Requests the image for a given tile.  This function should
   * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level.
   * @param [request] - The request object. Intended for internal use only.
   * @returns A promise for the image that will resolve when the image is available, or
   *          undefined if there are too many active requests to the server, and the request should be retried later.
   */
  requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
  /**
   * Picking features is not currently supported by this imagery provider, so this function simply returns
   * undefined.
   * @param x - The tile X coordinate.
   * @param y - The tile Y coordinate.
   * @param level - The tile level.
   * @param longitude - The longitude at which to pick features.
   * @param latitude - The latitude at which to pick features.
   * @returns Undefined since picking is not supported.
   */
  pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): undefined;
}

/**
 * <span style="display: block; text-align: center;">
 * <img src="Images/AnimationWidget.png" width="211" height="142" alt="" />
 * <br />Animation widget
 * </span>
 * <br /><br />
 * The Animation widget provides buttons for play, pause, and reverse, along with the
 * current time and date, surrounded by a "shuttle ring" for controlling the speed of animation.
 * <br /><br />
 * The "shuttle ring" concept is borrowed from video editing, where typically a
 * "jog wheel" can be rotated to move past individual animation frames very slowly, and
 * a surrounding shuttle ring can be twisted to control direction and speed of fast playback.
 * Cesium typically treats time as continuous (not broken into pre-defined animation frames),
 * so this widget offers no jog wheel.  Instead, the shuttle ring is capable of both fast and
 * very slow playback.  Click and drag the shuttle ring pointer itself (shown above in green),
 * or click in the rest of the ring area to nudge the pointer to the next preset speed in that direction.
 * <br /><br />
 * The Animation widget also provides a "realtime" button (in the upper-left) that keeps
 * animation time in sync with the end user's system clock, typically displaying
 * "today" or "right now."  This mode is not available in {@link ClockRange.CLAMPED} or
 * {@link ClockRange.LOOP_STOP} mode if the current time is outside of {@link Clock}'s startTime and endTime.
 * @example
 * // In HTML head, include a link to Animation.css stylesheet,
 * // and in the body, include: <div id="animationContainer"></div>
 *
 * const clock = new Cesium.Clock();
 * const clockViewModel = new Cesium.ClockViewModel(clock);
 * const viewModel = new Cesium.AnimationViewModel(clockViewModel);
 * const widget = new Cesium.Animation('animationContainer', viewModel);
 *
 * function tick() {
 *     clock.tick();
 *     Cesium.requestAnimationFrame(tick);
 * }
 * Cesium.requestAnimationFrame(tick);
 * @param container - The DOM element or ID that will contain the widget.
 * @param viewModel - The view model used by this widget.
 */
export class Animation {
  constructor(container: Element | string, viewModel: AnimationViewModel);
  /**
   * Gets the parent container.
   */
  readonly container: Element;
  /**
   * Gets the view model.
   */
  readonly viewModel: AnimationViewModel;
  /**
   * @returns true if the object has been destroyed, false otherwise.
   */
  isDestroyed(): boolean;
  /**
   * Destroys the animation widget.  Should be called if permanently
   * removing the widget from layout.
   */
  destroy(): void;
  /**
   * Resizes the widget to match the container size.
   * This function should be called whenever the container size is changed.
   */
  resize(): void;
  /**
   * Updates the widget to reflect any modified CSS rules for theming.
   * @example
   * animation.applyThemeChanges();
   */
  applyThemeChanges(): void;
}

/**
 * Hide display mode by eigenvalue
 */
export enum CategoryVisibleMode {
  /**
     * hide
     */
  Hide = 0,
  /**
   * show
   */
  Visible = 1,
  /**
   * ResetAll
   */
  ResetAll = 2
}

/**
 * Sectional pattern of clipping surface
 */
export enum ClipPlaneMode {
  /**
    * no cross section
    */
  NONE = 0,
  /**
   * Cross sections in the specified color
   */
  COLOR = 1,
  /**
   * Cross sections use the color of the model
   */
  MODEL_COLOR = 2
}

export enum DATAFILETYPE {
  OSGBFile = 0,
  OSGBCacheFile = 1,
  ClampGroundPolygon = 2,
  ClampObjectPolygon = 3,
  ClampGroundLine = 4,
  ClampObjectLine = 5,
  IconPoint = 6,
  Text = 7,
  PointCloudFile = 8,
  // 动态拉伸面
  ExtendRegion3D = 9,
  ExtendClampPolygonCache = 10,

  PolylineEffect = 11,
  RegionEffect = 12,
  ClampGroundAndObjectLineCache = 13,
  ClampGroundRealtimeRasterCache = 14
}

export enum EmissionTextureUnit {
  None = 0,
  First = 1,
  Second = 2
}

export enum INSTANCEMODE {
  SIZE_PER_INSTANCE = 20,
  SIZE_PER_DM_INSTANCE = 35,
  S3MB_BIM_INSTANCE = 17,
  S3MB_BIM_INSTANCE_2 = 16,
  S3MB_PIPE_INSTANCE = 29,
}

export enum InterpolationType {
  /**
   * Linear interpolation
   */
  Linear = 0,
  /**
   * Accelerated motion interpolation
   */
  Acceleration = 1,
  /**
   * Deceleration motion interpolation
   */
  Deceleration = 2,
  /**
   * Cubic spline interpolation
   */
  CubicSpline = 3,
  /**
   * SmoothStep interpolation
   */
  SmoothStep = 4
}

export enum LoadingPriorityMode {
  /**
   * Layer first
   */
  Root_Priority = 0,
  /**
   * Depth first
   */
  Child_Priority = 1,
  /**
   * Load according to the spatial index
   */
  UsePagedLodInfo = 2,
  /**
   * Depth-first nonlinear switching
   */
  Child_Priority_NonLinear = 3
}

export enum LOADSTATE {
  UNLOAD = 0,
  LOADING = 1,
  LOADED = 2,
  VOLLOADED = 3,
  PARSING = 4,
  PARSED = 5,
  TRANSFORMING = 6,
  TRANSFORMED = 7,
  LOST = 8,
  LOADVOL = 9,
  FAILED = 10,
  VOLFAILED = 11
}

/**
 * Layer color blending mode
 */
export enum MixColorType {
  /**
   * Color blending mode
   */
  MIX = 0,
  /**
   * Color replacement mode
   */
  REPLACE = 1
}

/**
 * The excavation mode
 */
export enum ModifyRegionMode {
  /**
   * Excavation of the internal
   */
  CLIP_INSIDE = 0,
  /**
   * The excavation outside
   */
  CLIP_OUTSIDE = 1
}

export enum ObjsOperationType {
  RESET = 0,
  SetColor = 0x01,
  SELECTED = 0x02,
  HIDE = 0x04,
  OFFSET = 0x08,
  CLIP = 0x10,
  BLOOM = 0x20,
  ALL = 0xff
}

/**
 * Particle Effects type
 */
export enum ParticleSystemType {
  /**
   * fire
   */
  FIRE = 0,
  /**
   * fountain
   */
  FOUNTAIN = 1,
  /**
   * rain
   */
  RAIN = 2
}

export enum PBR_MATERIAL_TYPE {
  NONE = 0,
  TITANIUM_SCUFFED = 1,
  METAL_PLATE = 2,
  EMISSION = 4,
  ROUGHNESS = 8
}

/**
 * Point cloud rendering mode
 */
export enum PointCloudRenderMode {
  /**
   * General point
   */
  POINT = 0,
  /**
   * The body of the yuan
   */
  VOXEL = 1
}

export enum ProgramDefines {
  EXCAVATION = 'EXCAVATION',
  FALTTEN = 'FALTTEN',
  OVERLAY = 'OVERLAY',
  HYPSOMETRIC = 'HYPSOMETRIC',
  ADJUST_COLOR = 'ADJUST_COLOR',
  TRANSPARENT_BACK_COLOR = 'TRANSPARENT_BACK_COLOR',
  HORIZONTAL_LINE = 'HORIZONTAL_LINE',
  COMPUTE_W_VALUE = 'COMPUTE_W_VALUE',
  COMPUTE_TEXCOORD = 'COMPUTE_TEXCOORD',
  HAS_LIGHT = 'HAS_LIGHT',
  HAS_NORMAL = 'HAS_NORMAL',
  REPLACE_SELECT_TYPE = 'REPLACE_SELECT_TYPE',
  SILHOUETTE_SELECT_TYPE = 'SILHOUETTE_SELECT_TYPE',
  MULTI_TEX = 'MULTI_TEX',
  APPLY_SPLIT = 'APPLY_SPLIT',
  APPLY_SWIPE = 'APPLY_SWIPE',
  TEXCOORD = 'TexCoord',
  TEXCOORD2 = 'TexCoord2',
  COMPRESS_VERTEX = 'COMPRESS_VERTEX',
  COMPRESS_NORMAL = 'COMPRESS_NORMAL',
  COMPRESS_COLOR = 'COMPRESS_COLOR',
  COMPRESS_TEXCOORD = 'COMPRESS_TEXCOORD',
  SKETCH_MODE = 'SKETCH_MODE',
  NORMAL_AND_DEPTH = 'NORMAL_AND_DEPTH',
  POST_EFFECT = 'POST_EFFECT',
  CLIP_FILT_BY_ID = 'CLIP_FILT_BY_ID',
  CLIP = 'CLIP',
  CLIPPLANE = 'CLIPPLANE',
  PBR = 'PBR',
  PT_CLOUD = 'PT_CLOUD',
  DIR_LIGHTS = 'DIR_LIGHTS ',
  POINT_LIGHTS = 'POINT_LIGHTS ',
  SPOT_LIGHTS = 'SPOT_LIGHTS ',
  W_VISIBLE = 'W_VISIBLE',
  EMISSION_TEXTURE = 'EMISSION_TEXTURE',
  EMISSION_TEXTURE_COUNT = 'EMISSION_TEXTURE_COUNT ',
  TEXTURE_MOVE = 'TEXTURE_MOVE',
  VOLUME = 'Volume',
  VOLUME2 = 'Volume2',
  TEXTURE_COORD_ONE_IS_W = 'TEXTURE_COORD_ONE_IS_W',
  TRIANGLE_FILTRATE = 'TRIANGLE_FILTRATE',
  UseInstanceSkeletonMatrix = 'UseInstanceSkeletonMatrix',
  RGBTOBGR = 'RGBTOBGR',
  HAS_SKELETONSELECTED = 'HAS_SKELETONSELECTED',
  SKELETONSELECT_ENABLE = 'SKELETONSELECT_ENABLE',
  REPLACE_COLOR_TYPE = 'REPLACE_COLOR_TYPE',
  INVALID_OBLIQUE = 'INVALID_OBLIQUE',//无效倾斜数据,默认用灰色
  IGNORE_NORMAL = 'IGNORE_NORMAL',
  TextureBatch = 'TextureBatch',
  Translation = 'Translation',
  VOL_AND_HYP = 'VOL_AND_HYP', // 有VOLUME时只有分层设色颜色，不用专题图颜色
  VERTEX_CAPTURE = 'VERTEX_CAPTURE',
  SEC_TEX_EMISSION = 'SEC_TEX_EMISSION',
  BRDF = 'BRDF',
  PBR_THEME = 'PBR_THEME',
  IBL = 'IBL',
  POINT = 'POINT',
  HAS_BASE_TEXTURE = 'HAS_BASE_TEXTURE',
  HAS_NORMAL_TEXTURE = 'HAS_NORMAL_TEXTURE',
  HAS_OCCLUSION_TEXTURE = 'HAS_OCCLUSION_TEXTURE',
  HAS_EMISSIVE_TEXTURE = 'HAS_EMISSIVE_TEXTURE',
  REFRACTION = 'REFRACTION',
  HAS_ANISOTROPY = 'HAS_ANISOTROPY',
  HAS_CLEARCOAT = 'HAS_CLEARCOAT',
  HAS_VOLUME = 'HAS_VOLUME',
  HAS_TRANSMISSION = 'HAS_TRANSMISSION',
  USE_BatchPBR = 'USE_BatchPBR',
  HAS_DIR_LIGHTS = 'HAS_DIR_LIGHTS',
  HAS_POINT_LIGHTS = 'HAS_POINT_LIGHTS',
  HAS_SPOT_LIGHTS = 'HAS_SPOT_LIGHTS',
  NO_TEXCOORD = 'NO_TEXCOORD',
  FLOOD_ANALYSIS = 'FLOOD_ANALYSIS',
  HAS_RAIN = 'HAS_RAIN',
  HAS_WETNESS = 'HAS_WETNESS',
  HAS_SNOW = 'HAS_SNOW',
  HAS_MetallicRoughness_TEXTURE = 'HAS_MetallicRoughness_TEXTURE',
  FusionMode = 'FusionMode',
  VISIBLEDISTANCEMAX = 'VISIBLEDISTANCEMAX',
  // BBL= Babylon
  BBL_OPACITY = 'BBL_OPACITY',
  BBL_OPACITYRGB = 'BBL_OPACITYRGB',
  METALLICWORKFLOW = 'METALLICWORKFLOW',
  DEBUGMODE = 'DEBUGMODE',
  REFLECTIVITY = 'REFLECTIVITY',
  ROUGHNESSSTOREINMETALMAPGREEN = 'ROUGHNESSSTOREINMETALMAPGREEN',
  METALLNESSSTOREINMETALMAPBLUE = 'METALLNESSSTOREINMETALMAPBLUE',
  SHEEN = 'SHEEN',
  SHEEN_TEXTURE = 'SHEEN_TEXTURE',
  SHEENBRDF_TEXTURE = 'SHEENBRDF_TEXTURE',
  SHEEN_ROUGHNESS = 'SHEEN_ROUGHNESS',
  CLEARCOAT = 'CLEARCOAT',
  CLEARCOAT_TEXTURE = 'CLEARCOAT_TEXTURE',
  CLEARCOAT_TINT = 'CLEARCOAT_TINT',
  CLEARCOAT_TINT_TEXTURE = 'CLEARCOAT_TINT_TEXTURE',
  CLEARCOAT_BUMP = 'CLEARCOAT_BUMP',
  SUBSURFACE = 'SUBSURFACE',
  SS_THICKNESSANDMASK_TEXTURE = 'SS_THICKNESSANDMASK_TEXTURE',
  SS_REFRACTION = 'SS_REFRACTION',
  SS_TRANSLUCENCY = 'SS_TRANSLUCENCY'
}

export enum RANGEMODE {
  DISTANCE_FROM_EYE_POINT = 0,
  PIXEL_SIZE_ON_SCREEN = 1,
  GEOMETRY_ERROR = 2
}

/**
 * S3M texture compression type
 */
export enum S3MCompressType {
  /**
   * compression
   */
  encNONE = 0,
  /**
   * DXT compression
   */
  enrS3TCDXTN = 14,
  /**
   * PVR compression -IOS devices
   */
  enrPVRTPF_PVRTC2 = 19,
  /**
   * PVR compression -IOS devices
   */
  enrPVRTPF_PVRTC = 20,
  /**
   * PVR compression -IOS devices
   */
  enrPVRTPF_PVRTC_4bpp = 21,
  /**
   * ETC compression - Android devices
   */
  enrPVRTPF_ETC1 = 22
}

export enum VERSION {
  S3M = 49,
  S3M4 = 1
}

/**
 * Select Color mode for S3M layer
 */
var SelectColorType = {
  /**
   * Color blending mode
   */
  MIX = 0,
  /**
   * Color replacement mode
   */
  REPLACE = 1,
  /**
   * Contour model
   */
  SILHOUETTE = 2,
  /**
   * Contour mode that will not be occluded
   */
  ALWAYS_SHOW_SILHOUETTE = 3,
  /**
   * Outer contour mode
   */
  SILHOUETTE_EDGE = 4
};

/**
 * S3M Layer shadow type
 */
export enum SHADOWTYPE {
  /**
   * Close the shadow
   */
  NONE = 0,
  /**
   * Select only the object to turn on shadow
   */
  SELECTION = 1,
  /**
   * Turn shadow on for all objects
   */
  ALL = 2
}

export enum SkeletonState {
  UnLoad = 0,
  Loading = 1,
  Loaded = 2,
  Parsing = 3,
  Ready = 4,
  LoadedFailed = 5,
  ParseFailed = 6
}

/**
 * SplitDirection
 */
export enum SplitDirection {
  /**
   * Disable the split
   */
  NONE = 0,
  /**
   * Shield the left side of the curtain
   */
  LEFT = 1,
  /**
   * Shield the right side of the curtain
   */
  RIGHT = 2,
  /**
   * Shield the top of the curtain
   */
  TOP = -1,
  /**
   * Shield the lower side of the curtain
   */
  BOTTOM = -2
}

export enum VertexWeightMode {
  DatasetField = 0,
  EdgeLengthMin = 1
}

/**
 * Facade立面出图类，通过该功能，对场景中的模型输出指定范围的立面图。 
 */
export class Facade {
  /**
   * 获取终止点
   */
  endPoint: Cartesian3;

  /**
   * 获取或设置立面出图范围的最远距离
   */
  farDistance: Number;

  /**
   * 获取或设置立面出图的最大高度。
   * 异步对象，解析出立面图的base64字符串（和场景出图用法保持一致）。
   *  @example
   * facade.readyPromise.then(function(base64) {
          XXX // 将base64字符串转换为图片进行下载或者填充到别的元素中
       });
   */
  readyPromise: Promise;

  /**
   * 获取起始点。
   */
  startPoint: Cartesian3

  /**
   * 将立面分析加入分析图层中进行更新
   */
  build(): void;

  /**
   * 设置指定线段出图的起止点
   * @param 开始位置
   * @param 结束位置
   */
  setBoundByPoints(startPoint: Cartesian3, endPoint: Cartesian3)
}

export class LimitBody {
  constructor(positions: any, skyline: any)

  destroy(): void;

  initialize(): void;

  update(): void;
}

/**
 * 剖面线分析类，在场景中选取起始点、结束点进行分析，获得剖面线分析效果图。
 */
export class Profile {
  /**
   * @param scene 指定用于分析的场景对象
   * @example
   * 创建剖面线分析
   * var profile= new Cesium.Profile(scene);
   */
  constructor(scene: Object)

  /**
   * 获取或设置剖面线分析的结束点。该点由经度、纬度和高程组成的数组表示
   */
  endPoint: Array

  /**
   * 获取或设置剖面分析在三维空间中的跨越高度，单位是米
   */
  extendHeight: Number

  /**
   * 获取或设置剖面线分析的起始点。该点由经度、纬度和高程组成的数组表示
   */
  startPoint: Array

  /**
   * 执行剖面线分析
   */
  build(): void

  /**
   * 清除分析结果
   */
  destroy(): void

  /**
   * 获取剖面分析的结果
   * @param func - 回调函数，其参数是剖面分析的结果（剖面图rgba字节流）
   */
  getBuffer(func: () => void);

  /**
   * 获取分析结果的点集的实际地理坐标
   * @param func - 回调函数，其参数是剖面分析的结果
   */
  getPositions(func: () => void);
}

/**
 * 视频投放类。将图片或视频投放到场景中，可模拟建筑物上的广告幕布或大屏电视效果
 * @param scene - 指定用于分析的场景对象
 * @example 
 * 创建视频投放
 * var projectionImagee= new Cesium.ProjectionImage(scene);
 */
export class ProjectionImage {
  constructor(scene: Object)

  /**
   * 获取或设置视频投放时投影仪的方位角，即顺时针与正北方向的夹角，取值范围：0度~360度
   */
  direction: number

  /**
   * 获取或设置观察点到投影仪的距离
   */
  distance: number

  /**
   * 获取或设置视频投放时提示线的颜色
   */
  hintLineColor: Color

  /**
   * 获取或设置视频投放时提示线的可见性
   */
  hintLineVisible: Color

  /**
   * 获取或设置视频投放时投影仪的水平视角范围，单位：度
   */
  horizontalFov: number

  /**
   * 获取或设置视频投放时投影仪的俯仰角，该角指相机方向和水面方向的夹角，取向上为正，单位：度
   */
  pitch: number

  /**
   * 获取或设置视频投放时投影仪的垂直视角范围，单位：度
   */
  verticalFov: number

  /**
   * 获取或设置视频投放观察者的位置。位置由经度、纬度和高程组成的数组表示
   */
  viewPosition: array

  /**
   *  获取或者设置视频投放是否可见，默认为true
   */
  visible: boolean

  /**
   * 获取或者设置视频投放的最大可见距离，默认为500
   */
  visibleDistanceMax: number

  /**
   * 从文件中读取多路视频，即通过文件同时添加多个视频进行投放
   * @param scene -	进行投放的场景
   * @param infoUrl - 视频的属性信息文件的地址或者路径
   * @param baseUrl - 基础路径。如果添加， 则会和文件中视频的名字拼接成一个路径，如果不添加，则使用infoUrl文件中的父级路径作为baseUrl
   * @example 
   * Cesium.ProjectionImage.fromInfo(scene, './data/allprojectionInfo.xml', './media/')
   */
  fromInfo(scene: Scene, infoUrl: string, baseUrl: string): Promise

  /**
   * 添加裁剪多边形
   * @param name - 多边形的名称
   * @param position - 多边形的位置
   */
  addClipRegion(options: { name: string, position: Cartesian3 }): boolean;

  /**
   * 执行视频投放分析
   */
  build(): void

  /**
   * 获取视频投放分析在指定视口的可见性
   * @param index - 指定的视口索引
   */
  getVisibleInViewport(index: number): boolean;

  /**
   * 图片像素坐标转世界坐标
   * @param x - 图片像素的x坐标
   * @param x - 图片像素的y坐标
   */
  pixelToWorldCoordinates(x: number, y: number): Cartesian3

  /**
   * 删除所有多边形 
   */
  removeAllClipRegion(): boolean

  /**
   * 删除指定名称的多边形
   * @param name - 多边形名称
   */
  removeClipRegion(name: string): boolean

  /**
   * 设置裁剪模式
   * @param - 为ModifyRegionMode枚举
   */
  setClipMode(mode: any): boolean

  /**
   * 按点设置方向(经度、纬度和高度)
   * @param position
   */
  setDistDirByPoint(position: array): void

  /**
   * 设置图片融合的S3M图层
   * @param layers - S3M图层
   */
  setFusionLayers(layers: array): void

  /**
   * 设置用于投放的图片或视频对象
   * @param options - url: 指定图片资源的地址 video:指定视频的地址，目前仅支持*.webm格式的视频，目前只支持.webm
   */
  setImage(options: { url: array, video: object })

  /**
   * 设置视频投放的位置信息，这些位置信息被保存在一个.xml的文件中，通过读取该文件的内容进行设置
   * @param url - 存储位置信息的文件的地址
   */
  setInfo(url: string)

  /**
   * 设置视频投放分析在指定视口的可见性ShadowQueryPoints
   * @param index - 指定的视口索引 索引值的范围为0-3
   */
  setVisibleInViewport(index: number)
}

/**
 * 阴影率分析类，指定分析范围、设置阴影类型、设定分析时间段得出阴影率分析结果
 * @param scene - 场景对象
 * @example 
 * //创建阴影率分析
 * var shadowQueryPoints= new Cesium.ShadowQueryPoints(scene)
 */
export class ShadowQueryPoints {
  constructor(scene: Scene);

  /**
   * 设置颜色表
   */
  colorTable: ColorTable;

  /**
   * 获取或设置分析的结束时间
   */
  endTime: JulianDate

  /**
   * 获取点集和每个点的阴影率事件
   */
  queryPointsEvent: Event

  /**
   * 获取或设置阴影率点的间距
   */
  spacing: number

  /**
   *  获取或设置分析的开始时间
   */
  startTime: JulianDate

  /**
   * 用于获取体元数据，设置给S3M图层，以体覆盖的形式来表达日照率
   */
  voxelData: object

  /**
   * 执行阴影分析
   */
  build(): void

  /**
   * 获得阴影率 
   * @param cartographic - 经纬度
   */
  getShadowRadio(cartographic: object): number

  /**
   * 获得阴影率分析在指定视口的可见性
   * @param index - 指定的视口索引  索引值的范围为：0-3
   */
  getVisibleInViewport(index: number): boolean

  /**
   * 添加阴影率分析的区域
   * @param options.position -  指定分析区域的位置信息，由包含经度、纬度的数组表示
   * @param options.bottom - 指定分析区域的底部高程
   * @param options.extend - 指定分析区域的拉伸高度
   */
  qureyRegion(options: { position: array, bottom: string, extend: string }): void

  /**
   * 设置阴影率分析在指定视口的可见性
   * @param index - 指定的视口索引 索引值的范围为：0-3
   */
  setVisibleInViewport(index: number): void
}

/**
 * 视线分析，即通视分析，根据观察者点位和目标点建立视线分析，并在场景中分析得到结果
 * @param scene - 场景对象
 * @example
 * //创建通视分析
 * var sightline = new Cesium.Sightline(scene)
 */
export class Sightline {
  constructor(scene: Scene)

  /**
   * 获取或设置通视分析的不可见部分颜色
   * @example
   * var sightline = new Cesium.Sightline(scene);
   * var color = new Cesium.Color(1, 0, 0);
   * //设置不可见部分的颜色
   * sightline .hiddenColor = color;
   * //获取不可见部分的颜色
   * var value= sightline .hiddenColor
   */
  hiddenColor: Color

  /**
   * 获取或设置通视线的宽度
   */
  lineWidth: number

  /**
   * 获取或设置观察者的位置。位置由经度、纬度和高程组成的数组表示
   * @example
   * var sightline = new Cesium.Sightline(scene);
  * //设置观察者的位置
  * sightline .viewPosition   = [120, 40, 100];F
  * //获取观察者的位置
  * var value= sightline .viewPosition;
   */
  viewPosition: array

  /**
   * 获取或设置通视分析的可见部分颜色
   * @example
   *  var sightline = new Cesium.Sightline(scene);
   * var color = new Cesium.Color(0, 1, 0);
   * //设置可见部分颜色
   * sightline .visibleColor = color;
   * //获取可见部分颜色
   * var value= sightline .visibleColor
   */
  visibleColor: Color

  /**
   * 添加目标点
   * @param options.position - 位置信息，由经度、纬度和高程组成的数组表示
   * @param options.name - 目标点的名称
   * @example
   * var sightline = new Cesium.Sightline(scene);
   * sightline.addTargetPoint({
   * postion : [120, 40, 50],
   * name : “first”
   *  });
   */
  addTargetPoint(options: { position: Array, name: string }): boolean

  /**
   * 执行通视分析
   * @example
   * var sightline = new Cesium.Sightline(scene);
   * sightline.build()
   */
  build(): void

  /**
   * 获得障碍点
   * @param name - 目标点名称
   * @param func - 回调函数
   */
  getBarrierPoint(name: string, func: () => void): object

  /**
   * 获取通视分析所有障碍物对象的IDS集合
   * @returns 返回一个k-v对象，key为S3M图层ID，value为对象IDS数组
   */
  getObjectIds(): object

  /**
   * 获得图层对应视口可见性
   * @param index - 索引 
   * @returns visible 可见性
   */
  getVisibleInViewport(index: number): boolean

  /**
   * 移除所有目标点
   * @example
   * var sightline = new Cesium.Sightline(scene);
   * sightline.removeAllTargetPoint()
   */
  removeAllTargetPoint(): void

  /**
   * 移除指定名称的目标点
   * @param name - 待移除的目标点名称
   * @return 移除成功返回true,否则返回false
   * @example
   * var sightline = new Cesium.Sightline(scene);
   * var flag = sightline.removeTargetPoint(“first”);
   */
  removeTargetPoint(name: string): boolean

  /**
   * 设置图层对应视口可见性
   * @param index - 索引
   */
  setVisibleInViewport(index: number): void
}

/**
 * 天际线分析。可设定观察者位置、观察方向，并在场景中得到分析结果
 * @example
 * //创建天际线分析
 * var skyline= new Cesium.Skyline(scene);
 */
export class Skyline {
  constructor(scene: object)

  /**
   * Get or Set the color
   * @example
   * var skyline= new Cesium.Skyline(scene);
   * var color = new Cesium.Color(0, 1, 0);
   * //设置颜色
   * skyline.color = color;
   * //获取颜色
   * var value= skyline.color ;
   */
  color: Color

  /**
   * 获取或设置相机与正北方向的夹角。单位：度，取值范围0-360
   * @example
   * var skyline= new Cesium.Skyline(scene);
   * //设置方向
   * skyline.direction = 1.0;
   * //获取方向
   * var value= skyline.direction ;
   */
  direction: number

  /**
   * 获取或设置线、面的显示模式。当值取0时，以线的形式展示；当值为1时，以面展示。默认值为线
   */
  displayMode: number

  /**
   * 获取或设置天际线的显示模式。 DisplayMode.LINE表示天际线的线模式，DisplayMode.FACE表示天际线的面模式
   * @example
   * var skyline= new Cesium.Skyline(scene);
   * //设置显示模式
   * skyline.displayStyle = Cesium.Skyline.displayMode.LINE;
   * //获取显示模式
   * var value= skyline.displayStyle ;
   */
  displayStyle: number

  /**
   * 地球表面是否参与天际线分析，默认值为false表示参与，当设置为true则表示不参与
   */
  ignoreGlobe: boolean

  /**
   * 设置天际线的宽度，默认1像素
   */
  lineWidth: number

  /**
   * 获取或设置相机的俯仰角，该俯仰角为相机方向和水面方向的夹角。单位：度，取值范围为0-90
   * @example
   * var skyline= new Cesium.Skyline(scene);
   * //设置俯仰角
   * skyline.pitch = 1.0;
   * //获取俯仰角
   * var value= skyline.pitch; 
   */
  pitch: number

  /**
   * 获取或设置天际线分析半径，单位：米。默认值为-1.0，表示无穷远
   */
  radius: number

  /**
   * Get or Set the viewPosition
   * @example
   * var skyline= new Cesium.Skyline(scene);
   * //设置观察者的位置
   * skyline.viewPosition   = [120, 40, 100];
   * //获取观察者的位置
   * var value= skyline.viewPosition;
   */
  viewPosition: array

  /**
   * 为天际线分析添加限高体对象，模拟新建建筑物在不影响天际线时的高度范围
   * @param options.position - 指定限高体位置信息，由经度、纬度的数组表示
   * @param options.name - 指定限高体名称
   * @returns 添加成功返回true,失败返回fals
   */
  addLimitbody(options: { position: array, name: string }): boolean

  /**
   * 执行天际线分析
   * @example
   * var skyline= new Cesium.Skyline(scene);
   * skyline.bulid();
   */
  build(): void

  /**
   * 清除限高体
   */
  clear(): void

  /**
   * 获取障碍物对象的IDS集合
   * @returns 返回一个k-v对象，key为S3M图层ID，value为对象IDS数组
   */
  getObjectIds(): object

  /**
   * 输出二维的天际线分析结果
   * @returns 二维线，由x/y数组表示
   */
  getSkyline2D(): Object

  /**
   * 输出三维的天际线分析结果
   * @returns 三维线，由x/y/z数组表示
   */
  getSkyline3D(): Object

  /**
   * 获取天际线闭合体的构建参数，包括三维天际线、观察点位置
   */
  getSkylineSectorParameter(): object

  /**
   * 获取天际线分析结果在指定视口的可见性
   * @param index 指定的视口索引索引值的范围为0-3
   */
  getVisibleInViewport(index: number): boolean

  /**
   * 移除所有限高体对象
   */
  removeAllLimitBody(): void

  /**
   * 移除指定名称的限高体对象
   * @param name 待移除限高体的名称
   * @returns 移除成功返回true,失败返回false
   */
  removeLimitbody(name: string): boolean

  /**
   * 设置天际线分析结果在指定视口的可见性
   * @param index 指定的视口索引
   */
  setVisibleInViewport(index: number): void
}

/**
 * 可视域分析，设置观察点、目标的位置，水平、垂直视角范围，建立可视区域分析并在指定的场景中显示分析结果
 * @param scene 场景对象
 * @example
 * //创建可视域分析
 * var viewShed3D= new Cesium.ViewShed3D(scene);
 */
export class ViewShed3D {
  constructor(scene: object)

  /**
   * 获取或设置当前相机的方向与正北方向的夹角，单位：度
   */
  direction: number

  /**
   * 获取或设置可视距离，单位：米
   */
  distance: number

  /**
   * 获取或设置不可见区域的颜色
   */
  hiddenAreaColor: Color

  /**
   * 获取或设置可视域分析的提示线颜色
   */
  hintLineColor: Color

  /**
   * 获取或设置可视域分析的水平视角范围。单位：度
   */
  horizontalFov: number

  /**
   * 获取或设置当前分析的相机俯仰角。注意：该俯仰角指当相机方向与地面平行的时候是0度，与相机本身参数俯仰不一样
   */
  pitch: number

  /**
   * 获取或设置可视域分析垂直视角范围。单位：度
   */
  verticalFov: number

  /**
   * 获取或设置观察点的位置。位置由经度、纬度和高程组成的数组表示
   */
  viewPosition: array

  /**
   * 获取或设置可见区域的颜色
   */
  visibleAreaColor: Color

  /**
   * 添加裁剪区域
   * @param options.name 裁剪区域的名称 
   * @param options.position 裁剪区域 
   * @returns 裁剪区域是否添加成功
   */
  addClipRegion(options: { name: string, position: array }): boolean

  /**
   * 获取目标点对应的障碍点
   * @param options 
   * @param targetPoint 目标点
   * @returns 障碍点
   */
  getBarrierPoint(options: object, targetPoint: Point3D): Point3D

  /**
   * 获取可视域闭合体的构建参数。
   * @Returns 返回可视/不可视闭合体的构建参数，包括视点、目标、障碍点行列阵列及半径
   */
  getViewshedParameter(): object

  /**
   * 获得可视域分析在对应视口的可见性
   */
  getVisibleInViewport(index: number): boolean

  /**
   * 移除所有裁剪区域
   */
  removeAllClipRegion(): boolean

  /**
   * 移除裁剪区域
   * @param name 区域名称
   */
  removeClipRegion(name: string): boolean

  /**
   * set the direction by point(longitude, latitude and height)
   * @param position 
   */
  setDistDirByPoint(position: array)

  /**
   * 设置可视域分析在对应视口的可见性
   * @param index 指定的视口索引
   */
  setVisibleInViewport(index: number): void
}

/**
 * 飞行管理类，控制飞行的开始、暂停、停止以及站点事件等
 * @param option.scene 场景对象
 * @param option.routes 飞行路线集合对象（从飞行文件中读取的）
 * @example
 * //创建飞行路线集合对象。
  *  var routes = new Cesium.RouteCollection();
  *  //读取飞行文件。
  *  routes.fromFile('./test.fpf');
  *  //创建飞行管理对象。
  *  var fm = new Cesium.FlyManager({
  *      scene : scene,
  *      routes : routes
  *  });
 */
export class FlyManager {
  constructor(option: { scene: Scene, routes: RouteCollection })

  /**
   * 获取当前飞行路线
   */
  currentRoute: Route

  /**
   * 获取或者设置当前站点索引（指定从该站点开始飞行
   */
  currentStopIndex: Number

  /**
   * 获取或者设置飞行路线的飞行速率，大于1.0加速，小于1.0减速
   */
  playRate: Number

  /**
   * 获取飞行路线的就绪状态的promise
   */
  readyPromise: Promise

  /**
   * 获取或者设置当前路线集合对象
   */
  routes: RouteCollection

  /**
   * 获取站点到达事件
   */
  stopArrived: Event

  /**
   * 获取当前飞行路线的所有站点
   * @returns 返回所有站点集合数组
   */
  getAllRouteStops(): array

  /**
   * 暂停飞行
   */
  pause()

  /**
   * 开始飞行
   */
  play()

  /**
   * 停止飞行
   */
  stop()

  /**
   * 站点定位
   * @param stop 相机定位到该站点
   */
  viewToStop(stop: RouteStop): void
}

//相机飞行拐弯模式
export enum TurningMode {
  /**
   * 平滑拐弯
   * @type {Number}
   */
  Smoothly = 0,
  /**
   * 直接拐弯
   * @type {Number}
   */
  Directly = 1
};

/**
 * 飞行路线对象类
 * @param option.isStopVisible 是否循环飞行
 * @param option.isFlyLoop 是否循环飞行
 * @param option.isLineVisible 飞行路线是否可见
 * @param option.routeName 飞行路线名称
 * @param option.speed 飞行速度
 * @param option.isAlongline 是否沿线飞行
 * @param option.totalDuration 总共的飞行时间
 */
export class Route {
  constructor(option: {
    isStopVisible: boolean,
    isFlyLoop: boolean,
    isLineVisible: boolean,
    routeName: string,
    speed: number,
    isAlongline: boolean,
    totalDuration: number,
  })

  /**
   * 获取或者设置该飞行路线是否是沿线飞行
   */
  isAlongline: boolean

  /**
   * 获取或者设置相机高度是否锁定
   */
  isAltitudeFree: boolean

  /**
   * 获取或者设置该飞行路线是否循环飞行
   */
  isFlyLoop: boolean

  /**
   * 获取或者设置相机是否锁定方位角
   */
  isHeadingFree: boolean

  /**
   * 获取或者设置该飞行路线的路径是否可见
   */
  isLineVisible: boolean

  /**
   * 获取或者设置该飞行路线的站点是否可见
   */
  isStopVisible: boolean

  /**
   * 获取或者设置相机是否锁定俯仰角
   */
  isTiltFree: boolean

  /**
   * 获取或者设置该飞行路线的名称
   */
  routeName: string

  /**
   * 获取或者设置该飞行路线的飞行速度，优先以站点速度为准（单位：m/s）
   */
  speed: number

  /**
   * 获取该飞行路线的所有站点集合
   */
  stopCollection: array

  /**
   * 获取该飞行路线的站点个数
   */
  stopCount: number

  /**
   * 获取或者设置该飞行路线总共飞行时间(单位：秒)
   */
  totalDuration: number

  /**
   * 添加站点
   * @param stop 站点对象
   */
  addStop(stop: RouteStop): boolean

  /**
   * 通过索引获取该飞行路线的站点
   * @param index 站点索引
   */
  get(index: number): RouteStop

  /**
   * 移除飞行站点，参数为站点对象
   * @param stop - 站点对象
   */
  removeStop(stop: object)
}

/**
 * 飞行路线集合对象类
 * @example 
 * //创建飞行路线集合对象。
 *  var routes = new Cesium.RouteCollection(entityCollection);
 *   //读取记录飞行路线的文本文件。
 *   routes.fromFile('./test.fpf');
 */
export class RouteCollection {
  constructor(entityCollection: EntityCollection)

  /**
   * 获取路线集合是否准备就绪
   */
  ready: boolean
  /**
   * 获取路线集合数组
   */
  routes: array

  /**
   * 添加路线对象
   * @param route 路线对象
   */
  addRoute(route: Route)

  /**
   * 异步加载记录飞行路线的fpf文本文件
   * @param url fpf文本文件路径url
   */
  fromFile(url: string)

  /**
   * 读取解析记录飞行路线的fpf文本文件
   * @param xml 记录飞行路线的fpf文本文件
   * @example 
   * var routes = new Cesium.RouteCollection();
   *   var XMLContent = "......";
   *  routes.fromXML(XMLContent);
   */
  fromXML(xml: string)

  /**
   * 通过索引获取飞行路线
   * @param index 索引
   */
  get(index: number): Route
}

/**
 * 飞行站点对象类。飞行路线由多个飞行站点构成
 * @param options.duration 当前站点到下一站点所持续的时间
 * @param options.isExcluded 当前站点是否被排除。（暂不支持）
 * @param options.waitTime 在本站点停留的时间
 * @param options.point 本站点的位置
 * @param options.heading 当前站点到下一站点所持续的时间
 * @param options.tilt 当前站点到下一站点所持续的时间
 * @param options.stopName 当前站点到下一站点所持续的时间
 * @param options.distanceToNext 当前站点到下一站点所持续的时间
 * @param options.speed 当前站点到下一站点所持续的时间
 */
export class RouteStop {
  constructor(options: {
    duration: number,
    isExcluded: boolean,
    waitTime: number,
    point: Cartesian3,
    heading: number,
    tilt: number,
    stopName: string,
    distanceToNext: number,
    speed: number
  })

  /**
   * 获取或设置当前站点到下一站点的飞行持续时间（单位：秒）
   */
  duration: number

  /**
  * 获取或者设置当前站点的相机heading角度（单位：弧度）
  */
  heading: number

  /**
   * 获取当前站点的索引
   */
  index: Number

  /**
   * 获取或者设置当前站点的位置
   */
  point: Cartesian3

  /**
   * 获取或者设置当前站点的promise，用于异步操作站点事件
   * @example 
   * flyManager.stopArrived.addEventListener(function(routeStop){
         audioEle.play();
         var defer = Cesium.when.defer();
         //播放音频的异步处理
         routeStop.promise = defer;
         audioEle.onended = function(){
              defer.resolve(true);
              routeStop.promise = undefined;
            };
          });
   */
  promise: object

  /**
   * 获取或设置当前站点的飞行速度（单位：米/秒）
   */
  speed: number

  /**
   * 获取或设置当前的站点名称
   */
  stopName: string

  /**
   * 获取或者设置当前站点动作模式,包括暂停和旋转
   */
  stopPlayMode: string

  /**
   * 获取或者设置当前站点环绕飞行时间
   */
  surroundDuration: number

  /**
   * 获取或者设置当前站点的相机的tilt角度（单位：弧度）
   */
  tilt: number

  /**
   * 获取或者设置当前站点的等待时间（单位：秒）
   */
  waitTime: number
}

/**
 * 站点模式,包括普通模式和环绕飞行模式
 */
export enum StopPlayMode {
  /**
  * 普通模式
  */
  StopPause = 'StopPause',
  /**
  * 站点环绕模式
  */
  StopAround = 'StopAround'
}

/**
 * 三维布告板对象类
 */
export class GeoBillboard {
  /**
   * 获取或设置布告板的高度，单位：像素
   */
  geoHeight: number

  /**
   * 获取或设置布告板图片的存储路径
   */
  geoImagePath: String

  /**
   * 获取或设置布告板的宽度，单位：像素
   */
  geoWidth: number
}

/**
 * 三维长方体几何对象类。该类用于在三维图层上绘制长方体几何对象
 * @param length 长方体的长度，单位：米
 * @param width 长方体的宽度，单位：米
 * @param height 长方体的高度，单位：米
 */
export class GeoBox {
  constructor(length: number, width: number, height: number)

  /**
   * 获取或设置长方体的高度，单位：米
   */
  geoHeight: number

  /**
   * 获取或设置长方体的长度，单位：米
   */
  geoLength: number

  /**n
   * 获取或设置长方体的宽度，单位：米
   */
  geoWidth: number

  /**
   * 获取长方体几何对象的中心点
   */
  getCenter(): number

  /**
   * 获取长方体几何对象是否有效
   */
  isValid(): boolean
}

export class GeoCircle3D {
  constructor(radius: number)

  init(radius: number): void

  isValid(): void

  getCenter(): void
}

/**
 * 三维椎体几何对象类
 * @param bottomRadius 椎体底部圆的半径，单位：米
 * @param height 椎体的高度，单位：米
 */
export class GeoCone {
  constructor(bottomRadius: number, height: number)

  /**
   * 获取或设置椎体底部圆的半径，单位：米
   */
  geoBottomRadius: number

  /**
   * 获取或设置椎体的高度，单位：米
   */
  geoHeight: number

  /**
   * 获取或者设置模型的旋转风格。目前主要支持绕顶点旋转和绕模型中心点旋转两种，默认值为绕中心点旋转
   */
  rotateOrigin: RotationOrigin

  /**
   * 克隆三维椎体几何对象
   * @returns 返回新的三维椎体几何对象
   */
  clone(): object
}

/**
  * 三维圆柱体几何对象类
  * @param topRadius  圆柱体顶部圆的半径，单位：米
  * @param bottomRadius 圆柱体底部圆的半径，单位：米
  * @param height 圆柱体的高度，单位：米
  */
export class GeoCylinder {
  constructor(topRadius: number, bottomRadius: number, height: number)

  /**
   * 获取或设置圆柱体底部圆的半径，单位：米
   */
  geoBottomRadius: number

  /**
   * 获取或设置圆柱体的高度，单位：米
   */
  geoHeight: number

  /**
   * 获取或设置圆柱体顶部圆的半径，单位：米
   */
  geoTopRadius: number

  /**
   * 克隆三维圆柱体几何对象
   * @returns 返回新的三维圆柱体几何对象
   */
  clone(): object
}


/**
   * 三维椭球体几何对象类
   * @param xAxis 椭球体x轴方向的长度，单位：米
   * @param yAxis 椭球体y轴方向的长度，单位：米
   * @param zAxis 椭球体z轴方向的长度，单位：米
   */
export class GeoEllipsoid {
  constructor(xAxis: number, yAxis: number, zAxis: number)

  /**
   * 获取或设置椭球体x轴方向的长度，单位：米
   */
  geoXAxis: number

  /**
   * 获取或设置椭球体y轴方向的长度，单位：米
   */
  geoYAxis: number

  /**
   * 获取或设置椭球体z轴方向的长度，单位：米
   */
  geoZAxis: number

  /**
   * 获取椭球体几何对象的中心点
   * @returns 椭球体几何对象的中心点地理坐标值
   */
  getCenter(): number

  /**
   * 获取椭球体几何对象是否有效
   * @returns 如果椭球体几何对象有效则返回 true，否则返回 false
   */
  isValid(): boolean
}

/**
 * 三维线对象类。它是由三维点串构成的线对象，这些点可以不在同一平面上。线对象由一个或多个部分组成，每个部分称为线对象的一个子对象。每个子对象由一个 Point3D 数组来表示
 * @param  point3DsArray Point3Ds数组
 */
export class GeoLine3D {
  constructor(point3DsArray: array)

  /**
   * 获取三维线对象的子对象个数
   */
  partCount: number

  /**
   * 向三维线对象中追加一个子对象
   * @param point3Ds 三维线子对象的点串
   * @returns 如果成功，则返回添加的子对象的索引号；如果失败，则返回-1
   */
  addPart(point3Ds: object): number

  /**
   * 获取三维线对象中指定索引号的子对象的三维点对象数组
   * @param index 三维线对象中子对象的索引号（大于等于零
   * @returns 如果成功，则返回 Point3Ds 对象；如果失败，则返回空值
   */
  getPart(index: number): Object
}

/**
   * 三维几何对象抽象类。它是三维几何类的基类，提供了基本三维几何类的属性和方法。通过本类可以对三维几何对象的姿态进行控制，包括对象的位置、旋转角度、缩放比例
   * @param option.rotationX 三维几何对象绕 X 轴的旋转角度，采用的坐标系以球心为原点，北方向为 Y 轴的右手坐标系
   * @param option.rotationY 三维几何对象沿 Y 轴方向的旋转角度。采用的坐标系以球心为原点，北方向为 Y 轴的右手坐标系
   * @param option.rotationZ 三维几何对象沿 Z 轴方向的旋转角度。采用的坐标系以球心为原点，北方向为 Y 轴的右手坐标系
   * @param option.scaleX 三维几何对象沿 X 轴方向的缩放比例。采用的坐标系以球心为原点，北方向为 Y 轴的右手坐标系
   * @param option.scaleY 三维几何对象沿 Y 轴方向的缩放比例。采用的坐标系以球心为原点，北方向为 Y 轴的右手坐标系
   * @param option.scaleZ 三维几何对象沿 Z 轴方向的缩放比例。采用的坐标系以球心为原点，北方向为 Y 轴的右手坐标系
   * @param option.position 三维几何对象的位置。该位置的坐标值是三维几何对象外接长方体底面中心点的三维坐标值。这个底面中心点用来控制三维几何对象在地球上放置位置
   * @param option.id 三维几何对象的Id
   * @param option.type 三维几何对象的类型
   */
export class Geometry3D {
  constructor(option: {
    rotationX: number,
    rotationY: number,
    rotationZ: number,
    scaleX: number,
    scaleY: number,
    scaleZ: number,
    position: object,
    id: number,
    type: number
  })

  /**
   * 获取或设置三维几何对象的Id
   */
  geoId: number

  /**
   * 获取或设置三维几何对象的位置
   */
  geoPosition: Point3D

  /**
   * 获取或设置三维几何对象绕 X 轴的旋转角度，单位：度
   */
  geoRotationX: Number

  /**
   * 获取或设置三维几何对象绕 Y 轴的旋转角度，单位：度
   */
  geoRotationY: Number

  /**
   * 获取或设置三维几何对象绕 Z 轴的旋转角度，单位：度
   */
  geoRotationZ: Number

  /**
   * 获取或设置三维几何对象沿 X 轴方向的缩放比例
   */
  geoScaleX: Number

  /**
   * 获取或设置三维几何对象沿 Y 轴方向的缩放比例
   */
  geoScaleY: Number

  /**
  * 获取或设置三维几何对象沿 Z 轴方向的缩放比例
  */
  geoScaleZ: Number

  /**
    * 获取三维几何对象的类型
    */
  geoType: String

  /**
   * geometry是否需要更新
   */
  isGeometryDirty: Boolean

  /**
   * geometry插入点是否是经纬度
   */
  isLatLon: Boolean

  /**
   * 矩阵
   */
  modelMatrix: Matirx4

  /**
   * 获取三维几何对象的地理范围，即三维几何对象的最小外接矩形，点的最小外接矩形就是点本身
   */
  getBounds()
}

/**
 * 三维模型对象类。空间查询时，可以设置GeoModel3D为查询对象
 */
export class GeoModel3D {
  /**
   * 获取或设置三维模型文件的存储路径
   */
  geoFilePath: string

  /**
   * 获取或者设置S3M模型文件数据，用来对接服务端下载的S3M流
   */
  geoModel: object
}

/**
 * 三维地理点几何对象类。该类用于表示点状地理要素 Feature3D 的空间信息，当赋予点状地理要素 Feature3D 一定风格时，即可将点状地理要素显示在三维场景中，它的空间位置就由 GeoPoint3D 决定。它与 Point3D 的区别是：Point3D 只能描述一个位置点
 * @param x 三维地理点几何对象的 X 坐标值，即经度坐标，单位：度
 * @param y 三维地理点几何对象的 Y 坐标值，即纬度坐标，单位：度
 * @param z 三维地理点几何对象的 Z 坐标值，即高度，单位：米
 */
export class GeoPoint3D {
  constructor(option: {
    x: number,
    y: number,
    z: number
  })

  /**
   * 获取或设置三维地理点几何对象的 X 坐标值，即经度坐标，单位：度
   */
  X: number

  /**
   * 获取或设置三维地理点几何对象的 Y 坐标值，即纬度坐标，单位：度
   */
  Y: number

  /**
   * 获取或设置三维地理点几何对象的 Z 坐标值，即高度，单位：米
   */
  Z: number
}

/**
 * 垂线类，根据两个经纬度的点绘制模型
 */
export class GeoPolyline {

}

/**
 * 三维面对象类。三维面几何对象由一个或多个部分组成，每个部分称为三维面几何对象的一个子对象，每个子对象用一个有序三维坐标点集合 Point3Ds 来表示，其起始点和终止点重合
 * @param point3DsArray Point3Ds数组。
 */
export class GeoRegion3D {
  constructor(point3DsArray: array)

  /**
   * 底部高程
   */
  bottomAltitude: number

  /**
   * 拉伸后的封底
   */
  closeBottom: Boolean

  /**
   * 拉伸后的封顶
   */
  closeTop: Boolean

  /**
   * 拉伸高度
   */
  extrudedHeight: number

  /**
   * 获取三维面几何对象的子对象个数
   */
  partCount: number

  /**
   * 向三维面对象中追加一个子对象
   * @param point3Ds 向三维面对象中追加一个子对象
   */
  addPart(point3Ds: object): number

  /**
   * 获取三维面对象中指定索引号的子对象的三维点对象数组
   * @param index 	三维面对象中子对象的索引号（大于等于零
   */
  getPart(index: number): object
}

/**
 * 三维球体几何对象类
 * @param radius 三维球体的半径，单位：米
 */
export class GeoSphere {
  constructor(radius: number)

  /**
   * 获取或设置三维球体的半径，单位：米
   */
  geoRadius: number

  /**
   * 获取球体几何对象的中心点
   */
  getCenter(): number

  /**
   * 获取球体几何对象是否有效
   */
  isValid(): Boolean

}

/**
 * 三维点对象类。该对象用于表示地理坐标系下坐标值精度为 Double 的三维点对象，即其坐标值大致范围为 ±5.0×1E−324 到 ±1.7×1E308，有效位为15-16位，单位为经纬度。三维点对象是三维几何对象的基础
 * @param x 三维点对象的经度坐标值，单位：度
 * @param y 三维点对象的纬度坐标值，单位：度
 * @param z 三维点对象的高度坐标值，单位：米
 */
export class Point3D {
  constructor(x: number, y: number, z: number)
}

/**
 * 向三维点集合对象中追加三维点对象
 * 
 */
export class Point3Ds {
  /**
   * 向三维点集合对象中追加三维点对象
   * @param point3D 向三维点集合对象中追加三维点对象
   */
  add(point3D: object): Number

  /**
   * 清除三维点集合对象中的所有元素
   */
  removeAll(): void
}

/**
 * Box编辑器类，用于对box进行编辑，可以对该编辑器进行激活、失效以及销毁等操作
 * @param viewer 	当前的viewer
 * @param box 		拟编辑的box对象，对该对象设置编辑器
 */
export class BoxEditor {
  constructor(viewer: Viewer, box: Entity)

  /**
   * 获取或者设置盒子的颜色
   */
  color: Color

  /**
   * 激活box编辑器
   */
  activate()

  /**
   * 使box编辑器失效
   */
  deactivate()

  /**
   * 销毁box编辑器
   */
  destroy()

  /**
   * 为编辑器设置编辑对象
   * @param editObject 拟编辑的box对象
   */
  setEditObject(editObject): void
}

/**
 * 绘制、量算的几何对象的风格
 */
export enum ClampMode {
  /**
   * 贴地模式
   */
  Ground,
  /**
   * 栅格化模式
   */
  Raster,
  /**
   * 贴对象模式
   */
  S3mModel,
  /**
   * 空间模式
   */
  Space
}

/**
 * 绘制处理器对象类。支持栅格化面对象的绘制
 * @param viewer	viewer对象
 * @param mode		绘制模式，包含点、线、面、图标
 * @param clampMode	clampMode 绘制风格，包含空间、贴地、贴对象（S3M模型）
 * @example 
 * var handler = new Cesium.DrawHandler(viewer,Cesium.DrawMode.Line,ClampMode.Ground);
 * handler.activate();
 */
export class DrawHandler {
  constructor(viewer: Viewer, mode: DrawMode, clampMode: ClampMode)

  /**
   * 绘制handler的激活事件
   * @example 
   * handler.activeEvt.addEventListener(function(result){});
   */
  activeEvt: Event

  /**
   * 获取或者设置绘制几何对象的风格，空间、贴地、贴对象
   */
  clampMode: number

  /**
   * 绘制完成事件,监听绘制完成的事件，获取当前绘制结果。
    当绘制模式为DrawMode.Point,事件回调的结果是{object : point}。
    当绘制模式为DrawMode.Polygon,事件回调的结果是{object : polygon}。
    当绘制模式为DrawMode.Line,事件回调的结果是{object : polyline}。
    当绘制模式为DrawMode.Marker,事件回调的结果是{object : marker}。
    @example 
    handler.drawEvt.addEventListener(function(result){
        console.log(result);
    });
   */
  drawEvt: Event

  /**
   * 设置绘制的图元是否开启深度检测，默认开启
   */
  enableDepthTest: Boolean

  /**
   * 绘制handler的移动事件
   * @example 
   * handler.movingEvt.addEventListener(function(result){});
   */
  movingEvt: Event

  /**
   * 激活handler
   */
  activate()

  /**
   * 清除所有图元
   */
  clear()

  /**
   * 使handler无效
   */
  deactivate()
}

/**
 * 绘制模式类
 */
export enum DrawMode {
  /**
   * 绘制盒子
   */
  Box,

  /**
   * 绘制线
   */
  Line,

  /**
   * 绘制图标
   */
  Marker,

  /**
   * 绘制点
   */
  Point,

  /**
   * 绘制面
   */
  Polygon
}

/**
 * 编辑对象
 * @param viewer viewer对象
 * @param editObject 被编辑对象
 * @example 
 *  var handler = new Cesium.EditHandler(viewer,editObject);
 *  handler.activate();
 */
export class EditHandler {
  constructor(viewer: Viewer, editObject: Entity)

  /**
   * 用于监听编辑线面后的变化
   */
  changedEvt: Event

  /**
   * 获取或者设置线面支持编辑高度
   */
  isEditZ: Boolean
}

/**
 * 量测处理器类
 * @param viewer 指定用于量测的视图
 * @param mode 	指定量测模式
 * @param clampMode 指定几何对象的风格（贴地，贴对象）
 * @example 
 *  var handler = new MeasureHandler(viewer,Cesium.MeasureMode.Distance);
 *   handler.activate();
 *   handler.measureEvt.addEventListener(function(obj){
 *      console.log(obj);
 *   });
 */
export class MeasureHandler {
  constructor(viewer: Viewer, mode: MeasureMode, clampMode: ClampMode)

  /**
   * 激活事件，监听当前事件以获取处理器的状态
   */
  activeEvt: Event

  /**
   * 当量测模式为Area,利用此标签实体对象 areaLabel 来显示面积量算结果
   */
  areaLabel: Entity

  /**
   * 获取或设置量算时点云捕捉点的颜色
   */
  capturePointColor: Color

  /**
   * 获取或设置量算时点云捕捉点的大小
   */
  capturePointSize: number

  /**
   * 贴对象模式
   */
  clampMode: ClampMode

  /**
   * 当量测模式为Distance,利用此标签实体对象disLabel来显示空间距离量算结果
   */
  disLabel: Entity

  /**
   * 设置绘制对象是否开启深度检测，默认开启
   */
  enableDepthTest: boolean

  /**
   * 获取或设置量算时指定几何对象的线颜色
   */
  fillColor: position

  /**
   * 获取或设置量算时线的类型
   */
  lineDisplayType: LineDisplayType

  /**
   * 获取或设置量算时指定几何对象的线宽
   */
  lineWidth: position

  /**
   * 量测事件，监听当前事件以获取测量结果。 当量测模式为MeasureMode.Distance时，回调结果为{distance : distance}。 当量测模式为MeasureMode.Area时，回调结果为{area : area,positions : positions}。 当量测模式为MeasureMode.DVH时，回调结果为{distance : distance,verticalHeight : vHeight,horizontalDistance : hHeight}
   * @example 
   * var handler = new Cesium.MeasureHandler(viewer,Cesium.MeasureMode.Area);
   *  handler.measureEvt.addEventListener(function(result){
   * var area = result.area > 1000000 ? result.area/1000000 + 'km²' : result.area + '㎡'
   * handler.areaLabel.text = 'area:' + area;
   *  });
   */
  measureEvt: Event

  /**
   * 当量测模式为DVH或Height,利用此标签实体对象 vLabel 来显示垂直高度量算结果
   */
  vLabel: Entity

  /**
   * 根据一系列笛卡尔坐标点计算面积，单位m2（平方米）
   * @param positions  面上各个点的坐标
   */
  computeArea(positions: any): void

  /**
   * 激活量测处理器
   */
  activate(): void

  /**
   * 清除所有关于量测的要素
   */
  clear(): void

  /**
   * 关闭量测处理器
   */
  deactivate()
}

/**
 * 量算模式类
 */
export enum MeasureMode {
  /**
   * 面积量算模式
   */
  Area,

  /**
   * 距离量算模式
   */
  Distance,

  /**
   * 空间距离、水平距离、垂直距离三分量量算模式（测高）
   */
  DVH
}

/**
 * 光源类
 */
export class LightSource {
  /**
   * 获取或设置环境光颜色
   * 
   */
  ambientLightColor: Color

  /**
   * 获取平行光源
   */
  directionalLight: DirectionalLight

  /**
   * 获取点光源
   */
  pointLight: PointLight

  /**
   * 获取聚光灯
   */
  spotLight: SpotLight

  /**
   * 获取或设置光照
   */
  sunLightON: Number

  /**
   * 设置灯光最大可见距离
   */
  visibleDistanceMax: Number
}

/**
 * 光源类型
 */
export enum LightSourceType {
  /**
   * 平行光
   */
  DIRECTIONAL,

  /**
   * 点光源
   */
  POINT,

  /**
   * 聚光灯
   */
  SPOT
}

/**
 * 点光源
 * @param position 点光源位置
 * @param options.color  光源颜色,默认白色
 * @param options.cutoffDistance  点光源的扩散距离,默认10米
 * @param options.decay  点光源衰减因子,越小随着距离衰减越小，越亮
 * @param options.intensity	 点光源强度
 */
export class PointLight {
  constructor(position: Cartesian3, options: {
    color: Color,
    cutoffDistance: Number,
    decay: Number,
    intensity: Number
  })

  /**
   * 获取或设置光源颜色,默认白色
   */
  color: Color

  /**
   * 获取或设置点光源的扩散距离,默认10米
   */
  cutoffDistance: Number

  /**
   * 获取或设置点点光源衰减因子,越小随着距离衰减越小，越亮
   */
  decay: Number

  /**
   * 获取点光源id
   */
  id: Number

  /**
   * 获取或设置点光源强度
   */
  intensity: Number

  /**
   * 获取点光源颜色
   */
  lightColor: Color

  /**
   * 获取或设置点光源位置，使用世界坐标系
   */
  position: Cartesian3
}

/**
 * 聚光灯
 * @param position 光源位置
 * @param targetPosition	目标点位置，决定聚光方向
 * @param options.color 光源颜色
 * @param options.intesity 光强度
 * @param options.distance 光能到达的距离，默认100米
 * @param options.decay 光源衰减因子，越小，随着距离衰减越小，也就越亮
 */
export class SpotLight {
  constructor(position: Cartesian3, targetPosition: Cartesian3, options: {
    color: Color,
    intesity: Number,
    distance: Number,
    decay: Number,
  })

  /**
   * 获取或设置聚光范围，默认Math.PI / 6，单位弧度
   */
  angle: Number

  /**
   * 获取或设置光源颜色,默认白色
   */
  color: Color

  /**
   * 获取或设置聚光灯光源衰减因子，越小，随着距离衰减越小，也就越亮
   */
  decay: Number

  /**
   * 获取聚光灯的方向
   */
  direction: Cartesian3

  /**
   * 获取或设置聚光灯光能到达的距离，默认100米
   */
  distance: Number

  /**
   * 获取聚光灯id
   */
  id: Number

  /**
   * 获取或设置聚光灯的光强度
   */
  intensity: Number

  /**
   * 获取聚光灯的颜色
   */
  lightColor: Color

  /**
   * 获取或设置点光源位置，使用世界坐标系
   */
  position: Cartesian3

  /**
   * 获取或设置聚光灯目标点位置，决定聚光方向
   */
  targetPosition: Cartesian3
}

/**
 * @param options.url 影像服务地址
 * @param options.name 影像图层名称
 * @param options.minimumLevel 最小层级
 * @param options.maximumLevel 最大层级
 * @param options.transparent 设置请求的地图服务的参数是否为
 * @param options.credit 影像服务描述信息
 * @param options.tileFormat 影像图片格式，默认为png
 * @param options.cacheKey 影像的三维缓存密钥
 * @example 
 * //创建provider。
 *   var provider = new Cesium.SuperMapImageryProvider({url : URL_CONFIG.ZF_IMG});
 *   //创建影像图层。
 *   var layer = viewer.imageryLayers.addImageryProvider(provider);
 */
export class SuperMapImageryProvider {
  constructor(options: {
    url: String,
    name: String,
    minimumLevel: number,
    maximumLevel: number,
    transparent: boolean,
    credit: string,
    tileFormat: string,
    cacheKey: string
  })

  /**
   * 获取该影像服务的描述信息对象
   */
  credit: Credit

  /**
   * 获取最大层级（LOD调度时可以请求的最大层级）
   */
  maximumLevel: Number

  /**
   * 获取最小层级（LOD调度时可以请求的最小层级）
   */
  minimumLevel: Number

  /**
   * 获取该影像服务是否就绪
   */
  ready: Boolean

  /**
   * 获取该服务的请求状态的promise
   */
  readyPromise: Promise

  /**
   * 获取该影像服务的矩形范围
   */
  rectangle: Rectangle

  /**
   * 获取或者设置子域名称。通过该接口可以向指定的子域请求数据
   */
  subdomains: String

  /**
   * 获取丢弃影像切片颜色比例
   */
  tileDiscardPolicy: DiscardColorTileImagePolicy

  /**
   * 获取请求切片格式
   */
  tileFormat: Format

  /**
   * 获取切片高度
   */
  tileHeight: Number

  /**
   * 获取切片宽度
   */
  tileWidth: Number

  /**
   * 获取投影方式（支持经纬度投影和墨卡托投影）
   */
  tilingScheme: TilingScheme

  /**
   * 获取影像服务的url
   */
  url: String

  /**
   * 设置地图子图层的过滤条件
   * @param v 过滤条件的数组
   */
  setLayerStatusParameters(v: array): void
}

/**
 * 天地图影像服务提供者类
 * @param options.mapStyle 指定天地图服务类型
 * @example 
 * var labelImagery = new Cesium.TiandituImageryProvider({
 *    mapStyle : Cesium.TiandituMapsStyle.CIA_C//天地图全球中文注记服务（经纬度投影）
*	});
 */
export class TiandituImageryProvider {
  constructor(options: {
    mapStyle: TiandituMapsStyle
  })

  /**
   * 获取服务的描述信息
   */
  credit: String

  /**
   * 错误事件
   */
  errorEvent: String

  /**
   * 获取服务类型
   */
  mapStyle: String

  /**
   * 获取可以请求的最大细节层次(LOD)
   */
  maximumLevel: Number

  /**
   * 获取可以请求的最小细节层次(LOD)
   */
  minimumLevel: Number

  /**
   * 获取瓦片高度
   */
  tileHeight: Number

  /**
   * 获取服务的url
   */
  url: String
}

/**
 * 天地图服务类型常量
 */
export enum TiandituMapsStyle {
  /**
   * 天地图全球中文注记服务（经纬度投影）
   */
  CIA_C,
  /**
   * 天地图全球中文注记服务（墨卡托投影）
   */
  CIA_W
}

/**
 * 天地图三维地形服务类。通过该类，可以添加由天地图服务器发布的三维地形服务
 * @param options.token 天地图地形服务的密钥
 * @param options.minimumLevel 最小数据层级
 * @param options.maximumLevel 最大数据层级
 */
export class TiandituTerrainProvider {
  constructor(options: {
    token: string,
    minimumLevel: number,
    maximumLevel: number
  })
}

/**
 * 缓存管理
 */
export class BufferManager {
  /**
   * VBO（顶点缓存对象）占用的最大缓存，单位MB
   */
  maxVBOSize
}

/**
 * DDS纹理对象
 * @param gl 
  * @param width 
  * @param height 
  * @param imageBuffer 
 */
export class DDSTexture {
  constructor(gl: WebGLRenderingContext, width: number, height: number, imageBuffer: Array)

  /**
   * 释放资源
   */
  destroy(): void

  /**
   * 激活纹理单元
   */
  enable(): void

  /**
   * 初始化DDS纹理
   */
  initTexture(): void

  /**
   * 更新纹理
   */
  updateTexture(): void
}


/**
 * DDS纹理管理
 */
export class DDSTextureManager {
  /**
   * 保留的纹理显存大小，单位MB
   */
  reservedMemorySize: number

  /**
   * 初始化DDS纹理
   */
  CreateTexture(): void
}

/**
 * 动态图层，一个动态图层可以包含多种类型的模型，每种模型又能包含多个实例，每个实例以一定刷新间隔更新状态信息DynamicObjectState，从而达到动态效果
 * @param context webgl context对象
 * @param urls 模型url数组
 * @example 
 * var uls = ['model1.s3m','model2.s3m'];
* var layer = new DynamicLayer3D(context,urls);
* scene.primitives.add(layer);
 */
export class DynamicLayer3D {
  constructor(context: Context, urls: array)

  /**
   * 设置是否支持模型局部偏移（模型自带偏移矩阵
   */
  enableLocalOffset: boolean

  /**
   * 获取或设置子对象过滤模式，默认为距离模式
   */
  filterMode: Mode

  /**
   * 获取或设置子对象过滤像素,默认为0
   */
  filterPixel: Number

  /**
   * 获取动态图层的所有模型分组集合{url:object}
   */
  group: Object

  /**
   * 获取或者设置动态图层的最大可见高度
   */
  maxVisibleAltitude: Number

  /**
   * 获取或设置对象过滤的最大可见距离
   */
  maxVisibleDistance: Number

  /**
   * 获取或者设置阴影模式。默认值为NONE
   */
  shadowType: ShadowType

  /**
   * 获取该图层类型标识
   */
  type: String

  /**
   * 获取或者设置动态图层的刷新间隔时间，单位ms
   */
  updateInterval: Number

  /**
   * 获取或者设置动态图层的可见性
   */
  visible: Boolean

  /**
   * 清除该动态图层所有动态实例对象的状态信息,在下次更新状态之前，所有动态实例都不被渲染
   * @example 
   * layer.clearAllState();
   */
  clearAllState(): void

  /**
   * 根据模型url和动态实例ID，清除该类型模型指定ID的动态实例的状态信息，下次更新状态之前，该实例不被渲染
   * @param url 模型url
   * @param ids 动态实例ids
   * @example 
   * layer.clearState('ship.s3m',[1]);
   */
  clearState(url: string, ids: array)

  /**
   * 删除该动态图层所有动态实例对象，在下次更新状态之前，所有动态实例都不被渲染
   * @example
   * layer.deleteAllObjects();
   */
  deleteAllObjects(): void

  /**
   * 根据模型url和动态实例ID，删除指定类型的对应ids的实例对象，下次再次更新相同id的状态，将不会在渲染对应id的对象
   * @param url 模型url
   * @param ids 动态实例ids
   * @example 
   * layer.deleteObjects('ship.s3m',[1]);
   */
  deleteObjects(url: string, ids: Array): void

  /**
   * 释放webgl资源。一旦释放对象资源, 它将不能被使用;调用任何方法将会抛出DeveloperError异常
   * @example 
   * layer = layer && layer.destroy();
   */
  destroy(): void

  /**
   * 获取是否开启单双面渲染
   * @param url 模型url
   */
  getCullEnabled(url: string) : boolean

  /**
   * 设置是否开启单双面渲染
   * @param url 模型url
   * @param enabled 是否开启单双面渲染
   */
  setCullEnabled(url: string, enabled: boolean)

  /**
   * 根据动态图层的url设置url对应的模型实例是否可选
   * @param url 动态图层的url
   * @param enable 其值为true时可选，为false时不可选
   */
  setPickEnable(url: string, enable: boolean)

  /**
   * 取消所有实例的选中状态
   */
  setUnSelected()

  /**
   * 根据url设置该图层下指定模型类型的所有实例的可见性
   * @param modelUrl 模型url（指定模型类型）
   * @param isVisible 是否可见
   * @example 
   * //设置model.s3m类型的所有实例不可见。
   *  layer.setVisibleByUrl('model.s3m',false);
   */
  setVisibleByUrl(modelUrl: string, isVisible: boolean)

  /**
   * 根据指定模型类型（url）更新对象状态信息
   * @param url 模型类型url
   * @param arrStates 状态信息（DynamicObjectState）数组
   * @example 
   * //更新model.s3m类型实例的状态信息
    * var states = [];
    * states.push(new DynamicObjectState({id : 1,longitude : 100,latitude : 10}));
    * states.push(new DynamicObjectState({id : 2,longitude : 101,latitude : 11}));
    * layer.updateObjectWithModel('model.s3m',states);
   */
  updateObjectWithModel(url: string, arrStates: Array)

}

/**
 * 动态实例对象状态信息，用于更新动态图层中的指定id模型实例的状态
 * @param options.longitude 经度
 * @param options.latitude	 纬度
 * @param options.altitude 高度
 * @param options.scale 缩放系数
 * @param options.color 颜色
 * @param options.heading 绕Z轴旋转的角度（弧度）
 * @param options.pitch 绕X轴旋转的角度（弧度）
 * @param options.roll 绕Y轴旋转的角度（弧度）
 * @param options.offset 模型中心点的偏移位置
 * @param options.id 对象id
 * @param options.description 描述信息
 */
export class DynamicObjectState {

  constructor(options: {
    longitude: number,
    latitude: number,
    altitude: number,
    scale: 	Cartesian3,
    color: Color,
    heading: number,
    pitch: number,
    roll: number,
    offset: Cartesian3,
    id: number | string,
    description: object | string
  })

  /**
   * 获取或者设置高度
   */
  altitude : Number

  /**
   * 获取或者设置颜色
   */
  color : Color

  /**
   * 获取或者设置描述信息
   */
  description : Object|String

  /**
   * 获取或者设置方位角(绕Z轴旋转)
   */
  heading : Number

  /**
   * 获取或者设置ID
   */
  id : Number | String

  /**
   * 获取或者设置纬度
   */
  latitude : Number

  /**
   * 获取或者设置经度
   */
  longitude : Number

  /**
   * 获取或者设置模型中心点偏移位置
   */
  offset : Cartesian3

  /**
   * 获取或者设置绕X轴旋转角度
   */
  pitch : Number

  /**
   * 获取或者设置绕Y轴旋转角度
   */
  roll : Number

  /**
   * 获取或者设置缩放系数
   */
  scale : Cartesian3

  /**
   * 获取或者设置模型的方位角（指北方向线起依顺时针方向至目标方向线的水平夹角），单位：弧度
   */
  startDirection : Number

  /**
   * 获取或者设置时间戳
   */
  timeStamp : Number

  /**
   * 克隆对象
   * @param state 克隆的源对象
   * @example 
   * var state = DynamicObjectState.clone(oldState);
   */
  clone(state) : DynamicObjectState
}

/**
 * 图层集合类。该类用于对场景中的所有图层进行管理
 */
export class Layers {

  /**
   * 获取图层列表
   */
  layerQueue : Array

  /**
   * 向图层集合添加一个图层
   */
  add(layer): void

  /**
   * 
   * @param name 
   */
  find(name) : Layer

  /**
   * 根据指定索引查找图层对象
   * @param index 指定的图层索引
   */
  findByIndex(index) : Layer

  /**
   * 获取当前点击选中的S3M图层
   */
  getSelectedLayer() : S3MTilesLayer

  /**
   * 向下调整图层顺序，和影像图层集合相对应
   * @param layer 
   */
  lower(layer): void

  /**
   * 
   * @param winpos 位置信息
   * @param scene 场景对象
   */
  pickFeatures(winpos: number, scene: object)

  /**
   * 向上调整图层顺序，和影像图层集合相对应
   * @param layer  待调整的图层
   */
  raise(layer): void

  /**
   * 释放被选择的图层对象
   */
  releaseSelection(): void

  /**
   * 从图层集合中删除指定名称的图层对象
   * @param layer 待删除的图层名称
   * @param destroy 指定删除时是否释放资源。
   */
  remove(layer, destroy) : Boolean

  /**
   * 删除图层集合中的所有图层对象
   * @param destroy 指定删除时是否释放资源
   */
  removeAll(destroy): void

  /**
   * 设置当前点击选中的S3M图层
   * @param layer 当前点击选中的S3M图层
   */
  setSelectedLayer(layer: S3MTilesLayer)
} 

/**
 * 点云分类信息
 * @param id 点云索引
 * @param type 点云类型
 * @param pointCounts 点云点数
 */
export class PointCloudClassificationInfo {
  constructor(id: number, type: number, pointCounts: number)

  /**
   * 获取或者设置点云索引
   */
  id : Number

  /**
   * 获取或者设置点云点数
   */
  pointCounts : Number

  /**
   * 获取或者设置点云类型
   */
  type : Number
}

/**
 * S3M实例化模型集合类
 * @param context 对象
 */
export class S3MInstanceCollection {
  constructor(context: Context)

  /**
   * addModels函数添加的模型加载完成后触发的事件
   */
   addedEvent()
  
   /**
    * 获取或者设置该图层是否贴对象，默认值为false。
    */
   clampToObject : Boolean

   /**
    * 获取或者设置子对象过滤模式
    */
   filterMode : RangeMode

   /**
    * 获取或者设置过滤像素大小，子对象投影屏幕的像素大小过滤阀值
    */
   filterPixel : Number

   /**
    * 获取该图层所有的模型组
    */
   group : Object

   /**
    * 获取或者设置模型始终显示在屏幕最前面，支持选中。默认值为false
    */
   isOverLay : Boolean

   /**
    * 获取或者设置图层的最大可见高度
    */
   maxVisibleAltitude : number
  
   /**
    * 获取或者设置该图层的最小可见高度
    */
   minVisibleAltitude : Number

   /**
    * 获取或者设置该图层的最小可见距离
    */
   minVisibleDistance : Number

   /**
    * 设置纹理显示模式（混合、替换）
    */
   mixColorType : Number

   /**
    * 获取或者设置该图层的模型矩阵，设置平移、旋转、缩放参数
    */
   modelMatrix : any

   /**
    * 获取或者设置阴影模式。默认值为NONE
    */
   shadowType : ShadowType

   /**
    * 获取该图层类型标识
    */
   type : String
  
   /**
    * 获取或者设置该图层的可见性
    */
   visible : Boolean

   /**
    * 添加一个或者一组实例
    * @param url 模型url
    * @param attrs 实例属性或者实例属性集合
    * @param data 流数据
    * @param streamBytes 是否截取前四个字节
    */
   add(url, attrs, data, streamBytes) : void

   /**
    * 通过ID获取实例对象S3MInstance
    * @param url 实例对象的url
    * @param id 实例对象的id
    */
   getInstance(url: string, id: number)

   /**
    * 获取指定分屏窗口所在的对象
    * @param index 视口索引值，其范围为0~3
    */
   getVisibleInViewport(index: number) : boolean

   /**
    * 移除url对应的所有实例对象
    * @param url 模型的url
    */
   removeCollection(url) : boolean

   /**
    * 移除url模型指定id对应的实例对象
    * @param url 模型的url
    * @param ids 实例对象id列表
    */
   removeInstance(url, ids) : boolean

   /**
    * 用于移除指定实例化模型的PBR材质
    * @param instancePath 为实例化模型的地址
    */
   removePBRMaterial(instancePath): void

   /**
    * 设置单面渲染
    * @param url 模型的url 
    * @param cullFace 是否开启单面渲染
    */
   setCullEnabled(url: string, cullFace: boolean)

   /**
    * 实例化集合支持设置PBR材质
    * @param instancePath 	模型地址
    * @param jsonPath JSON文件地址
    */
   setPBRMaterialFromJSON(instancePath, jsonPath): void

   /**
    * 取消所有实例的选中状态
    */
   setUnSelected(): void

   /**
    * 设置对象在哪个分屏窗口显示
    * @param index 视口索引值，其范围为0~3
    * @param visible 视口可见性
    */
   setVisibleInViewport(index: number, visible: boolean): void

   /**
    * Do not call this function directly.
    */
   update(frameState) : void
}

/**
 * 布告板模式
 */
export enum BillboardMode {
  /**
   * 贴地模式。即布告板贴在球面上
   */
  FixedXYZ,

  /**
   * 轴对齐模式。在这种模式下，布告板在水平方向上会跟着相机旋转，当相机位于布告板的正上方时，看到的就只是一条线， 即是说，这种模式下的布告板只能在水平分量上被选中
   */
  FixedZ,
  
  /**
   * 屏幕对齐模式。即是布告板会在任意方向上随着相机旋转，始终对着屏幕
   */
  None 
}

/**
 * 
 */
export class Style3D {

  /**
   * 获取或设置高度模式
   */
   altitudeMode : HeightReference

   /**
    * 获取或者设置billboard布告板的模式，目前支持贴地、屏幕对齐和轴对齐模式。如果在SuperMap桌面软件中生成S3M缓存时保留了该模式设置， 则WebGL端也支持
    */
   billboardMode : Number

   /**
    * 获取或设置底部高程
    * @example
    * var style3D = new Cesium.Style3D();
    //设置底部高程。
    style3D.bottomAltitude = 10;
    //获取底部高程值。
    var altitude = style3D.bottomAltitude;
    */
   bottomAltitude : Number

   /**
    * 设置或者获取牵引线的颜色
    */
   calloutColor : Color

   /**
    * 设置或者获取牵引线的宽度
    */
   calloutWidth : Number

   /**
    * 获取或者设置自发光体的颜色
    */
   emissionColor : Number

   /**
    * 获取或设置填充前景色
    * @example
    * var style3D = new Cesium.Style3D();
      var color = new Cesium.Color(1.0, 0.0, 0.0);
      //设置填充前景色。
      style3D.fillForeColor = color;
      //获取填充前景色。
      var fillForeColor = style3D.fillForeColor;
    */
   fillForeColor : Color

   /**
    * 获取或者设置填充风格
    */
   fillStyle : Number

   /**
    * 设置或者获取图标的存储路径或数据的网络来源
    */
   image : String

   /**
    * 获取或者设置线颜色
    */
   lineColor : Number

   /**
    * 获取或者设置线宽
    */
   lineWidth : Number

   /**
    * 获取或者设置点的颜色
    */
   pointColor : Number

   /**
    * 获取或者设置点的尺寸
    */
   pointSize : Number
}

